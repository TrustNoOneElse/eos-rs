/* automatically generated by rust-bindgen 0.68.1 */

pub const EOS_USE_DLLEXPORT: u32 = 1;
pub const _STL_COMPILER_PREPROCESSOR: u32 = 1;
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const NULL: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 1;
pub const _STL_WARNING_LEVEL: u32 = 3;
pub const _STL_DISABLED_WARNING_C4984: u32 = 4984;
pub const _STL_DISABLED_WARNING_C5053: u32 = 5053;
pub const _CPPLIB_VER: u32 = 650;
pub const _MSVC_STL_VERSION: u32 = 143;
pub const _MSVC_STL_UPDATE: u32 = 202302;
pub const _HAS_STATIC_RTTI: u32 = 1;
pub const _HAS_STD_BYTE: u32 = 0;
pub const _ENFORCE_MATCHING_ALLOCATORS: u32 = 0;
pub const _ENFORCE_FACET_SPECIALIZATIONS: u32 = 0;
pub const _FACET_SPECIALIZATION_MESSAGE : & [u8 ; 178] = b"Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 to suppress this error.\0" ;
pub const _STL_OPTIMIZE_SYSTEM_ERROR_OPERATORS: u32 = 1;
pub const _STD_VECTORIZE_WITH_FLOAT_CONTROL: u32 = 1;
pub const __cpp_lib_chrono_udls: u32 = 201304;
pub const __cpp_lib_complex_udls: u32 = 201309;
pub const __cpp_lib_exchange_function: u32 = 201304;
pub const __cpp_lib_generic_associative_lookup: u32 = 201304;
pub const __cpp_lib_integer_sequence: u32 = 201304;
pub const __cpp_lib_integral_constant_callable: u32 = 201304;
pub const __cpp_lib_is_final: u32 = 201402;
pub const __cpp_lib_is_null_pointer: u32 = 201309;
pub const __cpp_lib_make_reverse_iterator: u32 = 201402;
pub const __cpp_lib_make_unique: u32 = 201304;
pub const __cpp_lib_null_iterators: u32 = 201304;
pub const __cpp_lib_quoted_string_io: u32 = 201304;
pub const __cpp_lib_result_of_sfinae: u32 = 201210;
pub const __cpp_lib_robust_nonmodifying_seq_ops: u32 = 201304;
pub const __cpp_lib_shared_timed_mutex: u32 = 201402;
pub const __cpp_lib_string_udls: u32 = 201304;
pub const __cpp_lib_transformation_trait_aliases: u32 = 201304;
pub const __cpp_lib_tuple_element_t: u32 = 201402;
pub const __cpp_lib_tuples_by_type: u32 = 201304;
pub const __cpp_lib_addressof_constexpr: u32 = 201603;
pub const __cpp_lib_allocator_traits_is_always_equal: u32 = 201411;
pub const __cpp_lib_as_const: u32 = 201510;
pub const __cpp_lib_bool_constant: u32 = 201505;
pub const __cpp_lib_enable_shared_from_this: u32 = 201603;
pub const __cpp_lib_incomplete_container_elements: u32 = 201505;
pub const __cpp_lib_invoke: u32 = 201411;
pub const __cpp_lib_logical_traits: u32 = 201510;
pub const __cpp_lib_map_try_emplace: u32 = 201411;
pub const __cpp_lib_nonmember_container_access: u32 = 201411;
pub const __cpp_lib_shared_mutex: u32 = 201505;
pub const __cpp_lib_transparent_operators: u32 = 201510;
pub const __cpp_lib_type_trait_variable_templates: u32 = 201510;
pub const __cpp_lib_uncaught_exceptions: u32 = 201411;
pub const __cpp_lib_unordered_map_try_emplace: u32 = 201411;
pub const __cpp_lib_void_t: u32 = 201411;
pub const __cpp_lib_atomic_value_initialization: u32 = 201911;
pub const __cpp_lib_chrono: u32 = 201510;
pub const __cpp_lib_shared_ptr_arrays: u32 = 201611;
pub const __cpp_lib_experimental_erase_if: u32 = 201411;
pub const __cpp_lib_experimental_filesystem: u32 = 201406;
pub const _STL_WIN32_WINNT_VISTA: u32 = 1536;
pub const _STL_WIN32_WINNT_WIN7: u32 = 1537;
pub const _STL_WIN32_WINNT_WIN8: u32 = 1538;
pub const _STL_WIN32_WINNT_WINBLUE: u32 = 1539;
pub const _STL_WIN32_WINNT_WIN10: u32 = 2560;
pub const _STL_WIN32_WINNT: u32 = 1537;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const EOS_TRUE: u32 = 1;
pub const EOS_FALSE: u32 = 0;
pub const EOS_EPICACCOUNTID_MAX_LENGTH: u32 = 32;
pub const EOS_PRODUCTUSERID_MAX_LENGTH: u32 = 32;
pub const EOS_PAGEQUERY_API_LATEST: u32 = 1;
pub const EOS_PAGINATION_API_LATEST: u32 = 1;
pub const EOS_PAGEQUERY_MAXCOUNT_DEFAULT: u32 = 10;
pub const EOS_PAGEQUERY_MAXCOUNT_MAXIMUM: u32 = 100;
pub const EOS_OPT_Unknown: u32 = 0;
pub const EOS_OPT_Epic: u32 = 100;
pub const EOS_OPT_Steam: u32 = 4000;
pub const EOS_IPT_Steam: &[u8; 6] = b"STEAM\0";
pub const EOS_INTEGRATEDPLATFORM_OPTIONS_API_LATEST: u32 = 1;
pub const EOS_INTEGRATEDPLATFORM_STEAM_OPTIONS_API_LATEST: u32 = 2;
pub const EOS_INTEGRATEDPLATFORM_CREATEINTEGRATEDPLATFORMOPTIONSCONTAINER_API_LATEST: u32 = 1;
pub const EOS_INTEGRATEDPLATFORMOPTIONSCONTAINER_ADD_API_LATEST: u32 = 1;
pub const EOS_INTEGRATEDPLATFORM_SETUSERLOGINSTATUS_API_LATEST: u32 = 1;
pub const EOS_INTEGRATEDPLATFORM_ADDNOTIFYUSERLOGINSTATUSCHANGED_API_LATEST: u32 = 1;
pub const EOS_INTEGRATEDPLATFORM_SETUSERPRELOGOUTCALLBACK_API_LATEST: u32 = 1;
pub const EOS_INTEGRATEDPLATFORM_CLEARUSERPRELOGOUTCALLBACK_API_LATEST: u32 = 1;
pub const EOS_INTEGRATEDPLATFORM_FINALIZEDEFERREDUSERLOGOUT_API_LATEST: u32 = 1;
pub const EOS_PLATFORM_CLIENTCREDENTIALS_CLIENTID_MAX_LENGTH: u32 = 64;
pub const EOS_PLATFORM_CLIENTCREDENTIALS_CLIENTSECRET_MAX_LENGTH: u32 = 64;
pub const EOS_PLATFORM_RTCOPTIONS_API_LATEST: u32 = 2;
pub const EOS_COUNTRYCODE_MAX_LENGTH: u32 = 4;
pub const EOS_COUNTRYCODE_MAX_BUFFER_LEN: u32 = 5;
pub const EOS_LOCALECODE_MAX_LENGTH: u32 = 9;
pub const EOS_LOCALECODE_MAX_BUFFER_LEN: u32 = 10;
pub const EOS_PLATFORM_OPTIONS_API_LATEST: u32 = 13;
pub const EOS_PF_LOADING_IN_EDITOR: u32 = 1;
pub const EOS_PF_DISABLE_OVERLAY: u32 = 2;
pub const EOS_PF_DISABLE_SOCIAL_OVERLAY: u32 = 4;
pub const EOS_PF_RESERVED1: u32 = 8;
pub const EOS_PF_WINDOWS_ENABLE_OVERLAY_D3D9: u32 = 16;
pub const EOS_PF_WINDOWS_ENABLE_OVERLAY_D3D10: u32 = 32;
pub const EOS_PF_WINDOWS_ENABLE_OVERLAY_OPENGL: u32 = 64;
pub const EOS_PF_CONSOLE_ENABLE_OVERLAY_AUTOMATIC_UNLOADING: u32 = 128;
pub const EOS_PLATFORM_OPTIONS_PRODUCTID_MAX_LENGTH: u32 = 64;
pub const EOS_PLATFORM_OPTIONS_SANDBOXID_MAX_LENGTH: u32 = 64;
pub const EOS_PLATFORM_OPTIONS_ENCRYPTIONKEY_LENGTH: u32 = 64;
pub const EOS_PLATFORM_OPTIONS_DEPLOYMENTID_MAX_LENGTH: u32 = 64;
pub const EOS_PLATFORM_GETDESKTOPCROSSPLAYSTATUS_API_LATEST: u32 = 1;
pub const EOS_PLATFORM_CHECKFORLAUNCHERANDRESTART_ENV_VAR: &[u8; 21] = b"EOS_LAUNCHED_BY_EPIC\0";
pub const EOS_INITIALIZE_THREADAFFINITY_API_LATEST: u32 = 2;
pub const EOS_INITIALIZE_API_LATEST: u32 = 4;
pub const EOS_INITIALIZEOPTIONS_PRODUCTNAME_MAX_LENGTH: u32 = 64;
pub const EOS_INITIALIZEOPTIONS_PRODUCTVERSION_MAX_LENGTH: u32 = 64;
pub const EOS_METRICS_BEGINPLAYERSESSION_API_LATEST: u32 = 1;
pub const EOS_METRICS_ENDPLAYERSESSION_API_LATEST: u32 = 1;
pub const EOS_AUTH_ACCOUNTFEATURERESTRICTEDINFO_API_LATEST: u32 = 1;
pub const EOS_AUTH_TOKEN_API_LATEST: u32 = 2;
pub const EOS_AUTH_CREDENTIALS_API_LATEST: u32 = 4;
pub const EOS_AUTH_PINGRANTINFO_API_LATEST: u32 = 2;
pub const EOS_LF_NO_USER_INTERFACE: u32 = 1;
pub const EOS_AUTH_LOGIN_API_LATEST: u32 = 3;
pub const EOS_AUTH_LOGOUT_API_LATEST: u32 = 1;
pub const EOS_AUTH_LINKACCOUNT_API_LATEST: u32 = 1;
pub const EOS_AUTH_VERIFYUSERAUTH_API_LATEST: u32 = 1;
pub const EOS_AUTH_COPYUSERAUTHTOKEN_API_LATEST: u32 = 1;
pub const EOS_AUTH_COPYIDTOKEN_API_LATEST: u32 = 1;
pub const EOS_AUTH_IDTOKEN_API_LATEST: u32 = 1;
pub const EOS_AUTH_QUERYIDTOKEN_API_LATEST: u32 = 1;
pub const EOS_AUTH_VERIFYIDTOKEN_API_LATEST: u32 = 1;
pub const EOS_AUTH_ADDNOTIFYLOGINSTATUSCHANGED_API_LATEST: u32 = 1;
pub const EOS_AUTH_DELETEPERSISTENTAUTH_API_LATEST: u32 = 2;
pub const EOS_ECOM_ENTITLEMENT_API_LATEST: u32 = 2;
pub const EOS_ECOM_ENTITLEMENT_ENDTIMESTAMP_UNDEFINED: i32 = -1;
pub const EOS_ECOM_ITEMOWNERSHIP_API_LATEST: u32 = 1;
pub const EOS_ECOM_CATALOGITEM_API_LATEST: u32 = 1;
pub const EOS_ECOM_CATALOGITEM_ENTITLEMENTENDTIMESTAMP_UNDEFINED: i32 = -1;
pub const EOS_ECOM_CATALOGOFFER_API_LATEST: u32 = 5;
pub const EOS_ECOM_CATALOGOFFER_EXPIRATIONTIMESTAMP_UNDEFINED: i32 = -1;
pub const EOS_ECOM_CATALOGOFFER_RELEASEDATETIMESTAMP_UNDEFINED: i32 = -1;
pub const EOS_ECOM_CATALOGOFFER_EFFECTIVEDATETIMESTAMP_UNDEFINED: i32 = -1;
pub const EOS_ECOM_KEYIMAGEINFO_API_LATEST: u32 = 1;
pub const EOS_ECOM_CATALOGRELEASE_API_LATEST: u32 = 1;
pub const EOS_ECOM_CHECKOUTENTRY_API_LATEST: u32 = 1;
pub const EOS_ECOM_QUERYOWNERSHIP_API_LATEST: u32 = 2;
pub const EOS_ECOM_QUERYOWNERSHIP_MAX_CATALOG_IDS: u32 = 400;
pub const EOS_ECOM_QUERYOWNERSHIPBYSANDBOXIDSOPTIONS_API_LATEST: u32 = 1;
pub const EOS_ECOM_QUERYOWNERSHIP_MAX_SANDBOX_IDS: u32 = 10;
pub const EOS_ECOM_QUERYOWNERSHIPTOKEN_API_LATEST: u32 = 2;
pub const EOS_ECOM_QUERYOWNERSHIPTOKEN_MAX_CATALOGITEM_IDS: u32 = 32;
pub const EOS_ECOM_QUERYENTITLEMENTS_API_LATEST: u32 = 2;
pub const EOS_ECOM_QUERYENTITLEMENTS_MAX_ENTITLEMENT_IDS: u32 = 256;
pub const EOS_ECOM_QUERYENTITLEMENTTOKEN_API_LATEST: u32 = 1;
pub const EOS_ECOM_QUERYENTITLEMENTTOKEN_MAX_ENTITLEMENT_IDS: u32 = 32;
pub const EOS_ECOM_QUERYOFFERS_API_LATEST: u32 = 1;
pub const EOS_ECOM_CHECKOUT_API_LATEST: u32 = 1;
pub const EOS_ECOM_CHECKOUT_MAX_ENTRIES: u32 = 10;
pub const EOS_ECOM_TRANSACTIONID_MAXIMUM_LENGTH: u32 = 64;
pub const EOS_ECOM_REDEEMENTITLEMENTS_API_LATEST: u32 = 2;
pub const EOS_ECOM_REDEEMENTITLEMENTS_MAX_IDS: u32 = 32;
pub const EOS_ECOM_ENTITLEMENTID_MAX_LENGTH: u32 = 32;
pub const EOS_ECOM_GETLASTREDEEMEDENTITLEMENTSCOUNT_API_LATEST: u32 = 1;
pub const EOS_ECOM_COPYLASTREDEEMEDENTITLEMENTBYINDEX_API_LATEST: u32 = 1;
pub const EOS_ECOM_GETENTITLEMENTSCOUNT_API_LATEST: u32 = 1;
pub const EOS_ECOM_GETENTITLEMENTSBYNAMECOUNT_API_LATEST: u32 = 1;
pub const EOS_ECOM_COPYENTITLEMENTBYINDEX_API_LATEST: u32 = 1;
pub const EOS_ECOM_COPYENTITLEMENTBYNAMEANDINDEX_API_LATEST: u32 = 1;
pub const EOS_ECOM_COPYENTITLEMENTBYID_API_LATEST: u32 = 2;
pub const EOS_ECOM_GETOFFERCOUNT_API_LATEST: u32 = 1;
pub const EOS_ECOM_COPYOFFERBYINDEX_API_LATEST: u32 = 3;
pub const EOS_ECOM_COPYOFFERBYID_API_LATEST: u32 = 3;
pub const EOS_ECOM_GETOFFERITEMCOUNT_API_LATEST: u32 = 1;
pub const EOS_ECOM_COPYOFFERITEMBYINDEX_API_LATEST: u32 = 1;
pub const EOS_ECOM_COPYITEMBYID_API_LATEST: u32 = 1;
pub const EOS_ECOM_GETOFFERIMAGEINFOCOUNT_API_LATEST: u32 = 1;
pub const EOS_ECOM_COPYOFFERIMAGEINFOBYINDEX_API_LATEST: u32 = 1;
pub const EOS_ECOM_GETITEMIMAGEINFOCOUNT_API_LATEST: u32 = 1;
pub const EOS_ECOM_COPYITEMIMAGEINFOBYINDEX_API_LATEST: u32 = 1;
pub const EOS_ECOM_GETITEMRELEASECOUNT_API_LATEST: u32 = 1;
pub const EOS_ECOM_COPYITEMRELEASEBYINDEX_API_LATEST: u32 = 1;
pub const EOS_ECOM_GETTRANSACTIONCOUNT_API_LATEST: u32 = 1;
pub const EOS_ECOM_COPYTRANSACTIONBYINDEX_API_LATEST: u32 = 1;
pub const EOS_ECOM_COPYTRANSACTIONBYID_API_LATEST: u32 = 1;
pub const EOS_ECOM_TRANSACTION_GETENTITLEMENTSCOUNT_API_LATEST: u32 = 1;
pub const EOS_ECOM_TRANSACTION_COPYENTITLEMENTBYINDEX_API_LATEST: u32 = 1;
pub const EOS_UI_EVENTID_INVALID: u32 = 0;
pub const EOS_UI_SHOWFRIENDS_API_LATEST: u32 = 1;
pub const EOS_UI_HIDEFRIENDS_API_LATEST: u32 = 1;
pub const EOS_UI_GETFRIENDSVISIBLE_API_LATEST: u32 = 1;
pub const EOS_UI_GETFRIENDSEXCLUSIVEINPUT_API_LATEST: u32 = 1;
pub const EOS_UI_ADDNOTIFYDISPLAYSETTINGSUPDATED_API_LATEST: u32 = 1;
pub const EOS_UI_SETTOGGLEFRIENDSKEY_API_LATEST: u32 = 1;
pub const EOS_UI_GETTOGGLEFRIENDSKEY_API_LATEST: u32 = 1;
pub const EOS_UI_SETTOGGLEFRIENDSBUTTON_API_LATEST: u32 = 1;
pub const EOS_UI_GETTOGGLEFRIENDSBUTTON_API_LATEST: u32 = 1;
pub const EOS_UI_SETDISPLAYPREFERENCE_API_LATEST: u32 = 1;
pub const EOS_UI_ACKNOWLEDGEEVENTID_API_LATEST: u32 = 1;
pub const EOS_UI_ACKNOWLEDGECORRELATIONID_API_LATEST: u32 = 1;
pub const EOS_UI_REPORTINPUTSTATE_API_LATEST: u32 = 2;
pub const EOS_UI_PREPRESENT_API_LATEST: u32 = 1;
pub const EOS_UI_SHOWBLOCKPLAYER_API_LATEST: u32 = 1;
pub const EOS_UI_SHOWREPORTPLAYER_API_LATEST: u32 = 1;
pub const EOS_UI_SHOWNATIVEPROFILE_API_LATEST: u32 = 1;
pub const EOS_UI_PAUSESOCIALOVERLAY_API_LATEST: u32 = 1;
pub const EOS_UI_ISSOCIALOVERLAYPAUSED_API_LATEST: u32 = 1;
pub const EOS_UI_RECT_API_LATEST: u32 = 1;
pub const EOS_UI_MEMORYMONITORCALLBACKINFO_API_LATEST: u32 = 1;
pub const EOS_UI_ADDNOTIFYMEMORYMONITOR_API_LATEST: u32 = 1;
pub const EOS_UI_ADDNOTIFYMEMORYMONITOROPTIONS_API_LATEST: u32 = 1;
pub const EOS_FRIENDS_QUERYFRIENDS_API_LATEST: u32 = 1;
pub const EOS_FRIENDS_SENDINVITE_API_LATEST: u32 = 1;
pub const EOS_FRIENDS_ACCEPTINVITE_API_LATEST: u32 = 1;
pub const EOS_FRIENDS_REJECTINVITE_API_LATEST: u32 = 1;
pub const EOS_FRIENDS_GETFRIENDSCOUNT_API_LATEST: u32 = 1;
pub const EOS_FRIENDS_GETFRIENDATINDEX_API_LATEST: u32 = 1;
pub const EOS_FRIENDS_GETSTATUS_API_LATEST: u32 = 1;
pub const EOS_FRIENDS_ADDNOTIFYFRIENDSUPDATE_API_LATEST: u32 = 1;
pub const EOS_FRIENDS_GETBLOCKEDUSERSCOUNT_API_LATEST: u32 = 1;
pub const EOS_FRIENDS_GETBLOCKEDUSERATINDEX_API_LATEST: u32 = 1;
pub const EOS_FRIENDS_ADDNOTIFYBLOCKEDUSERSUPDATE_API_LATEST: u32 = 1;
pub const EOS_PRESENCE_DATARECORD_API_LATEST: u32 = 1;
pub const EOS_PRESENCE_INFO_API_LATEST: u32 = 3;
pub const EOS_PRESENCE_QUERYPRESENCE_API_LATEST: u32 = 1;
pub const EOS_PRESENCE_HASPRESENCE_API_LATEST: u32 = 1;
pub const EOS_PRESENCE_COPYPRESENCE_API_LATEST: u32 = 3;
pub const EOS_PRESENCE_CREATEPRESENCEMODIFICATION_API_LATEST: u32 = 1;
pub const EOS_PRESENCE_SETPRESENCE_API_LATEST: u32 = 1;
pub const EOS_PRESENCE_ADDNOTIFYONPRESENCECHANGED_API_LATEST: u32 = 1;
pub const EOS_PRESENCE_ADDNOTIFYJOINGAMEACCEPTED_API_LATEST: u32 = 2;
pub const EOS_PRESENCE_GETJOININFO_API_LATEST: u32 = 1;
pub const EOS_PRESENCEMODIFICATION_SETJOININFO_API_LATEST: u32 = 1;
pub const EOS_PRESENCE_DATA_MAX_KEYS: u32 = 32;
pub const EOS_PRESENCE_DATA_MAX_KEY_LENGTH: u32 = 64;
pub const EOS_PRESENCE_DATA_MAX_VALUE_LENGTH: u32 = 255;
pub const EOS_PRESENCE_RICH_TEXT_MAX_VALUE_LENGTH: u32 = 255;
pub const EOS_PRESENCE_KEY_PLATFORM_PRESENCE: &[u8; 21] = b"EOS_PlatformPresence\0";
pub const EOS_PRESENCEMODIFICATION_SETSTATUS_API_LATEST: u32 = 1;
pub const EOS_PRESENCE_SETSTATUS_API_LATEST: u32 = 1;
pub const EOS_PRESENCEMODIFICATION_SETRAWRICHTEXT_API_LATEST: u32 = 1;
pub const EOS_PRESENCE_SETRAWRICHTEXT_API_LATEST: u32 = 1;
pub const EOS_PRESENCEMODIFICATION_SETDATA_API_LATEST: u32 = 1;
pub const EOS_PRESENCE_SETDATA_API_LATEST: u32 = 1;
pub const EOS_PRESENCEMODIFICATION_DATARECORDID_API_LATEST: u32 = 1;
pub const EOS_PRESENCEMODIFICATION_DELETEDATA_API_LATEST: u32 = 1;
pub const EOS_PRESENCE_DELETEDATA_API_LATEST: u32 = 1;
pub const EOS_P2P_MAX_PACKET_SIZE: u32 = 1170;
pub const EOS_P2P_MAX_CONNECTIONS: u32 = 32;
pub const EOS_P2P_SOCKETID_API_LATEST: u32 = 1;
pub const EOS_P2P_SOCKETID_SOCKETNAME_SIZE: u32 = 33;
pub const EOS_P2P_SENDPACKET_API_LATEST: u32 = 3;
pub const EOS_P2P_GETNEXTRECEIVEDPACKETSIZE_API_LATEST: u32 = 2;
pub const EOS_P2P_RECEIVEPACKET_API_LATEST: u32 = 2;
pub const EOS_P2P_ADDNOTIFYPEERCONNECTIONREQUEST_API_LATEST: u32 = 1;
pub const EOS_P2P_ADDNOTIFYPEERCONNECTIONESTABLISHED_API_LATEST: u32 = 1;
pub const EOS_P2P_ADDNOTIFYPEERCONNECTIONINTERRUPTED_API_LATEST: u32 = 1;
pub const EOS_P2P_ADDNOTIFYPEERCONNECTIONCLOSED_API_LATEST: u32 = 1;
pub const EOS_P2P_ACCEPTCONNECTION_API_LATEST: u32 = 1;
pub const EOS_P2P_CLOSECONNECTION_API_LATEST: u32 = 1;
pub const EOS_P2P_CLOSECONNECTIONS_API_LATEST: u32 = 1;
pub const EOS_P2P_QUERYNATTYPE_API_LATEST: u32 = 1;
pub const EOS_P2P_GETNATTYPE_API_LATEST: u32 = 1;
pub const EOS_P2P_SETRELAYCONTROL_API_LATEST: u32 = 1;
pub const EOS_P2P_GETRELAYCONTROL_API_LATEST: u32 = 1;
pub const EOS_P2P_SETPORTRANGE_API_LATEST: u32 = 1;
pub const EOS_P2P_GETPORTRANGE_API_LATEST: u32 = 1;
pub const EOS_P2P_MAX_QUEUE_SIZE_UNLIMITED: u32 = 0;
pub const EOS_P2P_SETPACKETQUEUESIZE_API_LATEST: u32 = 1;
pub const EOS_P2P_GETPACKETQUEUEINFO_API_LATEST: u32 = 1;
pub const EOS_P2P_ADDNOTIFYINCOMINGPACKETQUEUEFULL_API_LATEST: u32 = 1;
pub const EOS_P2P_CLEARPACKETQUEUE_API_LATEST: u32 = 1;
pub const EOS_SESSIONMODIFICATION_MAX_SESSION_ATTRIBUTES: u32 = 64;
pub const EOS_SESSIONMODIFICATION_MAX_SESSION_ATTRIBUTE_LENGTH: u32 = 64;
pub const EOS_SESSIONMODIFICATION_MIN_SESSIONIDOVERRIDE_LENGTH: u32 = 16;
pub const EOS_SESSIONMODIFICATION_MAX_SESSIONIDOVERRIDE_LENGTH: u32 = 64;
pub const EOS_SESSIONS_CREATESESSIONMODIFICATION_API_LATEST: u32 = 5;
pub const EOS_SESSIONS_UPDATESESSIONMODIFICATION_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_INVITEID_MAX_LENGTH: u32 = 64;
pub const EOS_SESSIONS_SENDINVITE_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_REJECTINVITE_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_QUERYINVITES_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_GETINVITECOUNT_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_GETINVITEIDBYINDEX_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_CREATESESSIONSEARCH_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_UPDATESESSION_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_DESTROYSESSION_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_JOINSESSION_API_LATEST: u32 = 2;
pub const EOS_SESSIONS_STARTSESSION_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_ENDSESSION_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_REGISTERPLAYERS_API_LATEST: u32 = 3;
pub const EOS_SESSIONS_UNREGISTERPLAYERS_API_LATEST: u32 = 2;
pub const EOS_SESSIONMODIFICATION_SETBUCKETID_API_LATEST: u32 = 1;
pub const EOS_SESSIONMODIFICATION_SETHOSTADDRESS_API_LATEST: u32 = 1;
pub const EOS_SESSIONMODIFICATION_SETPERMISSIONLEVEL_API_LATEST: u32 = 1;
pub const EOS_SESSIONMODIFICATION_SETJOININPROGRESSALLOWED_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_MAXREGISTEREDPLAYERS: u32 = 1000;
pub const EOS_SESSIONMODIFICATION_SETMAXPLAYERS_API_LATEST: u32 = 1;
pub const EOS_SESSIONMODIFICATION_SETINVITESALLOWED_API_LATEST: u32 = 1;
pub const EOS_SESSIONMODIFICATION_SETALLOWEDPLATFORMIDS_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_SEARCH_BUCKET_ID: &[u8; 7] = b"bucket\0";
pub const EOS_SESSIONS_SEARCH_EMPTY_SERVERS_ONLY: &[u8; 10] = b"emptyonly\0";
pub const EOS_SESSIONS_SEARCH_NONEMPTY_SERVERS_ONLY: &[u8; 13] = b"nonemptyonly\0";
pub const EOS_SESSIONS_SEARCH_MINSLOTSAVAILABLE: &[u8; 18] = b"minslotsavailable\0";
pub const EOS_SESSIONS_ATTRIBUTEDATA_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_SESSIONATTRIBUTEDATA_API_LATEST: u32 = 1;
pub const EOS_ACTIVESESSION_COPYINFO_API_LATEST: u32 = 1;
pub const EOS_ACTIVESESSION_GETREGISTEREDPLAYERCOUNT_API_LATEST: u32 = 1;
pub const EOS_ACTIVESESSION_GETREGISTEREDPLAYERBYINDEX_API_LATEST: u32 = 1;
pub const EOS_SESSIONDETAILS_ATTRIBUTE_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_SESSIONATTRIBUTE_API_LATEST: u32 = 1;
pub const EOS_SESSIONMODIFICATION_ADDATTRIBUTE_API_LATEST: u32 = 2;
pub const EOS_SESSIONMODIFICATION_REMOVEATTRIBUTE_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_MAX_SEARCH_RESULTS: u32 = 200;
pub const EOS_SESSIONSEARCH_SETMAXSEARCHRESULTS_API_LATEST: u32 = 1;
pub const EOS_SESSIONSEARCH_FIND_API_LATEST: u32 = 2;
pub const EOS_SESSIONSEARCH_GETSEARCHRESULTCOUNT_API_LATEST: u32 = 1;
pub const EOS_SESSIONSEARCH_COPYSEARCHRESULTBYINDEX_API_LATEST: u32 = 1;
pub const EOS_SESSIONSEARCH_SETSESSIONID_API_LATEST: u32 = 1;
pub const EOS_SESSIONSEARCH_SETTARGETUSERID_API_LATEST: u32 = 1;
pub const EOS_SESSIONSEARCH_SETPARAMETER_API_LATEST: u32 = 1;
pub const EOS_SESSIONSEARCH_REMOVEPARAMETER_API_LATEST: u32 = 1;
pub const EOS_SESSIONDETAILS_SETTINGS_API_LATEST: u32 = 4;
pub const EOS_SESSIONDETAILS_INFO_API_LATEST: u32 = 2;
pub const EOS_SESSIONDETAILS_COPYINFO_API_LATEST: u32 = 1;
pub const EOS_SESSIONDETAILS_GETSESSIONATTRIBUTECOUNT_API_LATEST: u32 = 1;
pub const EOS_SESSIONDETAILS_COPYSESSIONATTRIBUTEBYINDEX_API_LATEST: u32 = 1;
pub const EOS_SESSIONDETAILS_COPYSESSIONATTRIBUTEBYKEY_API_LATEST: u32 = 1;
pub const EOS_ACTIVESESSION_INFO_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_COPYACTIVESESSIONHANDLE_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_ADDNOTIFYSESSIONINVITERECEIVED_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_ADDNOTIFYSESSIONINVITEACCEPTED_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_ADDNOTIFYSESSIONINVITEREJECTED_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_ADDNOTIFYJOINSESSIONACCEPTED_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_COPYSESSIONHANDLEBYINVITEID_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_COPYSESSIONHANDLEBYUIEVENTID_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_COPYSESSIONHANDLEFORPRESENCE_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_ISUSERINSESSION_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_DUMPSESSIONSTATE_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_ADDNOTIFYLEAVESESSIONREQUESTED_API_LATEST: u32 = 1;
pub const EOS_SESSIONS_ADDNOTIFYSENDSESSIONNATIVEINVITEREQUESTED_API_LATEST: u32 = 1;
pub const EOS_LOBBY_MAX_LOBBIES: u32 = 16;
pub const EOS_LOBBY_MAX_LOBBY_MEMBERS: u32 = 64;
pub const EOS_LOBBY_MAX_SEARCH_RESULTS: u32 = 200;
pub const EOS_LOBBY_MIN_LOBBYIDOVERRIDE_LENGTH: u32 = 4;
pub const EOS_LOBBY_MAX_LOBBYIDOVERRIDE_LENGTH: u32 = 60;
pub const EOS_LOBBYMODIFICATION_MAX_ATTRIBUTES: u32 = 64;
pub const EOS_LOBBYMODIFICATION_MAX_ATTRIBUTE_LENGTH: u32 = 64;
pub const EOS_LOBBYDETAILS_INFO_API_LATEST: u32 = 3;
pub const EOS_LOBBY_LOCALRTCOPTIONS_API_LATEST: u32 = 1;
pub const EOS_LOBBY_CREATELOBBY_API_LATEST: u32 = 9;
pub const EOS_LOBBY_DESTROYLOBBY_API_LATEST: u32 = 1;
pub const EOS_LOBBY_JOINLOBBY_API_LATEST: u32 = 4;
pub const EOS_LOBBY_JOINLOBBYBYID_API_LATEST: u32 = 2;
pub const EOS_LOBBY_LEAVELOBBY_API_LATEST: u32 = 1;
pub const EOS_LOBBY_UPDATELOBBYMODIFICATION_API_LATEST: u32 = 1;
pub const EOS_LOBBY_UPDATELOBBY_API_LATEST: u32 = 1;
pub const EOS_LOBBY_PROMOTEMEMBER_API_LATEST: u32 = 1;
pub const EOS_LOBBY_KICKMEMBER_API_LATEST: u32 = 1;
pub const EOS_LOBBY_HARDMUTEMEMBER_API_LATEST: u32 = 1;
pub const EOS_LOBBY_ADDNOTIFYLOBBYUPDATERECEIVED_API_LATEST: u32 = 1;
pub const EOS_LOBBY_ADDNOTIFYLOBBYMEMBERUPDATERECEIVED_API_LATEST: u32 = 1;
pub const EOS_LOBBY_ADDNOTIFYLOBBYMEMBERSTATUSRECEIVED_API_LATEST: u32 = 1;
pub const EOS_LOBBY_INVITEID_MAX_LENGTH: u32 = 64;
pub const EOS_LOBBY_ADDNOTIFYLOBBYINVITERECEIVED_API_LATEST: u32 = 1;
pub const EOS_LOBBY_ADDNOTIFYLOBBYINVITEACCEPTED_API_LATEST: u32 = 1;
pub const EOS_LOBBY_ADDNOTIFYJOINLOBBYACCEPTED_API_LATEST: u32 = 1;
pub const EOS_LOBBY_ADDNOTIFYLOBBYINVITEREJECTED_API_LATEST: u32 = 1;
pub const EOS_LOBBY_ADDNOTIFYSENDLOBBYNATIVEINVITEREQUESTED_API_LATEST: u32 = 1;
pub const EOS_LOBBY_COPYLOBBYDETAILSHANDLEBYINVITEID_API_LATEST: u32 = 1;
pub const EOS_LOBBY_COPYLOBBYDETAILSHANDLEBYUIEVENTID_API_LATEST: u32 = 1;
pub const EOS_LOBBY_CREATELOBBYSEARCH_API_LATEST: u32 = 1;
pub const EOS_LOBBY_SENDINVITE_API_LATEST: u32 = 1;
pub const EOS_LOBBY_REJECTINVITE_API_LATEST: u32 = 1;
pub const EOS_LOBBY_QUERYINVITES_API_LATEST: u32 = 1;
pub const EOS_LOBBY_GETINVITECOUNT_API_LATEST: u32 = 1;
pub const EOS_LOBBY_GETINVITEIDBYINDEX_API_LATEST: u32 = 1;
pub const EOS_LOBBY_COPYLOBBYDETAILSHANDLE_API_LATEST: u32 = 1;
pub const EOS_LOBBY_GETRTCROOMNAME_API_LATEST: u32 = 1;
pub const EOS_LOBBY_ISRTCROOMCONNECTED_API_LATEST: u32 = 1;
pub const EOS_LOBBY_ADDNOTIFYRTCROOMCONNECTIONCHANGED_API_LATEST: u32 = 2;
pub const EOS_LOBBY_SEARCH_BUCKET_ID: &[u8; 7] = b"bucket\0";
pub const EOS_LOBBY_SEARCH_MINCURRENTMEMBERS: &[u8; 18] = b"mincurrentmembers\0";
pub const EOS_LOBBY_SEARCH_MINSLOTSAVAILABLE: &[u8; 18] = b"minslotsavailable\0";
pub const EOS_LOBBY_ATTRIBUTEDATA_API_LATEST: u32 = 1;
pub const EOS_LOBBY_ATTRIBUTE_API_LATEST: u32 = 1;
pub const EOS_LOBBY_GETCONNECTSTRING_API_LATEST: u32 = 1;
pub const EOS_LOBBY_GETCONNECTSTRING_BUFFER_SIZE: u32 = 256;
pub const EOS_LOBBY_PARSECONNECTSTRING_API_LATEST: u32 = 1;
pub const EOS_LOBBY_PARSECONNECTSTRING_BUFFER_SIZE: u32 = 256;
pub const EOS_LOBBYMODIFICATION_SETBUCKETID_API_LATEST: u32 = 1;
pub const EOS_LOBBYMODIFICATION_SETPERMISSIONLEVEL_API_LATEST: u32 = 1;
pub const EOS_LOBBYMODIFICATION_SETMAXMEMBERS_API_LATEST: u32 = 1;
pub const EOS_LOBBYMODIFICATION_SETINVITESALLOWED_API_LATEST: u32 = 1;
pub const EOS_LOBBYMODIFICATION_ADDATTRIBUTE_API_LATEST: u32 = 2;
pub const EOS_LOBBYMODIFICATION_REMOVEATTRIBUTE_API_LATEST: u32 = 1;
pub const EOS_LOBBYMODIFICATION_ADDMEMBERATTRIBUTE_API_LATEST: u32 = 2;
pub const EOS_LOBBYMODIFICATION_REMOVEMEMBERATTRIBUTE_API_LATEST: u32 = 1;
pub const EOS_LOBBYMODIFICATION_SETALLOWEDPLATFORMIDS_API_LATEST: u32 = 1;
pub const EOS_LOBBYDETAILS_GETLOBBYOWNER_API_LATEST: u32 = 1;
pub const EOS_LOBBYDETAILS_COPYINFO_API_LATEST: u32 = 1;
pub const EOS_LOBBYDETAILS_GETATTRIBUTECOUNT_API_LATEST: u32 = 1;
pub const EOS_LOBBYDETAILS_COPYATTRIBUTEBYINDEX_API_LATEST: u32 = 1;
pub const EOS_LOBBYDETAILS_COPYATTRIBUTEBYKEY_API_LATEST: u32 = 1;
pub const EOS_LOBBYDETAILS_GETMEMBERATTRIBUTECOUNT_API_LATEST: u32 = 1;
pub const EOS_LOBBYDETAILS_COPYMEMBERATTRIBUTEBYINDEX_API_LATEST: u32 = 1;
pub const EOS_LOBBYDETAILS_COPYMEMBERATTRIBUTEBYKEY_API_LATEST: u32 = 1;
pub const EOS_LOBBYDETAILS_GETMEMBERCOUNT_API_LATEST: u32 = 1;
pub const EOS_LOBBYDETAILS_GETMEMBERBYINDEX_API_LATEST: u32 = 1;
pub const EOS_LOBBYSEARCH_FIND_API_LATEST: u32 = 1;
pub const EOS_LOBBYSEARCH_SETLOBBYID_API_LATEST: u32 = 1;
pub const EOS_LOBBYSEARCH_SETTARGETUSERID_API_LATEST: u32 = 1;
pub const EOS_LOBBYSEARCH_SETPARAMETER_API_LATEST: u32 = 1;
pub const EOS_LOBBYSEARCH_REMOVEPARAMETER_API_LATEST: u32 = 1;
pub const EOS_LOBBYSEARCH_SETMAXRESULTS_API_LATEST: u32 = 1;
pub const EOS_LOBBYSEARCH_GETSEARCHRESULTCOUNT_API_LATEST: u32 = 1;
pub const EOS_LOBBYSEARCH_COPYSEARCHRESULTBYINDEX_API_LATEST: u32 = 1;
pub const EOS_LOBBYDETAILS_COPYMEMBERINFO_API_LATEST: u32 = 1;
pub const EOS_LOBBYDETAILS_MEMBERINFO_API_LATEST: u32 = 1;
pub const EOS_LOBBY_ADDNOTIFYLEAVELOBBYREQUESTED_API_LATEST: u32 = 1;
pub const EOS_USERINFO_QUERYUSERINFO_API_LATEST: u32 = 1;
pub const EOS_USERINFO_QUERYUSERINFOBYDISPLAYNAME_API_LATEST: u32 = 1;
pub const EOS_USERINFO_QUERYUSERINFOBYEXTERNALACCOUNT_API_LATEST: u32 = 1;
pub const EOS_USERINFO_MAX_DISPLAYNAME_CHARACTERS: u32 = 16;
pub const EOS_USERINFO_MAX_DISPLAYNAME_UTF8_LENGTH: u32 = 64;
pub const EOS_USERINFO_COPYUSERINFO_API_LATEST: u32 = 3;
pub const EOS_USERINFO_EXTERNALUSERINFO_API_LATEST: u32 = 2;
pub const EOS_USERINFO_GETEXTERNALUSERINFOCOUNT_API_LATEST: u32 = 1;
pub const EOS_USERINFO_COPYEXTERNALUSERINFOBYINDEX_API_LATEST: u32 = 1;
pub const EOS_USERINFO_COPYEXTERNALUSERINFOBYACCOUNTTYPE_API_LATEST: u32 = 1;
pub const EOS_USERINFO_COPYEXTERNALUSERINFOBYACCOUNTID_API_LATEST: u32 = 1;
pub const EOS_USERINFO_BESTDISPLAYNAME_API_LATEST: u32 = 1;
pub const EOS_USERINFO_COPYBESTDISPLAYNAME_API_LATEST: u32 = 1;
pub const EOS_USERINFO_COPYBESTDISPLAYNAMEWITHPLATFORM_API_LATEST: u32 = 1;
pub const EOS_USERINFO_GETLOCALPLATFORMTYPE_API_LATEST: u32 = 1;
pub const EOS_PLAYERDATASTORAGE_FILENAME_MAX_LENGTH_BYTES: u32 = 64;
pub const EOS_PLAYERDATASTORAGE_TIME_UNDEFINED: i32 = -1;
pub const EOS_PLAYERDATASTORAGE_FILEMETADATA_API_LATEST: u32 = 3;
pub const EOS_PLAYERDATASTORAGE_QUERYFILE_API_LATEST: u32 = 1;
pub const EOS_PLAYERDATASTORAGE_QUERYFILEOPTIONS_API_LATEST: u32 = 1;
pub const EOS_PLAYERDATASTORAGE_QUERYFILELIST_API_LATEST: u32 = 2;
pub const EOS_PLAYERDATASTORAGE_QUERYFILELISTOPTIONS_API_LATEST: u32 = 2;
pub const EOS_PLAYERDATASTORAGE_GETFILEMETADATACOUNT_API_LATEST: u32 = 1;
pub const EOS_PLAYERDATASTORAGE_GETFILEMETADATACOUNTOPTIONS_API_LATEST: u32 = 1;
pub const EOS_PLAYERDATASTORAGE_COPYFILEMETADATAATINDEX_API_LATEST: u32 = 1;
pub const EOS_PLAYERDATASTORAGE_COPYFILEMETADATAATINDEXOPTIONS_API_LATEST: u32 = 1;
pub const EOS_PLAYERDATASTORAGE_COPYFILEMETADATABYFILENAME_API_LATEST: u32 = 1;
pub const EOS_PLAYERDATASTORAGE_COPYFILEMETADATABYFILENAMEOPTIONS_API_LATEST: u32 = 1;
pub const EOS_PLAYERDATASTORAGE_DUPLICATEFILE_API_LATEST: u32 = 1;
pub const EOS_PLAYERDATASTORAGE_DUPLICATEFILEOPTIONS_API_LATEST: u32 = 1;
pub const EOS_PLAYERDATASTORAGE_DELETEFILE_API_LATEST: u32 = 1;
pub const EOS_PLAYERDATASTORAGE_DELETEFILEOPTIONS_API_LATEST: u32 = 1;
pub const EOS_PLAYERDATASTORAGE_READFILE_API_LATEST: u32 = 1;
pub const EOS_PLAYERDATASTORAGE_READFILEOPTIONS_API_LATEST: u32 = 1;
pub const EOS_PLAYERDATASTORAGE_WRITEFILE_API_LATEST: u32 = 1;
pub const EOS_PLAYERDATASTORAGE_WRITEFILEOPTIONS_API_LATEST: u32 = 1;
pub const EOS_PLAYERDATASTORAGE_DELETECACHE_API_LATEST: u32 = 1;
pub const EOS_PLAYERDATASTORAGE_DELETECACHEOPTIONS_API_LATEST: u32 = 1;
pub const EOS_TITLESTORAGE_FILENAME_MAX_LENGTH_BYTES: u32 = 64;
pub const EOS_TITLESTORAGE_FILEMETADATA_API_LATEST: u32 = 2;
pub const EOS_TITLESTORAGE_QUERYFILE_API_LATEST: u32 = 1;
pub const EOS_TITLESTORAGE_QUERYFILEOPTIONS_API_LATEST: u32 = 1;
pub const EOS_TITLESTORAGE_QUERYFILELIST_API_LATEST: u32 = 1;
pub const EOS_TITLESTORAGE_QUERYFILELISTOPTIONS_API_LATEST: u32 = 1;
pub const EOS_TITLESTORAGE_GETFILEMETADATACOUNT_API_LATEST: u32 = 1;
pub const EOS_TITLESTORAGE_GETFILEMETADATACOUNTOPTIONS_API_LATEST: u32 = 1;
pub const EOS_TITLESTORAGE_COPYFILEMETADATAATINDEX_API_LATEST: u32 = 1;
pub const EOS_TITLESTORAGE_COPYFILEMETADATAATINDEXOPTIONS_API_LATEST: u32 = 1;
pub const EOS_TITLESTORAGE_COPYFILEMETADATABYFILENAME_API_LATEST: u32 = 1;
pub const EOS_TITLESTORAGE_COPYFILEMETADATABYFILENAMEOPTIONS_API_LATEST: u32 = 1;
pub const EOS_TITLESTORAGE_READFILE_API_LATEST: u32 = 1;
pub const EOS_TITLESTORAGE_READFILEOPTIONS_API_LATEST: u32 = 1;
pub const EOS_TITLESTORAGE_DELETECACHE_API_LATEST: u32 = 1;
pub const EOS_TITLESTORAGE_DELETECACHEOPTIONS_API_LATEST: u32 = 1;
pub const EOS_CONNECT_EXTERNAL_ACCOUNT_ID_MAX_LENGTH: u32 = 256;
pub const EOS_CONNECT_CREDENTIALS_API_LATEST: u32 = 1;
pub const EOS_CONNECT_USERLOGININFO_DISPLAYNAME_MAX_LENGTH: u32 = 32;
pub const EOS_CONNECT_USERLOGININFO_API_LATEST: u32 = 2;
pub const EOS_CONNECT_LOGIN_API_LATEST: u32 = 2;
pub const EOS_CONNECT_CREATEUSER_API_LATEST: u32 = 1;
pub const EOS_CONNECT_LINKACCOUNT_API_LATEST: u32 = 1;
pub const EOS_CONNECT_UNLINKACCOUNT_API_LATEST: u32 = 1;
pub const EOS_CONNECT_CREATEDEVICEID_API_LATEST: u32 = 1;
pub const EOS_CONNECT_CREATEDEVICEID_DEVICEMODEL_MAX_LENGTH: u32 = 64;
pub const EOS_CONNECT_DELETEDEVICEID_API_LATEST: u32 = 1;
pub const EOS_CONNECT_TRANSFERDEVICEIDACCOUNT_API_LATEST: u32 = 1;
pub const EOS_CONNECT_QUERYEXTERNALACCOUNTMAPPINGS_API_LATEST: u32 = 1;
pub const EOS_CONNECT_QUERYEXTERNALACCOUNTMAPPINGS_MAX_ACCOUNT_IDS: u32 = 128;
pub const EOS_CONNECT_GETEXTERNALACCOUNTMAPPING_API_LATEST: u32 = 1;
pub const EOS_CONNECT_GETEXTERNALACCOUNTMAPPINGS_API_LATEST: u32 = 1;
pub const EOS_CONNECT_QUERYPRODUCTUSERIDMAPPINGS_API_LATEST: u32 = 2;
pub const EOS_CONNECT_GETPRODUCTUSERIDMAPPING_API_LATEST: u32 = 1;
pub const EOS_CONNECT_GETPRODUCTUSEREXTERNALACCOUNTCOUNT_API_LATEST: u32 = 1;
pub const EOS_CONNECT_COPYPRODUCTUSEREXTERNALACCOUNTBYINDEX_API_LATEST: u32 = 1;
pub const EOS_CONNECT_COPYPRODUCTUSEREXTERNALACCOUNTBYACCOUNTTYPE_API_LATEST: u32 = 1;
pub const EOS_CONNECT_COPYPRODUCTUSEREXTERNALACCOUNTBYACCOUNTID_API_LATEST: u32 = 1;
pub const EOS_CONNECT_COPYPRODUCTUSERINFO_API_LATEST: u32 = 1;
pub const EOS_CONNECT_TIME_UNDEFINED: i32 = -1;
pub const EOS_CONNECT_EXTERNALACCOUNTINFO_API_LATEST: u32 = 1;
pub const EOS_CONNECT_ADDNOTIFYAUTHEXPIRATION_API_LATEST: u32 = 1;
pub const EOS_CONNECT_ONAUTHEXPIRATIONCALLBACK_API_LATEST: u32 = 1;
pub const EOS_CONNECT_ADDNOTIFYLOGINSTATUSCHANGED_API_LATEST: u32 = 1;
pub const EOS_CONNECT_IDTOKEN_API_LATEST: u32 = 1;
pub const EOS_CONNECT_COPYIDTOKEN_API_LATEST: u32 = 1;
pub const EOS_CONNECT_VERIFYIDTOKEN_API_LATEST: u32 = 1;
pub const EOS_ACHIEVEMENTS_QUERYDEFINITIONS_API_LATEST: u32 = 3;
pub const EOS_ACHIEVEMENTS_STATTHRESHOLDS_API_LATEST: u32 = 1;
pub const EOS_ACHIEVEMENTS_STATTHRESHOLD_API_LATEST: u32 = 1;
pub const EOS_ACHIEVEMENTS_PLAYERSTATINFO_API_LATEST: u32 = 1;
pub const EOS_ACHIEVEMENTS_DEFINITIONV2_API_LATEST: u32 = 2;
pub const EOS_ACHIEVEMENTS_GETACHIEVEMENTDEFINITIONCOUNT_API_LATEST: u32 = 1;
pub const EOS_ACHIEVEMENTS_COPYACHIEVEMENTDEFINITIONV2BYINDEX_API_LATEST: u32 = 2;
pub const EOS_ACHIEVEMENTS_COPYDEFINITIONV2BYINDEX_API_LATEST: u32 = 2;
pub const EOS_ACHIEVEMENTS_COPYACHIEVEMENTDEFINITIONV2BYACHIEVEMENTID_API_LATEST: u32 = 2;
pub const EOS_ACHIEVEMENTS_COPYDEFINITIONV2BYACHIEVEMENTID_API_LATEST: u32 = 2;
pub const EOS_ACHIEVEMENTS_QUERYPLAYERACHIEVEMENTS_API_LATEST: u32 = 2;
pub const EOS_ACHIEVEMENTS_ACHIEVEMENT_UNLOCKTIME_UNDEFINED: i32 = -1;
pub const EOS_ACHIEVEMENTS_PLAYERACHIEVEMENT_API_LATEST: u32 = 2;
pub const EOS_ACHIEVEMENTS_GETPLAYERACHIEVEMENTCOUNT_API_LATEST: u32 = 1;
pub const EOS_ACHIEVEMENTS_COPYPLAYERACHIEVEMENTBYINDEX_API_LATEST: u32 = 2;
pub const EOS_ACHIEVEMENTS_COPYPLAYERACHIEVEMENTBYACHIEVEMENTID_API_LATEST: u32 = 2;
pub const EOS_ACHIEVEMENTS_UNLOCKACHIEVEMENTS_API_LATEST: u32 = 1;
pub const EOS_ACHIEVEMENTS_ADDNOTIFYACHIEVEMENTSUNLOCKEDV2_API_LATEST: u32 = 2;
pub const EOS_ACHIEVEMENTS_DEFINITION_API_LATEST: u32 = 1;
pub const EOS_ACHIEVEMENTS_COPYDEFINITIONBYINDEX_API_LATEST: u32 = 1;
pub const EOS_ACHIEVEMENTS_COPYDEFINITIONBYACHIEVEMENTID_API_LATEST: u32 = 1;
pub const EOS_ACHIEVEMENTS_UNLOCKEDACHIEVEMENT_API_LATEST: u32 = 1;
pub const EOS_ACHIEVEMENTS_GETUNLOCKEDACHIEVEMENTCOUNT_API_LATEST: u32 = 1;
pub const EOS_ACHIEVEMENTS_COPYUNLOCKEDACHIEVEMENTBYINDEX_API_LATEST: u32 = 1;
pub const EOS_ACHIEVEMENTS_COPYUNLOCKEDACHIEVEMENTBYACHIEVEMENTID_API_LATEST: u32 = 1;
pub const EOS_ACHIEVEMENTS_ADDNOTIFYACHIEVEMENTSUNLOCKED_API_LATEST: u32 = 1;
pub const EOS_STATS_INGESTDATA_API_LATEST: u32 = 1;
pub const EOS_STATS_MAX_INGEST_STATS: u32 = 3000;
pub const EOS_STATS_INGESTSTAT_API_LATEST: u32 = 3;
pub const EOS_STATS_MAX_QUERY_STATS: u32 = 1000;
pub const EOS_STATS_QUERYSTATS_API_LATEST: u32 = 3;
pub const EOS_STATS_TIME_UNDEFINED: i32 = -1;
pub const EOS_STATS_STAT_API_LATEST: u32 = 1;
pub const EOS_STATS_GETSTATSCOUNT_API_LATEST: u32 = 1;
pub const EOS_STATS_GETSTATCOUNT_API_LATEST: u32 = 1;
pub const EOS_STATS_COPYSTATBYINDEX_API_LATEST: u32 = 1;
pub const EOS_STATS_COPYSTATBYNAME_API_LATEST: u32 = 1;
pub const EOS_LEADERBOARDS_TIME_UNDEFINED: i32 = -1;
pub const EOS_LEADERBOARDS_QUERYLEADERBOARDDEFINITIONS_API_LATEST: u32 = 2;
pub const EOS_LEADERBOARDS_DEFINITION_API_LATEST: u32 = 1;
pub const EOS_LEADERBOARDS_GETLEADERBOARDDEFINITIONCOUNT_API_LATEST: u32 = 1;
pub const EOS_LEADERBOARDS_COPYLEADERBOARDDEFINITIONBYINDEX_API_LATEST: u32 = 1;
pub const EOS_LEADERBOARDS_COPYLEADERBOARDDEFINITIONBYLEADERBOARDID_API_LATEST: u32 = 1;
pub const EOS_LEADERBOARDS_USERSCORESQUERYSTATINFO_API_LATEST: u32 = 1;
pub const EOS_LEADERBOARDS_QUERYLEADERBOARDUSERSCORES_API_LATEST: u32 = 2;
pub const EOS_LEADERBOARDS_LEADERBOARDUSERSCORE_API_LATEST: u32 = 1;
pub const EOS_LEADERBOARDS_GETLEADERBOARDUSERSCORECOUNT_API_LATEST: u32 = 1;
pub const EOS_LEADERBOARDS_COPYLEADERBOARDUSERSCOREBYINDEX_API_LATEST: u32 = 1;
pub const EOS_LEADERBOARDS_COPYLEADERBOARDUSERSCOREBYUSERID_API_LATEST: u32 = 1;
pub const EOS_LEADERBOARDS_QUERYLEADERBOARDRANKS_API_LATEST: u32 = 2;
pub const EOS_LEADERBOARDS_LEADERBOARDRECORD_API_LATEST: u32 = 2;
pub const EOS_LEADERBOARDS_GETLEADERBOARDRECORDCOUNT_API_LATEST: u32 = 1;
pub const EOS_LEADERBOARDS_COPYLEADERBOARDRECORDBYINDEX_API_LATEST: u32 = 2;
pub const EOS_LEADERBOARDS_COPYLEADERBOARDRECORDBYUSERID_API_LATEST: u32 = 2;
pub const EOS_MOD_IDENTIFIER_API_LATEST: u32 = 1;
pub const EOS_MODS_INSTALLMOD_API_LATEST: u32 = 1;
pub const EOS_MODS_UNINSTALLMOD_API_LATEST: u32 = 1;
pub const EOS_MODS_ENUMERATEMODS_API_LATEST: u32 = 1;
pub const EOS_MODS_COPYMODINFO_API_LATEST: u32 = 1;
pub const EOS_MODS_MODINFO_API_LATEST: u32 = 1;
pub const EOS_MODS_UPDATEMOD_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATCOMMON_SETCLIENTDETAILS_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATCOMMON_SETGAMESESSIONID_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATCOMMON_REGISTEREVENT_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATCOMMON_REGISTEREVENT_CUSTOMEVENTBASE: u32 = 268435456;
pub const EOS_ANTICHEATCOMMON_REGISTEREVENT_MAX_PARAMDEFSCOUNT: u32 = 12;
pub const EOS_ANTICHEATCOMMON_LOGEVENT_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATCOMMON_LOGEVENT_STRING_MAX_LENGTH: u32 = 39;
pub const EOS_ANTICHEATCOMMON_LOGGAMEROUNDSTART_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATCOMMON_LOGGAMEROUNDEND_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATCOMMON_LOGPLAYERSPAWN_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATCOMMON_LOGPLAYERDESPAWN_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATCOMMON_LOGPLAYERREVIVE_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATCOMMON_LOGPLAYERTICK_API_LATEST: u32 = 2;
pub const EOS_ANTICHEATCOMMON_LOGPLAYERUSEWEAPON_API_LATEST: u32 = 2;
pub const EOS_ANTICHEATCOMMON_LOGPLAYERUSEWEAPON_WEAPONNAME_MAX_LENGTH: u32 = 16;
pub const EOS_ANTICHEATCOMMON_LOGPLAYERUSEABILITY_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATCOMMON_LOGPLAYERTAKEDAMAGE_API_LATEST: u32 = 3;
pub const EOS_ANTICHEATCLIENT_ADDNOTIFYMESSAGETOSERVER_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATCLIENT_ADDNOTIFYMESSAGETOPEER_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATCLIENT_ADDNOTIFYPEERACTIONREQUIRED_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATCLIENT_ADDNOTIFYPEERAUTHSTATUSCHANGED_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATCLIENT_ADDNOTIFYCLIENTINTEGRITYVIOLATED_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATCLIENT_BEGINSESSION_API_LATEST: u32 = 3;
pub const EOS_ANTICHEATCLIENT_ENDSESSION_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATCLIENT_ADDEXTERNALINTEGRITYCATALOG_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATCLIENT_RECEIVEMESSAGEFROMSERVER_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATCLIENT_GETPROTECTMESSAGEOUTPUTLENGTH_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATCLIENT_PROTECTMESSAGE_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATCLIENT_UNPROTECTMESSAGE_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATCLIENT_REGISTERPEER_MIN_AUTHENTICATIONTIMEOUT: u32 = 40;
pub const EOS_ANTICHEATCLIENT_REGISTERPEER_MAX_AUTHENTICATIONTIMEOUT: u32 = 120;
pub const EOS_ANTICHEATCLIENT_REGISTERPEER_API_LATEST: u32 = 3;
pub const EOS_ANTICHEATCLIENT_UNREGISTERPEER_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATCLIENT_RECEIVEMESSAGEFROMPEER_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATCLIENT_POLLSTATUS_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATSERVER_ADDNOTIFYMESSAGETOCLIENT_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATSERVER_ADDNOTIFYCLIENTACTIONREQUIRED_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATSERVER_ADDNOTIFYCLIENTAUTHSTATUSCHANGED_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATSERVER_BEGINSESSION_MIN_REGISTERTIMEOUT: u32 = 10;
pub const EOS_ANTICHEATSERVER_BEGINSESSION_MAX_REGISTERTIMEOUT: u32 = 120;
pub const EOS_ANTICHEATSERVER_BEGINSESSION_API_LATEST: u32 = 3;
pub const EOS_ANTICHEATSERVER_ENDSESSION_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATSERVER_REGISTERCLIENT_API_LATEST: u32 = 2;
pub const EOS_ANTICHEATSERVER_UNREGISTERCLIENT_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATSERVER_RECEIVEMESSAGEFROMCLIENT_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATSERVER_SETCLIENTNETWORKSTATE_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATSERVER_GETPROTECTMESSAGEOUTPUTLENGTH_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATSERVER_PROTECTMESSAGE_API_LATEST: u32 = 1;
pub const EOS_ANTICHEATSERVER_UNPROTECTMESSAGE_API_LATEST: u32 = 1;
pub const EOS_REPORTS_REPORTMESSAGE_MAX_LENGTH: u32 = 512;
pub const EOS_REPORTS_REPORTCONTEXT_MAX_LENGTH: u32 = 4096;
pub const EOS_REPORTS_SENDPLAYERBEHAVIORREPORT_API_LATEST: u32 = 2;
pub const EOS_SANCTIONS_PLAYERSANCTION_API_LATEST: u32 = 2;
pub const EOS_SANCTIONS_QUERYACTIVEPLAYERSANCTIONS_API_LATEST: u32 = 2;
pub const EOS_SANCTIONS_GETPLAYERSANCTIONCOUNT_API_LATEST: u32 = 1;
pub const EOS_SANCTIONS_COPYPLAYERSANCTIONBYINDEX_API_LATEST: u32 = 1;
pub const EOS_KWS_MAX_PERMISSIONS: u32 = 16;
pub const EOS_KWS_MAX_PERMISSION_LENGTH: u32 = 32;
pub const EOS_KWS_PERMISSIONSTATUS_API_LATEST: u32 = 1;
pub const EOS_KWS_QUERYAGEGATE_API_LATEST: u32 = 1;
pub const EOS_KWS_CREATEUSER_API_LATEST: u32 = 1;
pub const EOS_KWS_QUERYPERMISSIONS_API_LATEST: u32 = 1;
pub const EOS_KWS_UPDATEPARENTEMAIL_API_LATEST: u32 = 1;
pub const EOS_KWS_REQUESTPERMISSIONS_API_LATEST: u32 = 1;
pub const EOS_KWS_GETPERMISSIONSCOUNT_API_LATEST: u32 = 1;
pub const EOS_KWS_COPYPERMISSIONBYINDEX_API_LATEST: u32 = 1;
pub const EOS_KWS_GETPERMISSIONBYKEY_API_LATEST: u32 = 1;
pub const EOS_KWS_ADDNOTIFYPERMISSIONSUPDATERECEIVED_API_LATEST: u32 = 1;
pub const EOS_RTC_JOINROOM_API_LATEST: u32 = 1;
pub const EOS_RTC_JOINROOMFLAGS_ENABLE_ECHO: u32 = 1;
pub const EOS_RTC_JOINROOMFLAGS_ENABLE_DATACHANNEL: u32 = 4;
pub const EOS_RTC_OPTION_KEY_MAXCHARCOUNT: u32 = 256;
pub const EOS_RTC_OPTION_VALUE_MAXCHARCOUNT: u32 = 256;
pub const EOS_RTC_OPTION_API_LATEST: u32 = 1;
pub const EOS_RTC_LEAVEROOM_API_LATEST: u32 = 1;
pub const EOS_RTC_BLOCKPARTICIPANT_API_LATEST: u32 = 1;
pub const EOS_RTC_ADDNOTIFYDISCONNECTED_API_LATEST: u32 = 1;
pub const EOS_RTC_PARTICIPANTMETADATA_KEY_MAXCHARCOUNT: u32 = 256;
pub const EOS_RTC_PARTICIPANTMETADATA_VALUE_MAXCHARCOUNT: u32 = 256;
pub const EOS_RTC_PARTICIPANTMETADATA_API_LATEST: u32 = 1;
pub const EOS_RTC_ADDNOTIFYPARTICIPANTSTATUSCHANGED_API_LATEST: u32 = 1;
pub const EOS_RTC_SETSETTING_API_LATEST: u32 = 1;
pub const EOS_RTC_SETROOMSETTING_API_LATEST: u32 = 1;
pub const EOS_RTC_ADDNOTIFYROOMSTATISTICSUPDATED_API_LATEST: u32 = 1;
pub const EOS_RTCADMIN_QUERYJOINROOMTOKEN_API_LATEST: u32 = 2;
pub const EOS_RTCADMIN_USERTOKEN_API_LATEST: u32 = 1;
pub const EOS_RTCADMIN_COPYUSERTOKENBYINDEX_API_LATEST: u32 = 2;
pub const EOS_RTCADMIN_COPYUSERTOKENBYUSERID_API_LATEST: u32 = 2;
pub const EOS_RTCADMIN_KICK_API_LATEST: u32 = 1;
pub const EOS_RTCADMIN_SETPARTICIPANTHARDMUTE_API_LATEST: u32 = 1;
pub const EOS_INVALID_PROGRESSIONSNAPSHOTID: u32 = 0;
pub const EOS_PROGRESSIONSNAPSHOT_BEGINSNAPSHOT_API_LATEST: u32 = 1;
pub const EOS_PROGRESSIONSNAPSHOT_ADDPROGRESSION_API_LATEST: u32 = 1;
pub const EOS_PROGRESSIONSNAPSHOT_SUBMITSNAPSHOT_API_LATEST: u32 = 1;
pub const EOS_PROGRESSIONSNAPSHOT_ENDSNAPSHOT_API_LATEST: u32 = 1;
pub const EOS_PROGRESSIONSNAPSHOT_DELETESNAPSHOT_API_LATEST: u32 = 1;
pub const EOS_CUSTOMINVITES_MAX_PAYLOAD_LENGTH: u32 = 500;
pub const EOS_CUSTOMINVITES_SETCUSTOMINVITE_API_LATEST: u32 = 1;
pub const EOS_CUSTOMINVITES_SENDCUSTOMINVITE_API_LATEST: u32 = 1;
pub const EOS_CUSTOMINVITES_ADDNOTIFYCUSTOMINVITERECEIVED_API_LATEST: u32 = 1;
pub const EOS_CUSTOMINVITES_ADDNOTIFYCUSTOMINVITEACCEPTED_API_LATEST: u32 = 1;
pub const EOS_CUSTOMINVITES_ADDNOTIFYCUSTOMINVITEREJECTED_API_LATEST: u32 = 1;
pub const EOS_CUSTOMINVITES_FINALIZEINVITE_API_LATEST: u32 = 1;
pub const EOS_CUSTOMINVITES_SENDREQUESTTOJOIN_API_LATEST: u32 = 1;
pub const EOS_CUSTOMINVITES_ADDNOTIFYREQUESTTOJOINRESPONSERECEIVED_API_LATEST: u32 = 1;
pub const EOS_CUSTOMINVITES_ADDNOTIFYREQUESTTOJOINRECEIVED_API_LATEST: u32 = 1;
pub const EOS_CUSTOMINVITES_ACCEPTREQUESTTOJOIN_API_LATEST: u32 = 1;
pub const EOS_CUSTOMINVITES_REJECTREQUESTTOJOIN_API_LATEST: u32 = 1;
pub const EOS_CUSTOMINVITES_ADDNOTIFYSENDCUSTOMNATIVEINVITEREQUESTED_API_LATEST: u32 = 1;
pub const EOS_CUSTOMINVITES_ADDNOTIFYREQUESTTOJOINACCEPTED_API_LATEST: u32 = 1;
pub const EOS_CUSTOMINVITES_ADDNOTIFYREQUESTTOJOINREJECTED_API_LATEST: u32 = 1;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut va_list, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __vcrt_va_list_is_reference {
    pub _address: u8,
}
pub const __vcrt_va_list_is_reference___the_value: __vcrt_va_list_is_reference__bindgen_ty_1 =
    __vcrt_va_list_is_reference__bindgen_ty_1::__the_value;
#[repr(u8)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum __vcrt_va_list_is_reference__bindgen_ty_1 {
    __the_value = 0,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __vcrt_assert_va_start_is_not_reference {
    pub _address: u8,
}
pub type __vcrt_bool = bool;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type EOS_Bool = i32;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EResult {
    #[doc = " Successful result. no further error processing needed"]
    EOS_Success = 0,
    #[doc = " Failed due to no connection"]
    EOS_NoConnection = 1,
    #[doc = " Failed login due to invalid credentials"]
    EOS_InvalidCredentials = 2,
    #[doc = " Failed due to invalid or missing user"]
    EOS_InvalidUser = 3,
    #[doc = " Failed due to invalid or missing authentication token for user (e.g. not logged in)"]
    EOS_InvalidAuth = 4,
    #[doc = " Failed due to invalid access"]
    EOS_AccessDenied = 5,
    #[doc = " If the client does not possess the permission required"]
    EOS_MissingPermissions = 6,
    #[doc = " If the token provided does not represent an account"]
    EOS_Token_Not_Account = 7,
    #[doc = " Throttled due to too many requests"]
    EOS_TooManyRequests = 8,
    #[doc = " Async request was already pending"]
    EOS_AlreadyPending = 9,
    #[doc = " Invalid parameters specified for request"]
    EOS_InvalidParameters = 10,
    #[doc = " Invalid request"]
    EOS_InvalidRequest = 11,
    #[doc = " Failed due to unable to parse or recognize a backend response"]
    EOS_UnrecognizedResponse = 12,
    #[doc = " Incompatible client for backend version"]
    EOS_IncompatibleVersion = 13,
    #[doc = " Not configured correctly for use"]
    EOS_NotConfigured = 14,
    #[doc = " Already configured for use."]
    EOS_AlreadyConfigured = 15,
    #[doc = " Feature not available on this implementation"]
    EOS_NotImplemented = 16,
    #[doc = " Operation was canceled (likely by user)"]
    EOS_Canceled = 17,
    #[doc = " The requested information was not found"]
    EOS_NotFound = 18,
    #[doc = " An error occurred during an asynchronous operation, and it will be retried. Callbacks receiving this result will be called again in the future."]
    EOS_OperationWillRetry = 19,
    #[doc = " The request had no effect"]
    EOS_NoChange = 20,
    #[doc = " The request attempted to use multiple or inconsistent API versions"]
    EOS_VersionMismatch = 21,
    #[doc = " A maximum limit was exceeded on the client, different from EOS_TooManyRequests"]
    EOS_LimitExceeded = 22,
    #[doc = " Feature or client ID performing the operation has been disabled."]
    EOS_Disabled = 23,
    #[doc = " Duplicate entry not allowed"]
    EOS_DuplicateNotAllowed = 24,
    #[doc = " Required parameters are missing. DEPRECATED: This error is no longer used."]
    EOS_MissingParameters_DEPRECATED = 25,
    #[doc = " Sandbox ID is invalid"]
    EOS_InvalidSandboxId = 26,
    #[doc = " Request timed out"]
    EOS_TimedOut = 27,
    #[doc = " A query returned some but not all of the requested results."]
    EOS_PartialResult = 28,
    #[doc = " Client is missing the whitelisted role"]
    EOS_Missing_Role = 29,
    #[doc = " Client is missing the whitelisted feature"]
    EOS_Missing_Feature = 30,
    #[doc = " The sandbox given to the backend is invalid"]
    EOS_Invalid_Sandbox = 31,
    #[doc = " The deployment given to the backend is invalid"]
    EOS_Invalid_Deployment = 32,
    #[doc = " The product ID specified to the backend is invalid"]
    EOS_Invalid_Product = 33,
    #[doc = " The product user ID specified to the backend is invalid"]
    EOS_Invalid_ProductUserID = 34,
    #[doc = " There was a failure with the backend service"]
    EOS_ServiceFailure = 35,
    #[doc = " Cache directory is not set in platform options."]
    EOS_CacheDirectoryMissing = 36,
    #[doc = " Cache directory is not accessible."]
    EOS_CacheDirectoryInvalid = 37,
    #[doc = " The request failed because resource was in an invalid state"]
    EOS_InvalidState = 38,
    #[doc = " Request is in progress"]
    EOS_RequestInProgress = 39,
    #[doc = " Application is suspended"]
    EOS_ApplicationSuspended = 40,
    #[doc = " Network is disconnected"]
    EOS_NetworkDisconnected = 41,
    #[doc = " Account locked due to login failures"]
    EOS_Auth_AccountLocked = 1001,
    #[doc = " Account locked by update operation."]
    EOS_Auth_AccountLockedForUpdate = 1002,
    #[doc = " Refresh token used was invalid"]
    EOS_Auth_InvalidRefreshToken = 1003,
    #[doc = " Invalid access token, typically when switching between backend environments"]
    EOS_Auth_InvalidToken = 1004,
    #[doc = " Invalid bearer token"]
    EOS_Auth_AuthenticationFailure = 1005,
    #[doc = " Invalid platform token"]
    EOS_Auth_InvalidPlatformToken = 1006,
    #[doc = " Auth parameters are not associated with this account"]
    EOS_Auth_WrongAccount = 1007,
    #[doc = " Auth parameters are not associated with this client"]
    EOS_Auth_WrongClient = 1008,
    #[doc = " Full account is required"]
    EOS_Auth_FullAccountRequired = 1009,
    #[doc = " Headless account is required"]
    EOS_Auth_HeadlessAccountRequired = 1010,
    #[doc = " Password reset is required"]
    EOS_Auth_PasswordResetRequired = 1011,
    #[doc = " Password was previously used and cannot be reused"]
    EOS_Auth_PasswordCannotBeReused = 1012,
    #[doc = " Authorization code/exchange code has expired"]
    EOS_Auth_Expired = 1013,
    #[doc = " Consent has not been given by the user"]
    EOS_Auth_ScopeConsentRequired = 1014,
    #[doc = " The application has no profile on the backend"]
    EOS_Auth_ApplicationNotFound = 1015,
    #[doc = " The requested consent wasn't found on the backend"]
    EOS_Auth_ScopeNotFound = 1016,
    #[doc = " This account has been denied access to login"]
    EOS_Auth_AccountFeatureRestricted = 1017,
    #[doc = " The overlay failed to load the Account Portal. This can range from general overlay failure, to overlay failed to connect to the web server, to overlay failed to render the web page."]
    EOS_Auth_AccountPortalLoadError = 1018,
    #[doc = " An attempted login has failed due to the user needing to take corrective action on their account."]
    EOS_Auth_CorrectiveActionRequired = 1019,
    #[doc = " Pin grant code initiated"]
    EOS_Auth_PinGrantCode = 1020,
    #[doc = " Pin grant code attempt expired"]
    EOS_Auth_PinGrantExpired = 1021,
    #[doc = " Pin grant code attempt pending"]
    EOS_Auth_PinGrantPending = 1022,
    #[doc = " External auth source did not yield an account"]
    EOS_Auth_ExternalAuthNotLinked = 1030,
    #[doc = " External auth access revoked"]
    EOS_Auth_ExternalAuthRevoked = 1032,
    #[doc = " External auth token cannot be interpreted"]
    EOS_Auth_ExternalAuthInvalid = 1033,
    #[doc = " External auth cannot be linked to his account due to restrictions"]
    EOS_Auth_ExternalAuthRestricted = 1034,
    #[doc = " External auth cannot be used for login"]
    EOS_Auth_ExternalAuthCannotLogin = 1035,
    #[doc = " External auth is expired"]
    EOS_Auth_ExternalAuthExpired = 1036,
    #[doc = " External auth cannot be removed since it's the last possible way to login"]
    EOS_Auth_ExternalAuthIsLastLoginType = 1037,
    #[doc = " Exchange code not found"]
    EOS_Auth_ExchangeCodeNotFound = 1040,
    #[doc = " Originating exchange code session has expired"]
    EOS_Auth_OriginatingExchangeCodeSessionExpired = 1041,
    #[doc = " The account has been disabled and cannot be used for authentication"]
    EOS_Auth_AccountNotActive = 1050,
    #[doc = " MFA challenge required"]
    EOS_Auth_MFARequired = 1060,
    #[doc = " Parental locks are in place"]
    EOS_Auth_ParentalControls = 1070,
    #[doc = " Korea real ID association required but missing"]
    EOS_Auth_NoRealId = 1080,
    #[doc = " Silent login failed when EOS_LF_NO_USER_INTERFACE was specified, and user interaction is needed before the user can be logged in."]
    EOS_Auth_UserInterfaceRequired = 1090,
    #[doc = " An outgoing friend invitation is awaiting acceptance; sending another invite to the same user is erroneous"]
    EOS_Friends_InviteAwaitingAcceptance = 2000,
    #[doc = " There is no friend invitation to accept/reject"]
    EOS_Friends_NoInvitation = 2001,
    #[doc = " Users are already friends, so sending another invite is erroneous"]
    EOS_Friends_AlreadyFriends = 2003,
    #[doc = " Users are not friends, so deleting the friend is erroneous"]
    EOS_Friends_NotFriends = 2004,
    #[doc = " Remote user has too many invites to receive new invites"]
    EOS_Friends_TargetUserTooManyInvites = 2005,
    #[doc = " Local user has too many invites to send new invites"]
    EOS_Friends_LocalUserTooManyInvites = 2006,
    #[doc = " Remote user has too many friends to make a new friendship"]
    EOS_Friends_TargetUserFriendLimitExceeded = 2007,
    #[doc = " Local user has too many friends to make a new friendship"]
    EOS_Friends_LocalUserFriendLimitExceeded = 2008,
    #[doc = " Request data was null or invalid"]
    EOS_Presence_DataInvalid = 3000,
    #[doc = " Request contained too many or too few unique data items, or the request would overflow the maximum amount of data allowed"]
    EOS_Presence_DataLengthInvalid = 3001,
    #[doc = " Request contained data with an invalid key"]
    EOS_Presence_DataKeyInvalid = 3002,
    #[doc = " Request contained data with a key too long or too short"]
    EOS_Presence_DataKeyLengthInvalid = 3003,
    #[doc = " Request contained data with an invalid value"]
    EOS_Presence_DataValueInvalid = 3004,
    #[doc = " Request contained data with a value too long"]
    EOS_Presence_DataValueLengthInvalid = 3005,
    #[doc = " Request contained an invalid rich text string"]
    EOS_Presence_RichTextInvalid = 3006,
    #[doc = " Request contained a rich text string that was too long"]
    EOS_Presence_RichTextLengthInvalid = 3007,
    #[doc = " Request contained an invalid status state"]
    EOS_Presence_StatusInvalid = 3008,
    #[doc = " The entitlement retrieved is stale, requery for updated information"]
    EOS_Ecom_EntitlementStale = 4000,
    #[doc = " The offer retrieved is stale, requery for updated information"]
    EOS_Ecom_CatalogOfferStale = 4001,
    #[doc = " The item or associated structure retrieved is stale, requery for updated information"]
    EOS_Ecom_CatalogItemStale = 4002,
    #[doc = " The one or more offers has an invalid price. This may be caused by the price setup."]
    EOS_Ecom_CatalogOfferPriceInvalid = 4003,
    #[doc = " The checkout page failed to load"]
    EOS_Ecom_CheckoutLoadError = 4004,
    #[doc = " The player closed the purchase flow overlay after clicking the purchase button. The purchase may still go through, and the game needs to query unredeemed entitlements for a short time."]
    EOS_Ecom_PurchaseProcessing = 4005,
    #[doc = " Session is already in progress"]
    EOS_Sessions_SessionInProgress = 5000,
    #[doc = " Too many players to register with this session"]
    EOS_Sessions_TooManyPlayers = 5001,
    #[doc = " Client has no permissions to access this session"]
    EOS_Sessions_NoPermission = 5002,
    #[doc = " Session already exists in the system"]
    EOS_Sessions_SessionAlreadyExists = 5003,
    #[doc = " Session lock required for operation"]
    EOS_Sessions_InvalidLock = 5004,
    #[doc = " Invalid session reference"]
    EOS_Sessions_InvalidSession = 5005,
    #[doc = " Sandbox ID associated with auth didn't match"]
    EOS_Sessions_SandboxNotAllowed = 5006,
    #[doc = " Invite failed to send"]
    EOS_Sessions_InviteFailed = 5007,
    #[doc = " Invite was not found with the service"]
    EOS_Sessions_InviteNotFound = 5008,
    #[doc = " This client may not modify the session"]
    EOS_Sessions_UpsertNotAllowed = 5009,
    #[doc = " Backend nodes unavailable to process request"]
    EOS_Sessions_AggregationFailed = 5010,
    #[doc = " Individual backend node is as capacity"]
    EOS_Sessions_HostAtCapacity = 5011,
    #[doc = " Sandbox on node is at capacity"]
    EOS_Sessions_SandboxAtCapacity = 5012,
    #[doc = " An anonymous operation was attempted on a non anonymous session"]
    EOS_Sessions_SessionNotAnonymous = 5013,
    #[doc = " Session is currently out of sync with the backend, data is saved locally but needs to sync with backend"]
    EOS_Sessions_OutOfSync = 5014,
    #[doc = " User has received too many invites"]
    EOS_Sessions_TooManyInvites = 5015,
    #[doc = " Presence session already exists for the client"]
    EOS_Sessions_PresenceSessionExists = 5016,
    #[doc = " Deployment on node is at capacity"]
    EOS_Sessions_DeploymentAtCapacity = 5017,
    #[doc = " Session operation not allowed"]
    EOS_Sessions_NotAllowed = 5018,
    #[doc = " Session operation not allowed"]
    EOS_Sessions_PlayerSanctioned = 5019,
    #[doc = " Request filename was invalid"]
    EOS_PlayerDataStorage_FilenameInvalid = 6000,
    #[doc = " Request filename was too long"]
    EOS_PlayerDataStorage_FilenameLengthInvalid = 6001,
    #[doc = " Request filename contained invalid characters"]
    EOS_PlayerDataStorage_FilenameInvalidChars = 6002,
    #[doc = " Request operation would grow file too large"]
    EOS_PlayerDataStorage_FileSizeTooLarge = 6003,
    #[doc = " Request file length is not valid"]
    EOS_PlayerDataStorage_FileSizeInvalid = 6004,
    #[doc = " Request file handle is not valid"]
    EOS_PlayerDataStorage_FileHandleInvalid = 6005,
    #[doc = " Request data is invalid"]
    EOS_PlayerDataStorage_DataInvalid = 6006,
    #[doc = " Request data length was invalid"]
    EOS_PlayerDataStorage_DataLengthInvalid = 6007,
    #[doc = " Request start index was invalid"]
    EOS_PlayerDataStorage_StartIndexInvalid = 6008,
    #[doc = " Request is in progress"]
    EOS_PlayerDataStorage_RequestInProgress = 6009,
    #[doc = " User is marked as throttled which means he can't perform some operations because limits are exceeded."]
    EOS_PlayerDataStorage_UserThrottled = 6010,
    #[doc = " Encryption key is not set during SDK init."]
    EOS_PlayerDataStorage_EncryptionKeyNotSet = 6011,
    #[doc = " User data callback returned error (EOS_PlayerDataStorage_EWriteResult::EOS_WR_FailRequest or EOS_PlayerDataStorage_EReadResult::EOS_RR_FailRequest)"]
    EOS_PlayerDataStorage_UserErrorFromDataCallback = 6012,
    #[doc = " User is trying to read file that has header from newer version of SDK. Game/SDK needs to be updated."]
    EOS_PlayerDataStorage_FileHeaderHasNewerVersion = 6013,
    #[doc = " The file is corrupted. In some cases retry can fix the issue."]
    EOS_PlayerDataStorage_FileCorrupted = 6014,
    #[doc = " EOS Auth service deemed the external token invalid"]
    EOS_Connect_ExternalTokenValidationFailed = 7000,
    #[doc = " EOS Auth user already exists"]
    EOS_Connect_UserAlreadyExists = 7001,
    #[doc = " EOS Auth expired"]
    EOS_Connect_AuthExpired = 7002,
    #[doc = " EOS Auth invalid token"]
    EOS_Connect_InvalidToken = 7003,
    #[doc = " EOS Auth doesn't support this token type"]
    EOS_Connect_UnsupportedTokenType = 7004,
    #[doc = " EOS Auth Account link failure"]
    EOS_Connect_LinkAccountFailed = 7005,
    #[doc = " EOS Auth External service for validation was unavailable"]
    EOS_Connect_ExternalServiceUnavailable = 7006,
    #[doc = " EOS Auth External Service configuration failure with Dev Portal"]
    EOS_Connect_ExternalServiceConfigurationFailure = 7007,
    #[doc = " EOS Auth Account link failure. Tried to link Nintendo Network Service Account without first linking Nintendo Account. DEPRECATED: The requirement has been removed and this error is no longer used."]
    EOS_Connect_LinkAccountFailedMissingNintendoIdAccount_DEPRECATED = 7008,
    #[doc = " The social overlay page failed to load"]
    EOS_UI_SocialOverlayLoadError = 8000,
    #[doc = " Client has no permissions to modify this lobby"]
    EOS_Lobby_NotOwner = 9000,
    #[doc = " Lobby lock required for operation"]
    EOS_Lobby_InvalidLock = 9001,
    #[doc = " Lobby already exists in the system"]
    EOS_Lobby_LobbyAlreadyExists = 9002,
    #[doc = " Lobby is already in progress"]
    EOS_Lobby_SessionInProgress = 9003,
    #[doc = " Too many players to register with this lobby"]
    EOS_Lobby_TooManyPlayers = 9004,
    #[doc = " Client has no permissions to access this lobby"]
    EOS_Lobby_NoPermission = 9005,
    #[doc = " Invalid lobby session reference"]
    EOS_Lobby_InvalidSession = 9006,
    #[doc = " Sandbox ID associated with auth didn't match"]
    EOS_Lobby_SandboxNotAllowed = 9007,
    #[doc = " Invite failed to send"]
    EOS_Lobby_InviteFailed = 9008,
    #[doc = " Invite was not found with the service"]
    EOS_Lobby_InviteNotFound = 9009,
    #[doc = " This client may not modify the lobby"]
    EOS_Lobby_UpsertNotAllowed = 9010,
    #[doc = " Backend nodes unavailable to process request"]
    EOS_Lobby_AggregationFailed = 9011,
    #[doc = " Individual backend node is as capacity"]
    EOS_Lobby_HostAtCapacity = 9012,
    #[doc = " Sandbox on node is at capacity"]
    EOS_Lobby_SandboxAtCapacity = 9013,
    #[doc = " User has received too many invites"]
    EOS_Lobby_TooManyInvites = 9014,
    #[doc = " Deployment on node is at capacity"]
    EOS_Lobby_DeploymentAtCapacity = 9015,
    #[doc = " Lobby operation not allowed"]
    EOS_Lobby_NotAllowed = 9016,
    #[doc = " While restoring a lost connection lobby ownership changed and only local member data was updated"]
    EOS_Lobby_MemberUpdateOnly = 9017,
    #[doc = " Presence lobby already exists for the client"]
    EOS_Lobby_PresenceLobbyExists = 9018,
    #[doc = " Operation requires lobby with voice enabled"]
    EOS_Lobby_VoiceNotEnabled = 9019,
    #[doc = " The client platform does not match the allowed platform list for the lobby."]
    EOS_Lobby_PlatformNotAllowed = 9020,
    #[doc = " User callback that receives data from storage returned error."]
    EOS_TitleStorage_UserErrorFromDataCallback = 10000,
    #[doc = " User forgot to set Encryption key during platform init. Title Storage can't work without it."]
    EOS_TitleStorage_EncryptionKeyNotSet = 10001,
    #[doc = " Downloaded file is corrupted."]
    EOS_TitleStorage_FileCorrupted = 10002,
    #[doc = " Downloaded file's format is newer than client SDK version."]
    EOS_TitleStorage_FileHeaderHasNewerVersion = 10003,
    #[doc = " ModSdk process is already running. This error comes from the EOSSDK."]
    EOS_Mods_ModSdkProcessIsAlreadyRunning = 11000,
    #[doc = " ModSdk command is empty. Either the ModSdk configuration file is missing or the manifest location is empty."]
    EOS_Mods_ModSdkCommandIsEmpty = 11001,
    #[doc = " Creation of the ModSdk process failed. This error comes from the SDK."]
    EOS_Mods_ModSdkProcessCreationFailed = 11002,
    #[doc = " A critical error occurred in the external ModSdk process that we were unable to resolve."]
    EOS_Mods_CriticalError = 11003,
    #[doc = " A internal error occurred in the external ModSdk process that we were unable to resolve."]
    EOS_Mods_ToolInternalError = 11004,
    #[doc = " A IPC failure occurred in the external ModSdk process."]
    EOS_Mods_IPCFailure = 11005,
    #[doc = " A invalid IPC response received in the external ModSdk process."]
    EOS_Mods_InvalidIPCResponse = 11006,
    #[doc = " A URI Launch failure occurred in the external ModSdk process."]
    EOS_Mods_URILaunchFailure = 11007,
    #[doc = " Attempting to perform an action with a mod that is not installed. This error comes from the external ModSdk process."]
    EOS_Mods_ModIsNotInstalled = 11008,
    #[doc = " Attempting to perform an action on a game that the user doesn't own. This error comes from the external ModSdk process."]
    EOS_Mods_UserDoesNotOwnTheGame = 11009,
    #[doc = " Invalid result of the request to get the offer for the mod. This error comes from the external ModSdk process."]
    EOS_Mods_OfferRequestByIdInvalidResult = 11010,
    #[doc = " Could not find the offer for the mod. This error comes from the external ModSdk process."]
    EOS_Mods_CouldNotFindOffer = 11011,
    #[doc = " Request to get the offer for the mod failed. This error comes from the external ModSdk process."]
    EOS_Mods_OfferRequestByIdFailure = 11012,
    #[doc = " Request to purchase the mod failed. This error comes from the external ModSdk process."]
    EOS_Mods_PurchaseFailure = 11013,
    #[doc = " Attempting to perform an action on a game that is not installed or is partially installed. This error comes from the external ModSdk process."]
    EOS_Mods_InvalidGameInstallInfo = 11014,
    #[doc = " Failed to get manifest location. Either the ModSdk configuration file is missing or the manifest location is empty"]
    EOS_Mods_CannotGetManifestLocation = 11015,
    #[doc = " Attempting to perform an action with a mod that does not support the current operating system."]
    EOS_Mods_UnsupportedOS = 11016,
    #[doc = " The anti-cheat client protection is not available. Check that the game was started using the anti-cheat bootstrapper."]
    EOS_AntiCheat_ClientProtectionNotAvailable = 12000,
    #[doc = " The current anti-cheat mode is incorrect for using this API"]
    EOS_AntiCheat_InvalidMode = 12001,
    #[doc = " The ProductId provided to the anti-cheat client helper executable does not match what was used to initialize the EOS SDK"]
    EOS_AntiCheat_ClientProductIdMismatch = 12002,
    #[doc = " The SandboxId provided to the anti-cheat client helper executable does not match what was used to initialize the EOS SDK"]
    EOS_AntiCheat_ClientSandboxIdMismatch = 12003,
    #[doc = " (ProtectMessage/UnprotectMessage) No session key is available, but it is required to complete this operation"]
    EOS_AntiCheat_ProtectMessageSessionKeyRequired = 12004,
    #[doc = " (ProtectMessage/UnprotectMessage) Message integrity is invalid"]
    EOS_AntiCheat_ProtectMessageValidationFailed = 12005,
    #[doc = " (ProtectMessage/UnprotectMessage) Initialization failed"]
    EOS_AntiCheat_ProtectMessageInitializationFailed = 12006,
    #[doc = " (RegisterPeer) Peer is already registered"]
    EOS_AntiCheat_PeerAlreadyRegistered = 12007,
    #[doc = " (UnregisterPeer) Peer does not exist"]
    EOS_AntiCheat_PeerNotFound = 12008,
    #[doc = " (ReceiveMessageFromPeer) Invalid call: Peer is not protected"]
    EOS_AntiCheat_PeerNotProtected = 12009,
    #[doc = " The DeploymentId provided to the anti-cheat client helper executable does not match what was used to initialize the EOS SDK"]
    EOS_AntiCheat_ClientDeploymentIdMismatch = 12010,
    #[doc = " EOS Connect DeviceID auth method is not supported for anti-cheat"]
    EOS_AntiCheat_DeviceIdAuthIsNotSupported = 12011,
    #[doc = " EOS RTC room cannot accept more participants"]
    EOS_RTC_TooManyParticipants = 13000,
    #[doc = " EOS RTC room already exists"]
    EOS_RTC_RoomAlreadyExists = 13001,
    #[doc = " The user kicked out from the room"]
    EOS_RTC_UserKicked = 13002,
    #[doc = " The user is banned"]
    EOS_RTC_UserBanned = 13003,
    #[doc = " EOS RTC room was left successfully"]
    EOS_RTC_RoomWasLeft = 13004,
    #[doc = " Connection dropped due to long timeout"]
    EOS_RTC_ReconnectionTimegateExpired = 13005,
    #[doc = " EOS RTC room was left due to platform release"]
    EOS_RTC_ShutdownInvoked = 13006,
    #[doc = " EOS RTC operation failed because the user is in the local user's block list"]
    EOS_RTC_UserIsInBlocklist = 13007,
    #[doc = " The number of available Snapshot IDs have all been exhausted."]
    EOS_ProgressionSnapshot_SnapshotIdUnavailable = 14000,
    #[doc = " The KWS user does not have a parental email associated with the account.  The parent account was unlinked or deleted"]
    EOS_KWS_ParentEmailMissing = 15000,
    #[doc = " The KWS user is no longer a minor and trying to update the parent email"]
    EOS_KWS_UserGraduated = 15001,
    #[doc = " EOS Android VM not stored"]
    EOS_Android_JavaVMNotStored = 17000,
    #[doc = " Patch required before the user can use the privilege"]
    EOS_Permission_RequiredPatchAvailable = 18000,
    #[doc = " System update required before the user can use the privilege"]
    EOS_Permission_RequiredSystemUpdate = 18001,
    #[doc = " Parental control failure usually"]
    EOS_Permission_AgeRestrictionFailure = 18002,
    #[doc = " Premium Account Subscription required but not available"]
    EOS_Permission_AccountTypeFailure = 18003,
    #[doc = " User restricted from chat"]
    EOS_Permission_ChatRestriction = 18004,
    #[doc = " User restricted from User Generated Content"]
    EOS_Permission_UGCRestriction = 18005,
    #[doc = " Online play is restricted"]
    EOS_Permission_OnlinePlayRestricted = 18006,
    #[doc = " The application was not launched through the Bootstrapper. Desktop crossplay functionality is unavailable."]
    EOS_DesktopCrossplay_ApplicationNotBootstrapped = 19000,
    #[doc = " The redistributable service is not installed."]
    EOS_DesktopCrossplay_ServiceNotInstalled = 19001,
    #[doc = " The desktop crossplay service failed to start."]
    EOS_DesktopCrossplay_ServiceStartFailed = 19002,
    #[doc = " The desktop crossplay service is no longer running for an unknown reason."]
    EOS_DesktopCrossplay_ServiceNotRunning = 19003,
    #[doc = " When sending the custom invite failed."]
    EOS_CustomInvites_InviteFailed = 20000,
    #[doc = " The best display name could not be safely determined."]
    EOS_UserInfo_BestDisplayNameIndeterminate = 22000,
    #[doc = " An unexpected error that we cannot identify has occurred."]
    EOS_UnexpectedError = 2147483647,
}
extern "C" {
    #[doc = " Returns a string representation of an EOS_EResult.\n The return value is never null.\n The return value must not be freed.\n\n Example: EOS_EResult_ToString(EOS_Success) returns \"EOS_Success\""]
    pub fn EOS_EResult_ToString(Result: EOS_EResult) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns whether a result is to be considered the final result, or false if the callback that returned this result\n will be called again either after some time or from another action.\n\n @param Result The result to check against being a final result for an operation\n @return True if this result means the operation is complete, false otherwise"]
    pub fn EOS_EResult_IsOperationComplete(Result: EOS_EResult) -> EOS_Bool;
}
extern "C" {
    #[doc = " Encode a byte array into hex encoded string\n\n @return An EOS_EResult that indicates whether the byte array was converted and copied into the OutBuffer.\n         EOS_Success if the encoding was successful and passed out in OutBuffer\n         EOS_InvalidParameters if you pass a null pointer on invalid length for any of the parameters\n         EOS_LimitExceeded - The OutBuffer is not large enough to receive the encoding. InOutBufferLength contains the required minimum length to perform the operation successfully."]
    pub fn EOS_ByteArray_ToString(
        ByteArray: *const u8,
        Length: u32,
        OutBuffer: *mut ::std::os::raw::c_char,
        InOutBufferLength: *mut u32,
    ) -> EOS_EResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_EpicAccountIdDetails {
    _unused: [u8; 0],
}
#[doc = " A handle to a user's Epic Account ID\n This ID is associated with a specific login associated with Epic Account Services\n\n @see EOS_Auth_Login"]
pub type EOS_EpicAccountId = *mut EOS_EpicAccountIdDetails;
extern "C" {
    #[doc = " Check whether or not the given Epic Account ID is considered valid\n NOTE: This will return true for any EOS_EpicAccountId created with EOS_EpicAccountId_FromString as there is no validation\n\n @param AccountId The Epic Account ID to check for validity\n @return EOS_TRUE if the EOS_EpicAccountId is valid, otherwise EOS_FALSE"]
    pub fn EOS_EpicAccountId_IsValid(AccountId: EOS_EpicAccountId) -> EOS_Bool;
}
extern "C" {
    #[doc = " Retrieve a null-terminated stringified Epic Account ID from an EOS_EpicAccountId. This is useful for replication of Epic Account IDs in multiplayer games.\n This string will be no larger than EOS_EPICACCOUNTID_MAX_LENGTH + 1 and will only contain UTF8-encoded printable characters as well as a null-terminator.\n\n @param AccountId The Epic Account ID for which to retrieve the stringified version.\n @param OutBuffer The buffer into which the character data should be written\n @param InOutBufferLength The size of the OutBuffer in characters.\n                          The input buffer should include enough space to be null-terminated.\n                          When the function returns, this parameter will be filled with the length of the string copied into OutBuffer including the null-termination character.\n\n @return An EOS_EResult that indicates whether the Epic Account ID string was copied into the OutBuffer.\n         EOS_Success - The OutBuffer was filled, and InOutBufferLength contains the number of characters copied into OutBuffer including the null-terminator.\n         EOS_InvalidParameters - Either OutBuffer or InOutBufferLength were passed as NULL parameters.\n         EOS_InvalidUser - The AccountId is invalid and cannot be stringified.\n         EOS_LimitExceeded - The OutBuffer is not large enough to receive the Epic Account ID string. InOutBufferLength contains the required minimum length to perform the operation successfully."]
    pub fn EOS_EpicAccountId_ToString(
        AccountId: EOS_EpicAccountId,
        OutBuffer: *mut ::std::os::raw::c_char,
        InOutBufferLength: *mut i32,
    ) -> EOS_EResult;
}
extern "C" {
    #[doc = " Retrieve an EOS_EpicAccountId from a raw string representing an Epic Account ID. The input string must be null-terminated.\n NOTE: There is no validation on the string format, this should only be used with values serialized from legitimate sources such as EOS_EpicAccountId_ToString\n\n @param AccountIdString The stringified account ID for which to retrieve the Epic Account ID\n @return The EOS_EpicAccountId that corresponds to the AccountIdString"]
    pub fn EOS_EpicAccountId_FromString(
        AccountIdString: *const ::std::os::raw::c_char,
    ) -> EOS_EpicAccountId;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_ProductUserIdDetails {
    _unused: [u8; 0],
}
#[doc = " A handle to a user's Product User ID (game services related ecosystem)\n This ID is associated with any of the external account providers (of which Epic Account Services is one)\n\n @see EOS_Connect_Login\n @see EOS_EExternalCredentialType"]
pub type EOS_ProductUserId = *mut EOS_ProductUserIdDetails;
extern "C" {
    #[doc = " Check whether or not the given account unique ID is considered valid\n NOTE: This will return true for any EOS_ProductUserId created with EOS_ProductUserId_FromString as there is no validation\n\n @param AccountId The Product User ID to check for validity\n @return EOS_TRUE if the EOS_ProductUserId is valid, otherwise EOS_FALSE"]
    pub fn EOS_ProductUserId_IsValid(AccountId: EOS_ProductUserId) -> EOS_Bool;
}
extern "C" {
    #[doc = " Retrieve a null-terminated stringified Product User ID from an EOS_ProductUserId. This is useful for replication of Product User IDs in multiplayer games.\n This string will be no larger than EOS_PRODUCTUSERID_MAX_LENGTH + 1 and will only contain UTF8-encoded printable characters as well as the null-terminator.\n\n @param AccountId The Product User ID for which to retrieve the stringified version.\n @param OutBuffer The buffer into which the character data should be written\n @param InOutBufferLength The size of the OutBuffer in characters.\n                          The input buffer should include enough space to be null-terminated.\n                          When the function returns, this parameter will be filled with the length of the string copied into OutBuffer including the null-termination character.\n\n @return An EOS_EResult that indicates whether the Product User ID string was copied into the OutBuffer.\n         EOS_Success - The OutBuffer was filled, and InOutBufferLength contains the number of characters copied into OutBuffer including the null-terminator.\n         EOS_InvalidParameters - Either OutBuffer or InOutBufferLength were passed as NULL parameters.\n         EOS_InvalidUser - The AccountId is invalid and cannot be stringified.\n         EOS_LimitExceeded - The OutBuffer is not large enough to receive the Product User ID string. InOutBufferLength contains the required minimum length to perform the operation successfully."]
    pub fn EOS_ProductUserId_ToString(
        AccountId: EOS_ProductUserId,
        OutBuffer: *mut ::std::os::raw::c_char,
        InOutBufferLength: *mut i32,
    ) -> EOS_EResult;
}
extern "C" {
    #[doc = " Retrieve an EOS_ProductUserId from a raw string representing an Epic Online Services Product User ID. The input string must be null-terminated.\n NOTE: There is no validation on the string format, this should only be used with values serialized from legitimate sources such as EOS_ProductUserId_ToString\n\n @param ProductUserIdString The stringified product user ID for which to retrieve the Epic Online Services Product User ID\n @return The EOS_ProductUserId that corresponds to the ProductUserIdString"]
    pub fn EOS_ProductUserId_FromString(
        ProductUserIdString: *const ::std::os::raw::c_char,
    ) -> EOS_ProductUserId;
}
#[doc = " Handle to an existing registered notification (0 is an invalid handle)"]
pub type EOS_NotificationId = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_ContinuanceTokenDetails {
    _unused: [u8; 0],
}
#[doc = " A handle to a continuance token @see eos_connect.h"]
pub type EOS_ContinuanceToken = *mut EOS_ContinuanceTokenDetails;
extern "C" {
    #[doc = " Retrieve a null-terminated stringified continuance token from an EOS_ContinuanceToken.\n\n To get the required buffer size, call once with OutBuffer set to NULL, InOutBufferLength will contain the buffer size needed.\n Call again with valid params to get the stringified continuance token which will only contain UTF8-encoded printable characters as well as the null-terminator.\n\n @param ContinuanceToken The continuance token for which to retrieve the stringified version.\n @param OutBuffer The buffer into which the character data should be written\n @param InOutBufferLength The size of the OutBuffer in characters.\n                          The input buffer should include enough space to be null-terminated.\n                          When the function returns, this parameter will be filled with the length of the string copied into OutBuffer including the null-termination character.\n\n @return An EOS_EResult that indicates whether the continuance token string was copied into the OutBuffer.\n         EOS_Success - The OutBuffer was filled, and InOutBufferLength contains the number of characters copied into OutBuffer including the null-terminator.\n         EOS_InvalidParameters - Either OutBuffer or InOutBufferLength were passed as NULL parameters.\n         EOS_InvalidUser - The AccountId is invalid and cannot be stringified.\n         EOS_LimitExceeded - The OutBuffer is not large enough to receive the continuance token string. InOutBufferLength contains the required minimum length to perform the operation successfully."]
    pub fn EOS_ContinuanceToken_ToString(
        ContinuanceToken: EOS_ContinuanceToken,
        OutBuffer: *mut ::std::os::raw::c_char,
        InOutBufferLength: *mut i32,
    ) -> EOS_EResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PageQuery {
    #[doc = " API Version: Set this to EOS_PAGEQUERY_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The index into the ordered query results to start the page at."]
    pub StartIndex: i32,
    #[doc = " The maximum number of results to have in the page."]
    pub MaxCount: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_PageQuery() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_PageQuery> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PageQuery>(),
        12usize,
        concat!("Size of: ", stringify!(_tagEOS_PageQuery))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PageQuery>(),
        4usize,
        concat!("Alignment of ", stringify!(_tagEOS_PageQuery))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PageQuery),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StartIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PageQuery),
            "::",
            stringify!(StartIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PageQuery),
            "::",
            stringify!(MaxCount)
        )
    );
}
pub type EOS_PageQuery = _tagEOS_PageQuery;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PageResult {
    #[doc = " The index into the ordered query results to start the page at."]
    pub StartIndex: i32,
    #[doc = " The number of results in the current page."]
    pub Count: i32,
    #[doc = " The number of results associated with they original query options."]
    pub TotalCount: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_PageResult() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_PageResult> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PageResult>(),
        12usize,
        concat!("Size of: ", stringify!(_tagEOS_PageResult))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PageResult>(),
        4usize,
        concat!("Alignment of ", stringify!(_tagEOS_PageResult))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StartIndex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PageResult),
            "::",
            stringify!(StartIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PageResult),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PageResult),
            "::",
            stringify!(TotalCount)
        )
    );
}
pub type EOS_PageResult = _tagEOS_PageResult;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_ELoginStatus {
    #[doc = " Player has not logged in or chosen a local profile"]
    EOS_LS_NotLoggedIn = 0,
    #[doc = " Player is using a local profile but is not logged in"]
    EOS_LS_UsingLocalProfile = 1,
    #[doc = " Player has been validated by the platform specific authentication service"]
    EOS_LS_LoggedIn = 2,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EAttributeType {
    #[doc = " Boolean value (true/false)"]
    EOS_AT_BOOLEAN = 0,
    #[doc = " 64 bit integers"]
    EOS_AT_INT64 = 1,
    #[doc = " Double/floating point precision"]
    EOS_AT_DOUBLE = 2,
    #[doc = " UTF8 Strings"]
    EOS_AT_STRING = 3,
}
pub use self::EOS_EAttributeType as EOS_ESessionAttributeType;
pub use self::EOS_EAttributeType as EOS_ELobbyAttributeType;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EComparisonOp {
    #[doc = " Value must equal the one stored on the lobby/session"]
    EOS_CO_EQUAL = 0,
    #[doc = " Value must not equal the one stored on the lobby/session"]
    EOS_CO_NOTEQUAL = 1,
    #[doc = " Value must be strictly greater than the one stored on the lobby/session"]
    EOS_CO_GREATERTHAN = 2,
    #[doc = " Value must be greater than or equal to the one stored on the lobby/session"]
    EOS_CO_GREATERTHANOREQUAL = 3,
    #[doc = " Value must be strictly less than the one stored on the lobby/session"]
    EOS_CO_LESSTHAN = 4,
    #[doc = " Value must be less than or equal to the one stored on the lobby/session"]
    EOS_CO_LESSTHANOREQUAL = 5,
    #[doc = " Prefer values nearest the one specified ie. abs(SearchValue-SessionValue) closest to 0"]
    EOS_CO_DISTANCE = 6,
    #[doc = " Value stored on the lobby/session may be any from a specified list"]
    EOS_CO_ANYOF = 7,
    #[doc = " Value stored on the lobby/session may NOT be any from a specified list"]
    EOS_CO_NOTANYOF = 8,
    #[doc = " This one value is a part of a collection"]
    EOS_CO_ONEOF = 9,
    #[doc = " This one value is NOT part of a collection"]
    EOS_CO_NOTONEOF = 10,
    #[doc = " This value is a CASE SENSITIVE substring of an attribute stored on the lobby/session"]
    EOS_CO_CONTAINS = 11,
}
pub use self::EOS_EComparisonOp as EOS_EOnlineComparisonOp;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EExternalAccountType {
    #[doc = " External account is associated with Epic Games"]
    EOS_EAT_EPIC = 0,
    #[doc = " External account is associated with Steam"]
    EOS_EAT_STEAM = 1,
    #[doc = " External account is associated with PlayStation(TM)Network"]
    EOS_EAT_PSN = 2,
    #[doc = " External account is associated with Xbox Live"]
    EOS_EAT_XBL = 3,
    #[doc = " External account is associated with Discord"]
    EOS_EAT_DISCORD = 4,
    #[doc = " External account is associated with GOG"]
    EOS_EAT_GOG = 5,
    #[doc = " External account is associated with Nintendo\n\n With both EOS Connect and EOS UserInfo APIs, the associated account type is Nintendo Service Account ID.\n Local user authentication is possible using Nintendo Account ID, while the account type does not get exposed to the SDK in queries related to linked accounts information."]
    EOS_EAT_NINTENDO = 6,
    #[doc = " External account is associated with Uplay"]
    EOS_EAT_UPLAY = 7,
    #[doc = " External account is associated with an OpenID Provider"]
    EOS_EAT_OPENID = 8,
    #[doc = " External account is associated with Apple"]
    EOS_EAT_APPLE = 9,
    #[doc = " External account is associated with Google"]
    EOS_EAT_GOOGLE = 10,
    #[doc = " External account is associated with Oculus"]
    EOS_EAT_OCULUS = 11,
    #[doc = " External account is associated with itch.io"]
    EOS_EAT_ITCHIO = 12,
    #[doc = " External account is associated with Amazon"]
    EOS_EAT_AMAZON = 13,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EExternalCredentialType {
    #[doc = " Epic Account Services Token\n\n Using ID Token is preferred, retrieved with EOS_Auth_CopyIdToken that returns EOS_Auth_IdToken::JsonWebToken.\n Using Auth Token is supported for backwards compatibility, retrieved with EOS_Auth_CopyUserAuthToken that returns EOS_Auth_Token::AccessToken.\n\n Supported with EOS_Connect_Login.\n\n @see EOS_Auth_CopyIdToken\n @see EOS_Auth_CopyUserAuthToken"]
    EOS_ECT_EPIC = 0,
    #[doc = " Steam Encrypted App Ticket\n\n Generated using the ISteamUser::RequestEncryptedAppTicket API of Steamworks SDK.\n For ticket generation parameters, use pDataToInclude(NULL) and cbDataToInclude(0).\n\n The retrieved App Ticket byte buffer needs to be converted into a hex-encoded UTF-8 string (e.g. \"FA87097A..\") before passing it to the EOS_Connect_Login API.\n EOS_ByteArray_ToString can be used for this conversion.\n\n Supported with EOS_Connect_Login.\n Note that EOS_ECT_STEAM_APP_TICKET is deprecated for use with EOS_Auth_Login. Use EOS_ECT_STEAM_SESSION_TICKET instead.\n\n @see EOS_ECT_STEAM_SESSION_TICKET"]
    EOS_ECT_STEAM_APP_TICKET = 1,
    #[doc = " PlayStation(TM)Network ID Token\n\n Retrieved from the PlayStation(R) SDK. Please see first-party documentation for additional information.\n\n Supported with EOS_Auth_Login, EOS_Connect_Login."]
    EOS_ECT_PSN_ID_TOKEN = 2,
    #[doc = " Xbox Live XSTS Token\n\n Retrieved from the GDK and XDK. Please see first-party documentation for additional information.\n\n Supported with EOS_Auth_Login, EOS_Connect_Login."]
    EOS_ECT_XBL_XSTS_TOKEN = 3,
    #[doc = " Discord Access Token\n\n Retrieved using the ApplicationManager::GetOAuth2Token API of Discord SDK.\n\n Supported with EOS_Connect_Login."]
    EOS_ECT_DISCORD_ACCESS_TOKEN = 4,
    #[doc = " GOG Galaxy Encrypted App Ticket\n\n Generated using the IUser::RequestEncryptedAppTicket API of GOG Galaxy SDK.\n For ticket generation parameters, use data(NULL) and dataSize(0).\n\n The retrieved App Ticket byte buffer needs to be converted into a hex-encoded UTF-8 string (e.g. \"FA87097A..\") before passing it to the EOS_Connect_Login API.\n For C/C++ API integration, use the EOS_ByteArray_ToString API for the conversion.\n For C# integration, you can use <see cref=\"Helper.ToHexString\" /> for the conversion.\n\n Supported with EOS_Connect_Login."]
    EOS_ECT_GOG_SESSION_TICKET = 5,
    #[doc = " Nintendo Account ID Token\n\n Identifies a Nintendo user account and is acquired through web flow authentication where the local user logs in using their email address/sign-in ID and password.\n This is the common Nintendo account that users login with outside the Nintendo Switch device.\n\n Supported with EOS_Auth_Login, EOS_Connect_Login."]
    EOS_ECT_NINTENDO_ID_TOKEN = 6,
    #[doc = " Nintendo Service Account ID Token (NSA ID)\n\n The NSA ID identifies uniquely the local Nintendo Switch device. The authentication token is acquired locally without explicit user credentials.\n As such, it is the primary authentication method for seamless login on Nintendo Switch.\n\n The NSA ID is not exposed directly to the user and does not provide any means for login outside the local device.\n Because of this, Nintendo Switch users will need to link their Nintendo Account or another external user account\n to their Product User ID in order to share their game progression across other platforms. Otherwise, the user will\n not be able to login to their existing Product User ID on another platform due to missing login credentials to use.\n It is recommended that the game explicitly communicates this restriction to the user so that they will know to add\n the first linked external account on the Nintendo Switch device and then proceed with login on another platform.\n\n In addition to sharing cross-platform game progression, linking the Nintendo Account or another external account\n will allow preserving the game progression permanently. Otherwise, the game progression will be tied only to the\n local device. In case the user loses access to their local device, they will not be able to recover the game\n progression if it is only associated with this account type.\n\n Supported with EOS_Auth_Login, EOS_Connect_Login."]
    EOS_ECT_NINTENDO_NSA_ID_TOKEN = 7,
    #[doc = " Uplay Access Token"]
    EOS_ECT_UPLAY_ACCESS_TOKEN = 8,
    #[doc = " OpenID Provider Access Token\n\n Supported with EOS_Connect_Login."]
    EOS_ECT_OPENID_ACCESS_TOKEN = 9,
    #[doc = " Device ID access token that identifies the current locally logged in user profile on the local device.\n The local user profile here refers to the operating system user login, for example the user's Windows Account\n or on a mobile device the default active user profile.\n\n This credential type is used to automatically login the local user using the EOS Connect Device ID feature.\n\n The intended use of the Device ID feature is to allow automatically logging in the user on a mobile device\n and to allow playing the game without requiring the user to necessarily login using a real user account at all.\n This makes a seamless first-time experience possible and allows linking the local device with a real external\n user account at a later time, sharing the same EOS_ProductUserId that is being used with the Device ID feature.\n\n Supported with EOS_Connect_Login.\n\n @see EOS_Connect_CreateDeviceId"]
    EOS_ECT_DEVICEID_ACCESS_TOKEN = 10,
    #[doc = " Apple ID Token\n\n Supported with EOS_Connect_Login."]
    EOS_ECT_APPLE_ID_TOKEN = 11,
    #[doc = " Google ID Token\n\n Supported with EOS_Connect_Login."]
    EOS_ECT_GOOGLE_ID_TOKEN = 12,
    #[doc = " Oculus User ID and Nonce\n\n Call ovr_User_GetUserProof(), or Platform.User.GetUserProof() if you are using Unity, to retrieve the nonce.\n Then pass the local User ID and the Nonce as a \"{UserID}|{Nonce}\" formatted string for the EOS_Connect_Login Token parameter.\n\n Note that in order to successfully retrieve a valid non-zero id for the local user using ovr_User_GetUser(),\n your Oculus App needs to be configured in the Oculus Developer Dashboard to have the User ID feature enabled.\n\n Supported with EOS_Connect_Login."]
    EOS_ECT_OCULUS_USERID_NONCE = 13,
    #[doc = " itch.io JWT Access Token\n\n Use the itch.io app manifest to receive a JWT access token for the local user via the ITCHIO_API_KEY process environment variable.\n The itch.io access token is valid for 7 days after which the game needs to be restarted by the user as otherwise EOS Connect\n authentication session can no longer be refreshed.\n\n Supported with EOS_Connect_Login."]
    EOS_ECT_ITCHIO_JWT = 14,
    #[doc = " itch.io Key Access Token\n\n This access token type is retrieved through the OAuth 2.0 authentication flow for the itch.io application.\n\n Supported with EOS_Connect_Login."]
    EOS_ECT_ITCHIO_KEY = 15,
    #[doc = " Epic Games ID Token\n\n Acquired using EOS_Auth_CopyIdToken that returns EOS_Auth_IdToken::JsonWebToken.\n\n Supported with EOS_Connect_Login."]
    EOS_ECT_EPIC_ID_TOKEN = 16,
    #[doc = " Amazon Access Token\n\n Supported with EOS_Connect_Login."]
    EOS_ECT_AMAZON_ACCESS_TOKEN = 17,
    #[doc = " Steam Auth Session Ticket\n\n Generated using the ISteamUser::GetAuthTicketForWebApi API of Steamworks SDK.\n\n @attention\n The pchIdentity input parameter of GetAuthTicketForWebApi API must be set to a valid non-empty string value.\n The string value used by the game client must match identically to the backend-configured value in EOS Dev Portal.\n The recommended value to use is \"epiconlineservices\" in lowercase, matching the default value for new Steam identity provider credentials in EOS Dev Portal.\n This identifier is important for security reasons to prevent session hijacking. Applications must use a dedicated unique identity identifier for Session Tickets passed to the EOS SDK APIs.\n Session Tickets using the EOS-assigned identifier must not be used with anything else than the EOS SDK APIs. You must use a different identifier when generating Session Tickets to authenticate with other parties.\n\n @warning\n To update an already live game to use the new GetAuthTicketForWebApi API instead of the deprecated GetAuthSessionTicket API, follow these steps in this order to prevent breaking the live game for players:\n 1. Update your game client code to use the new ISteamUser::GetAuthTicketForWebApi API.\n 2. Publish the new game client update to end-users.\n 3. Update the existing Steam identity provider credentials entry in EOS Dev Portal to use the same identity string identifier as the game client.\n\n @example\n SteamUser()->GetAuthTicketForWebApi(\"epiconlineservices\");\n\n The retrieved Auth Session Ticket byte buffer needs to be converted into a hex-encoded UTF-8 string (e.g. \"FA87097A..\") before passing it to the EOS_Auth_Login or EOS_Connect_Login APIs.\n EOS_ByteArray_ToString can be used for this conversion.\n\n Supported with EOS_Auth_Login, EOS_Connect_Login.\n\n @version 1.15.1+"]
    EOS_ECT_STEAM_SESSION_TICKET = 18,
}
#[doc = " This type is used to distinguish between different supported integrated platforms.\n Integrated platforms which are common across multiple host platforms will be defined here."]
pub type EOS_IntegratedPlatformType = *const ::std::os::raw::c_char;
#[doc = " This type is used to distinguish between different online platforms."]
pub type EOS_OnlinePlatformType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_IntegratedPlatformOptionsContainerHandle {
    _unused: [u8; 0],
}
pub type EOS_HIntegratedPlatformOptionsContainer =
    *mut EOS_IntegratedPlatformOptionsContainerHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_IntegratedPlatformHandle {
    _unused: [u8; 0],
}
pub type EOS_HIntegratedPlatform = *mut EOS_IntegratedPlatformHandle;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EIntegratedPlatformManagementFlags {
    #[doc = " The integrated platform library should be disabled. This is equivalent to providing no flags."]
    EOS_IPMF_Disabled = 1,
    #[doc = " The integrated platform library is managed by the calling application. EOS SDK should only hook into an existing instance of the integrated platform library."]
    EOS_IPMF_LibraryManagedByApplication = 2,
    #[doc = " EOS SDK should fully manage the integrated platform library. It will do this by performing the load, initialize, tick and unload operations as necessary."]
    EOS_IPMF_LibraryManagedBySDK = 4,
    #[doc = " The EOS SDK should not mirror the EOS rich presence with the Integrated Platform.\n The default behavior is for EOS SDK to share local presence with the Integrated Platform."]
    EOS_IPMF_DisablePresenceMirroring = 8,
    #[doc = " EOS SDK should not perform any sessions management through the Integrated Platform.\n The default behavior is for EOS SDK to perform sessions management through the Integrated Platform.\n Sessions management includes:\n    - sharing the lobby and session presence enabled games with the Integrated Platform.\n    - handling Social Overlay join button events which cannot be handled by normal processing of Epic Services.\n    - handling Social Overlay invite button events which cannot be handled by normal processing of Epic Services.\n    - handling startup requests from the Integrated Platform to immediately join a game due to in invite while offline.\n\n @see EOS_Lobby_AddNotifySendLobbyNativeInviteRequested"]
    EOS_IPMF_DisableSDKManagedSessions = 16,
    #[doc = " Some features within the EOS SDK may wish to know a preference of Integrated Platform versus EOS.\n When determining an absolute platform preference those with this flag will be skipped.\n The IntegratedPlatforms list is provided via the EOS_Platform_Options during EOS_Platform_Create.\n\n The primary usage of the EOS_IPMF_PreferEOSIdentity and EOS_IPMF_PreferIntegratedIdentity flags is with game invites\n from the Social Overlay.\n\n For game invites from the Social Overlay the EOS SDK will follow these rules:\n     - If the only account ID we can determine for the target player is an EAS ID then the EOS system will be used.\n     - If the only account ID we can determine for the target player is an integrated platform ID then the integrated platform system will be used.\n     - If both are available then the EOS SDK will operate in 1 of 3 modes:\n         - no preference identified: use both the EOS and integrated platform systems.\n         - PreferEOS: Use EOS if the target is an EAS friend and is either online in EAS or not online for the integrated platform.\n         - PreferIntegrated: Use integrated platform if the target is an integrated platform friend and is either online in the integrated platform or not online for EAS.\n     - If the integrated platform fails to send then try EAS if was not already used."]
    EOS_IPMF_PreferEOSIdentity = 32,
    #[doc = " Some features within the EOS SDK may wish to know a preference of Integrated Platform versus EOS.\n For further explanation see EOS_IPMF_PreferEOSIdentity.\n\n @see EOS_IPMF_PreferEOSIdentity"]
    EOS_IPMF_PreferIntegratedIdentity = 64,
    #[doc = " By default the EOS SDK will attempt to detect the login/logout events of local users and update local states accordingly. Setting this flag will disable this functionality,\n relying on the application to process login/logout events and notify EOS SDK. It is not possible for the EOS SDK to do this on all platforms, making this flag not always\n optional.\n\n This flag must be set to use the manual platform user login/logout functions, even on platforms where it is not possible for the EOS SDK to detect login/logout events,\n making this a required flag for correct Integrated Platform behavior on those platforms."]
    EOS_IPMF_ApplicationManagedIdentityLogin = 128,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_IntegratedPlatform_Options {
    #[doc = " API Version: Set this to EOS_INTEGRATEDPLATFORM_OPTIONS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The type to be initialized."]
    pub Type: EOS_IntegratedPlatformType,
    #[doc = " Identifies how to initialize the IntegratedPlatform."]
    pub Flags: EOS_EIntegratedPlatformManagementFlags,
    #[doc = " Options specific to this integrated platform type.\n This parameter is either required or set to NULL based on the platform type.\n\n @see EOS_IntegratedPlatform_Steam_Options"]
    pub InitOptions: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_IntegratedPlatform_Options() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_IntegratedPlatform_Options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_IntegratedPlatform_Options>(),
        32usize,
        concat!("Size of: ", stringify!(_tagEOS_IntegratedPlatform_Options))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_IntegratedPlatform_Options>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_IntegratedPlatform_Options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_Options),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_Options),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_Options),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InitOptions) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_Options),
            "::",
            stringify!(InitOptions)
        )
    );
}
pub type EOS_IntegratedPlatform_Options = _tagEOS_IntegratedPlatform_Options;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_IntegratedPlatform_Steam_Options {
    #[doc = " API Version: Set this to EOS_INTEGRATEDPLATFORM_STEAM_OPTIONS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Usage of this parameter is dependent on the specified EOS_EIntegratedPlatformManagementFlags.\n\n Optional with EOS_IPMF_LibraryManagedByApplication.\n Set to override the loaded library basename, or use NULL to assume the default basename by platform:\n\n - Linux: libsteam_api.so,\n - macOS: libsteam_api.dylib,\n - Windows 32-bit: steam_api.dll,\n - Windows 64-bit: steam_api64.dll.\n\n Required with EOS_IPMF_LibraryManagedBySDK.\n Set to a fully qualified file path to the Steamworks SDK runtime library on disk."]
    pub OverrideLibraryPath: *const ::std::os::raw::c_char,
    #[doc = " Used to specify the major version of the Steam SDK your game is compiled against, e.g.:\n\n Options.SteamMajorVersion = 1;"]
    pub SteamMajorVersion: u32,
    #[doc = " Used to specify the minor version of the Steam SDK your game is compiled against, e.g.:\n\n Options.SteamMinorVersion = 57;"]
    pub SteamMinorVersion: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_IntegratedPlatform_Steam_Options() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_IntegratedPlatform_Steam_Options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_IntegratedPlatform_Steam_Options>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_IntegratedPlatform_Steam_Options)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_IntegratedPlatform_Steam_Options>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_IntegratedPlatform_Steam_Options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_Steam_Options),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OverrideLibraryPath) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_Steam_Options),
            "::",
            stringify!(OverrideLibraryPath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SteamMajorVersion) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_Steam_Options),
            "::",
            stringify!(SteamMajorVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SteamMinorVersion) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_Steam_Options),
            "::",
            stringify!(SteamMinorVersion)
        )
    );
}
pub type EOS_IntegratedPlatform_Steam_Options = _tagEOS_IntegratedPlatform_Steam_Options;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_IntegratedPlatform_CreateIntegratedPlatformOptionsContainerOptions {
    #[doc = " API Version: Set this to EOS_INTEGRATEDPLATFORM_CREATEINTEGRATEDPLATFORMOPTIONSCONTAINER_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_IntegratedPlatform_CreateIntegratedPlatformOptionsContainerOptions()
{
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_IntegratedPlatform_CreateIntegratedPlatformOptionsContainerOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            _tagEOS_IntegratedPlatform_CreateIntegratedPlatformOptionsContainerOptions,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_IntegratedPlatform_CreateIntegratedPlatformOptionsContainerOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _tagEOS_IntegratedPlatform_CreateIntegratedPlatformOptionsContainerOptions,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_IntegratedPlatform_CreateIntegratedPlatformOptionsContainerOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_CreateIntegratedPlatformOptionsContainerOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_IntegratedPlatform_CreateIntegratedPlatformOptionsContainerOptions =
    _tagEOS_IntegratedPlatform_CreateIntegratedPlatformOptionsContainerOptions;
extern "C" {
    #[doc = " Creates an integrated platform options container handle. This handle can used to add multiple options to your container which will then be applied with EOS_Platform_Create.\n The resulting handle must be released by calling EOS_IntegratedPlatformOptionsContainer_Release once it has been passed to EOS_Platform_Create.\n\n @param Options structure containing operation input parameters.\n @param OutIntegratedPlatformOptionsContainerHandle Pointer to an integrated platform options container handle to be set if successful.\n @return Success if we successfully created the integrated platform options container handle pointed at in OutIntegratedPlatformOptionsContainerHandle, or an error result if the input data was invalid.\n\n @see EOS_IntegratedPlatformOptionsContainer_Release\n @see EOS_Platform_Create\n @see EOS_IntegratedPlatformOptionsContainer_Add"]
    pub fn EOS_IntegratedPlatform_CreateIntegratedPlatformOptionsContainer(
        Options: *const EOS_IntegratedPlatform_CreateIntegratedPlatformOptionsContainerOptions,
        OutIntegratedPlatformOptionsContainerHandle: *mut EOS_HIntegratedPlatformOptionsContainer,
    ) -> EOS_EResult;
}
extern "C" {
    #[doc = " Release the memory associated with an EOS_HIntegratedPlatformOptionsContainer handle. This must be called on Handles retrieved from EOS_IntegratedPlatform_CreateIntegratedPlatformOptionsContainer.\n This can be safely called on a NULL integrated platform options container handle.\n\n @param IntegratedPlatformOptionsContainerHandle The integrated platform options container handle to release.\n\n @see EOS_IntegratedPlatform_CreateIntegratedPlatformOptionsContainer"]
    pub fn EOS_IntegratedPlatformOptionsContainer_Release(
        IntegratedPlatformOptionsContainerHandle: EOS_HIntegratedPlatformOptionsContainer,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_IntegratedPlatformOptionsContainer_AddOptions {
    #[doc = " API Version: Set this to EOS_INTEGRATEDPLATFORMOPTIONSCONTAINER_ADD_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The integrated platform options to add."]
    pub Options: *const EOS_IntegratedPlatform_Options,
}
#[test]
fn bindgen_test_layout__tagEOS_IntegratedPlatformOptionsContainer_AddOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_IntegratedPlatformOptionsContainer_AddOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_IntegratedPlatformOptionsContainer_AddOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_IntegratedPlatformOptionsContainer_AddOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_IntegratedPlatformOptionsContainer_AddOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_IntegratedPlatformOptionsContainer_AddOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatformOptionsContainer_AddOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Options) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatformOptionsContainer_AddOptions),
            "::",
            stringify!(Options)
        )
    );
}
pub type EOS_IntegratedPlatformOptionsContainer_AddOptions =
    _tagEOS_IntegratedPlatformOptionsContainer_AddOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_IntegratedPlatform_SetUserLoginStatusOptions {
    #[doc = " API Version: Set this to EOS_INTEGRATEDPLATFORM_SETUSERLOGINSTATUS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The integrated platform this user belongs to."]
    pub PlatformType: EOS_IntegratedPlatformType,
    #[doc = " String version of the integrated platform-dependent user id."]
    pub LocalPlatformUserId: *const ::std::os::raw::c_char,
    #[doc = " The login status of the provided user"]
    pub CurrentLoginStatus: EOS_ELoginStatus,
}
#[test]
fn bindgen_test_layout__tagEOS_IntegratedPlatform_SetUserLoginStatusOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_IntegratedPlatform_SetUserLoginStatusOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_IntegratedPlatform_SetUserLoginStatusOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_IntegratedPlatform_SetUserLoginStatusOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_IntegratedPlatform_SetUserLoginStatusOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_IntegratedPlatform_SetUserLoginStatusOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_SetUserLoginStatusOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PlatformType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_SetUserLoginStatusOptions),
            "::",
            stringify!(PlatformType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalPlatformUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_SetUserLoginStatusOptions),
            "::",
            stringify!(LocalPlatformUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurrentLoginStatus) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_SetUserLoginStatusOptions),
            "::",
            stringify!(CurrentLoginStatus)
        )
    );
}
pub type EOS_IntegratedPlatform_SetUserLoginStatusOptions =
    _tagEOS_IntegratedPlatform_SetUserLoginStatusOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_IntegratedPlatform_AddNotifyUserLoginStatusChangedOptions {
    #[doc = " API Version: Set this to EOS_INTEGRATEDPLATFORM_ADDNOTIFYUSERLOGINSTATUSCHANGED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_IntegratedPlatform_AddNotifyUserLoginStatusChangedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_IntegratedPlatform_AddNotifyUserLoginStatusChangedOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_IntegratedPlatform_AddNotifyUserLoginStatusChangedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_IntegratedPlatform_AddNotifyUserLoginStatusChangedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_IntegratedPlatform_AddNotifyUserLoginStatusChangedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_IntegratedPlatform_AddNotifyUserLoginStatusChangedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_AddNotifyUserLoginStatusChangedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_IntegratedPlatform_AddNotifyUserLoginStatusChangedOptions =
    _tagEOS_IntegratedPlatform_AddNotifyUserLoginStatusChangedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_IntegratedPlatform_UserLoginStatusChangedCallbackInfo {
    #[doc = " Context that was passed into EOS_IntegratedPlatform_AddNotifyUserLoginStatusChanged"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The integrated platform of the local platform user."]
    pub PlatformType: EOS_IntegratedPlatformType,
    #[doc = " String version of platform's user id."]
    pub LocalPlatformUserId: *const ::std::os::raw::c_char,
    #[doc = " The Epic Games Account ID associated with this Integrated Platform's User (if there is one)"]
    pub AccountId: EOS_EpicAccountId,
    #[doc = " The EOS Product User ID associated with this Integrated Platform's User (if there is one)"]
    pub ProductUserId: EOS_ProductUserId,
    #[doc = " The login status prior to this change."]
    pub PreviousLoginStatus: EOS_ELoginStatus,
    #[doc = " The login status at the time of this notification."]
    pub CurrentLoginStatus: EOS_ELoginStatus,
}
#[test]
fn bindgen_test_layout__tagEOS_IntegratedPlatform_UserLoginStatusChangedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_IntegratedPlatform_UserLoginStatusChangedCallbackInfo,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_IntegratedPlatform_UserLoginStatusChangedCallbackInfo>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_IntegratedPlatform_UserLoginStatusChangedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_IntegratedPlatform_UserLoginStatusChangedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_IntegratedPlatform_UserLoginStatusChangedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_UserLoginStatusChangedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PlatformType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_UserLoginStatusChangedCallbackInfo),
            "::",
            stringify!(PlatformType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalPlatformUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_UserLoginStatusChangedCallbackInfo),
            "::",
            stringify!(LocalPlatformUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccountId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_UserLoginStatusChangedCallbackInfo),
            "::",
            stringify!(AccountId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProductUserId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_UserLoginStatusChangedCallbackInfo),
            "::",
            stringify!(ProductUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PreviousLoginStatus) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_UserLoginStatusChangedCallbackInfo),
            "::",
            stringify!(PreviousLoginStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurrentLoginStatus) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_UserLoginStatusChangedCallbackInfo),
            "::",
            stringify!(CurrentLoginStatus)
        )
    );
}
pub type EOS_IntegratedPlatform_UserLoginStatusChangedCallbackInfo =
    _tagEOS_IntegratedPlatform_UserLoginStatusChangedCallbackInfo;
pub type EOS_IntegratedPlatform_OnUserLoginStatusChangedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_IntegratedPlatform_UserLoginStatusChangedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_IntegratedPlatform_SetUserPreLogoutCallbackOptions {
    #[doc = " API Version: Set this to EOS_INTEGRATEDPLATFORM_SETUSERPRELOGOUTCALLBACK_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_IntegratedPlatform_SetUserPreLogoutCallbackOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_IntegratedPlatform_SetUserPreLogoutCallbackOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_IntegratedPlatform_SetUserPreLogoutCallbackOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_IntegratedPlatform_SetUserPreLogoutCallbackOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_IntegratedPlatform_SetUserPreLogoutCallbackOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_IntegratedPlatform_SetUserPreLogoutCallbackOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_SetUserPreLogoutCallbackOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_IntegratedPlatform_SetUserPreLogoutCallbackOptions =
    _tagEOS_IntegratedPlatform_SetUserPreLogoutCallbackOptions;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EIntegratedPlatformPreLogoutAction {
    #[doc = " The application accepts the user being logged-out. all cached data for the user will be cleared immediately and any pending\n actions canceled."]
    EOS_IPLA_ProcessLogoutImmediately = 0,
    #[doc = " Instead of the user being logged-out, the SDK will wait for a call to EOS_IntegratedPlatform_FinalizeDeferredUserLogout with the\n expected login state of the user. If the expected state matches the current state, the user will continue to be logged-in or they\n will be logged-out, depending on the value of the expected state. This lets the application choose to ask the user if they meant\n to logout if it wishes, possibly preventing losing any unsaved changes, such as game progress, leaving a multiplayer match, or\n similar.\n\n @see EOS_IntegratedPlatform_FinalizeDeferredUserLogout"]
    EOS_IPLA_DeferLogout = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_IntegratedPlatform_UserPreLogoutCallbackInfo {
    #[doc = " Context that was passed into EOS_IntegratedPlatform_SetUserPreLogoutCallback"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The integrated platform the local user logged-out of."]
    pub PlatformType: EOS_IntegratedPlatformType,
    #[doc = " String version of platform-dependent user id."]
    pub LocalPlatformUserId: *const ::std::os::raw::c_char,
    #[doc = " The Epic Games Account ID associated with this Integrated Platform's User (if there is one)"]
    pub AccountId: EOS_EpicAccountId,
    #[doc = " The EOS Product User ID associated with this Integrated Platform's User (if there is one)"]
    pub ProductUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_IntegratedPlatform_UserPreLogoutCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_IntegratedPlatform_UserPreLogoutCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_IntegratedPlatform_UserPreLogoutCallbackInfo>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_IntegratedPlatform_UserPreLogoutCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_IntegratedPlatform_UserPreLogoutCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_IntegratedPlatform_UserPreLogoutCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_UserPreLogoutCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PlatformType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_UserPreLogoutCallbackInfo),
            "::",
            stringify!(PlatformType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalPlatformUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_UserPreLogoutCallbackInfo),
            "::",
            stringify!(LocalPlatformUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccountId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_UserPreLogoutCallbackInfo),
            "::",
            stringify!(AccountId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProductUserId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_UserPreLogoutCallbackInfo),
            "::",
            stringify!(ProductUserId)
        )
    );
}
pub type EOS_IntegratedPlatform_UserPreLogoutCallbackInfo =
    _tagEOS_IntegratedPlatform_UserPreLogoutCallbackInfo;
pub type EOS_IntegratedPlatform_OnUserPreLogoutCallback = ::std::option::Option<
    unsafe extern "C" fn(
        Data: *const EOS_IntegratedPlatform_UserPreLogoutCallbackInfo,
    ) -> EOS_EIntegratedPlatformPreLogoutAction,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_IntegratedPlatform_ClearUserPreLogoutCallbackOptions {
    #[doc = " API Version: Set this to EOS_INTEGRATEDPLATFORM_CLEARUSERPRELOGOUTCALLBACK_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_IntegratedPlatform_ClearUserPreLogoutCallbackOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_IntegratedPlatform_ClearUserPreLogoutCallbackOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_IntegratedPlatform_ClearUserPreLogoutCallbackOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_IntegratedPlatform_ClearUserPreLogoutCallbackOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_IntegratedPlatform_ClearUserPreLogoutCallbackOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_IntegratedPlatform_ClearUserPreLogoutCallbackOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_ClearUserPreLogoutCallbackOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_IntegratedPlatform_ClearUserPreLogoutCallbackOptions =
    _tagEOS_IntegratedPlatform_ClearUserPreLogoutCallbackOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_IntegratedPlatform_FinalizeDeferredUserLogoutOptions {
    #[doc = " API Version: Set this to EOS_INTEGRATEDPLATFORM_FINALIZEDEFERREDUSERLOGOUT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The integrated platform this user belongs to."]
    pub PlatformType: EOS_IntegratedPlatformType,
    #[doc = " String version of the integrated platform-dependent user id."]
    pub LocalPlatformUserId: *const ::std::os::raw::c_char,
    #[doc = " The logged-in state the user is expected to be (EOS_LS_LoggedIn or EOS_LS_NotLoggedIn). If the provided\n state does not match internal EOS state, this function will return in failure. If the state is incorrect,\n the application should wait and attempt to call the function again next tick, after both updating its own\n state from the system and calling EOS_Platform_Tick, allowing the SDK to update its state from the system\n as well."]
    pub ExpectedLoginStatus: EOS_ELoginStatus,
}
#[test]
fn bindgen_test_layout__tagEOS_IntegratedPlatform_FinalizeDeferredUserLogoutOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_IntegratedPlatform_FinalizeDeferredUserLogoutOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_IntegratedPlatform_FinalizeDeferredUserLogoutOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_IntegratedPlatform_FinalizeDeferredUserLogoutOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_IntegratedPlatform_FinalizeDeferredUserLogoutOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_IntegratedPlatform_FinalizeDeferredUserLogoutOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_FinalizeDeferredUserLogoutOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PlatformType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_FinalizeDeferredUserLogoutOptions),
            "::",
            stringify!(PlatformType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalPlatformUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_FinalizeDeferredUserLogoutOptions),
            "::",
            stringify!(LocalPlatformUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExpectedLoginStatus) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_IntegratedPlatform_FinalizeDeferredUserLogoutOptions),
            "::",
            stringify!(ExpectedLoginStatus)
        )
    );
}
pub type EOS_IntegratedPlatform_FinalizeDeferredUserLogoutOptions =
    _tagEOS_IntegratedPlatform_FinalizeDeferredUserLogoutOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_PlatformHandle {
    _unused: [u8; 0],
}
pub type EOS_HPlatform = *mut EOS_PlatformHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Platform_ClientCredentials {
    #[doc = " Client ID of the service permissions entry. Set to NULL if no service permissions are used. Max length is EOS_PLATFORM_CLIENTCREDENTIALS_CLIENTID_MAX_LENGTH."]
    pub ClientId: *const ::std::os::raw::c_char,
    #[doc = " Client secret for accessing the set of permissions. Set to NULL if no service permissions are used. Max length is EOS_PLATFORM_CLIENTCREDENTIALS_CLIENTSECRET_MAX_LENGTH."]
    pub ClientSecret: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Platform_ClientCredentials() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Platform_ClientCredentials> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Platform_ClientCredentials>(),
        16usize,
        concat!("Size of: ", stringify!(_tagEOS_Platform_ClientCredentials))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Platform_ClientCredentials>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Platform_ClientCredentials)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Platform_ClientCredentials),
            "::",
            stringify!(ClientId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientSecret) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Platform_ClientCredentials),
            "::",
            stringify!(ClientSecret)
        )
    );
}
pub type EOS_Platform_ClientCredentials = _tagEOS_Platform_ClientCredentials;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_ERTCBackgroundMode {
    #[doc = " Upon entering a background application status, all logged in users leave any RTC rooms. All subsequent attemps to join any RTC rooms will be rejected.\n Upon returning to a foreground application status, all subsequent attemps to join any RTC rooms will be allowed."]
    EOS_RTCBM_LeaveRooms = 0,
    #[doc = " Application status has no effect on RTC rooms. Audio is captured from input devices and is played to output devices.\n Games should obtain consent from users and otherwise make users aware this is occurring."]
    EOS_RTCBM_KeepRoomsAlive = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Platform_RTCOptions {
    #[doc = " API Version: Set this to EOS_PLATFORM_RTCOPTIONS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " This field is for platform specific initialization if any.\n\n If provided then the structure will be located in <System>/eos_<System>.h.\n The structure will be named EOS_<System>_RTCOptions."]
    pub PlatformSpecificOptions: *mut ::std::os::raw::c_void,
    #[doc = " Configures RTC behavior upon entering to any background application statuses"]
    pub BackgroundMode: EOS_ERTCBackgroundMode,
}
#[test]
fn bindgen_test_layout__tagEOS_Platform_RTCOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Platform_RTCOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Platform_RTCOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Platform_RTCOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Platform_RTCOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Platform_RTCOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Platform_RTCOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PlatformSpecificOptions) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Platform_RTCOptions),
            "::",
            stringify!(PlatformSpecificOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BackgroundMode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Platform_RTCOptions),
            "::",
            stringify!(BackgroundMode)
        )
    );
}
pub type EOS_Platform_RTCOptions = _tagEOS_Platform_RTCOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Platform_Options {
    #[doc = " API Version: Set this to EOS_PLATFORM_OPTIONS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " A reserved field that should always be nulled."]
    pub Reserved: *mut ::std::os::raw::c_void,
    #[doc = " The product ID for the running application, found on the dev portal. Max length is EOS_PLATFORM_OPTIONS_PRODUCTID_MAX_LENGTH."]
    pub ProductId: *const ::std::os::raw::c_char,
    #[doc = " The sandbox ID for the running application, found on the dev portal. Max length is EOS_PLATFORM_OPTIONS_SANDBOXID_MAX_LENGTH."]
    pub SandboxId: *const ::std::os::raw::c_char,
    #[doc = " Set of service permissions associated with the running application"]
    pub ClientCredentials: EOS_Platform_ClientCredentials,
    #[doc = " Set this to EOS_FALSE if the application is running as a client with a local user, otherwise set to EOS_TRUE (e.g. for a dedicated game server)"]
    pub bIsServer: EOS_Bool,
    #[doc = " Used by Player Data Storage and Title Storage. Must be null initialized if unused. 256-bit Encryption Key for file encryption in hexadecimal format; EOS_PLATFORM_OPTIONS_ENCRYPTIONKEY_LENGTH hex chars."]
    pub EncryptionKey: *const ::std::os::raw::c_char,
    #[doc = " The override country code to use for the logged in user. (EOS_COUNTRYCODE_MAX_LENGTH)"]
    pub OverrideCountryCode: *const ::std::os::raw::c_char,
    #[doc = " The override locale code to use for the logged in user. This follows ISO 639. (EOS_LOCALECODE_MAX_LENGTH)"]
    pub OverrideLocaleCode: *const ::std::os::raw::c_char,
    #[doc = " The deployment ID for the running application, found on the dev portal. Max length is EOS_PLATFORM_OPTIONS_DEPLOYMENTID_MAX_LENGTH."]
    pub DeploymentId: *const ::std::os::raw::c_char,
    #[doc = " Platform creation flags, e.g. EOS_PF_LOADING_IN_EDITOR. This is a bitwise-or union of the defined flags."]
    pub Flags: u64,
    #[doc = " Used by Player Data Storage and Title Storage. Must be null initialized if unused. Cache directory path. Absolute path to the folder that is going to be used for caching temporary data. The path is created if it's missing."]
    pub CacheDirectory: *const ::std::os::raw::c_char,
    #[doc = " A budget, measured in milliseconds, for EOS_Platform_Tick to do its work. When the budget is met or exceeded (or if no work is available), EOS_Platform_Tick will return.\n This allows your game to amortize the cost of SDK work across multiple frames in the event that a lot of work is queued for processing.\n Zero is interpreted as \"perform all available work\"."]
    pub TickBudgetInMilliseconds: u32,
    #[doc = " RTC options. Setting to NULL will disable RTC features (e.g. voice)"]
    pub RTCOptions: *const EOS_Platform_RTCOptions,
    #[doc = " A handle that contains all the options for setting up integrated platforms.\n When set to NULL, the EOS Integrated Platform behavior for the host platform will be disabled."]
    pub IntegratedPlatformOptionsContainerHandle: EOS_HIntegratedPlatformOptionsContainer,
    #[doc = " Pointer to EOS_<Platform>_SystemSpecificOptions. This structure will be located in <Platform>/eos_<Platform>.h"]
    pub SystemSpecificOptions: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_Platform_Options() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Platform_Options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Platform_Options>(),
        136usize,
        concat!("Size of: ", stringify!(_tagEOS_Platform_Options))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Platform_Options>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Platform_Options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Platform_Options),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Platform_Options),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProductId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Platform_Options),
            "::",
            stringify!(ProductId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SandboxId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Platform_Options),
            "::",
            stringify!(SandboxId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientCredentials) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Platform_Options),
            "::",
            stringify!(ClientCredentials)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsServer) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Platform_Options),
            "::",
            stringify!(bIsServer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EncryptionKey) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Platform_Options),
            "::",
            stringify!(EncryptionKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OverrideCountryCode) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Platform_Options),
            "::",
            stringify!(OverrideCountryCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OverrideLocaleCode) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Platform_Options),
            "::",
            stringify!(OverrideLocaleCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DeploymentId) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Platform_Options),
            "::",
            stringify!(DeploymentId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Platform_Options),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CacheDirectory) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Platform_Options),
            "::",
            stringify!(CacheDirectory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TickBudgetInMilliseconds) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Platform_Options),
            "::",
            stringify!(TickBudgetInMilliseconds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RTCOptions) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Platform_Options),
            "::",
            stringify!(RTCOptions)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).IntegratedPlatformOptionsContainerHandle) as usize
                - ptr as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Platform_Options),
            "::",
            stringify!(IntegratedPlatformOptionsContainerHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SystemSpecificOptions) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Platform_Options),
            "::",
            stringify!(SystemSpecificOptions)
        )
    );
}
pub type EOS_Platform_Options = _tagEOS_Platform_Options;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EApplicationStatus {
    #[doc = " Xbox only.\n\n Notifies the SDK that the application has entered constrained mode.\n While in constrained mode, the application has reduced access to reserved system resources."]
    EOS_AS_BackgroundConstrained = 0,
    #[doc = " Xbox only.\n\n Notifies the SDK that the application has returned from constrained mode,\n and is back to running in a regular state with full access to system resources.\n\n The SDK will handle this state change and automatically transition its active state to EOS_AS_Foreground.\n As result, after the application has set the EOS_AS_BackgroundUnconstrained state,\n calling EOS_Platform_GetApplicationStatus will return EOS_AS_Foreground as the persisted active state."]
    EOS_AS_BackgroundUnconstrained = 1,
    #[doc = " Notifies the SDK that the application has been put into suspended state by the platform system."]
    EOS_AS_BackgroundSuspended = 2,
    #[doc = " Notifies the SDK that the application has been resumed from suspended state.\n\n This is the default active state on all platforms."]
    EOS_AS_Foreground = 3,
}
extern "C" {
    #[doc = " Gets the string representation of an EOS_EApplicationStatus value.\n\n Example: EOS_EApplicationStatus_ToString(EOS_EApplicationStatus::EOS_AS_Foreground) returns \"EOS_AS_Foreground\".\n\n @param ApplicationStatus EOS_EApplicationStatus value to get as string.\n\n @return Pointer to a static string representing the input enum value.\n         The returned string is guaranteed to be non-null, and must not be freed by the application."]
    pub fn EOS_EApplicationStatus_ToString(
        ApplicationStatus: EOS_EApplicationStatus,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_ENetworkStatus {
    #[doc = " Networking unavailable."]
    EOS_NS_Disabled = 0,
    #[doc = " Not connected to the internet. Only local area networking (LAN) may be available."]
    EOS_NS_Offline = 1,
    #[doc = " Connected to the internet."]
    EOS_NS_Online = 2,
}
extern "C" {
    #[doc = " Gets the string representation of an EOS_ENetworkStatus value.\n\n Example: EOS_ENetworkStatus_ToString(EOS_ENetworkStatus::EOS_NS_Online) returns \"EOS_NS_Online\".\n\n @param NetworkStatus EOS_ENetworkStatus value to get as string.\n\n @return Pointer to a static string representing the input enum value.\n         The returned string is guaranteed to be non-null, and must not be freed by the application."]
    pub fn EOS_ENetworkStatus_ToString(
        NetworkStatus: EOS_ENetworkStatus,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EDesktopCrossplayStatus {
    #[doc = " Desktop crossplay is ready to use."]
    EOS_DCS_OK = 0,
    #[doc = " The application was not launched through the Bootstrapper."]
    EOS_DCS_ApplicationNotBootstrapped = 1,
    #[doc = " The redistributable service is not installed."]
    EOS_DCS_ServiceNotInstalled = 2,
    #[doc = " The service failed to start."]
    EOS_DCS_ServiceStartFailed = 3,
    #[doc = " The service was started successfully, but is no longer running in the background, for an unknown reason."]
    EOS_DCS_ServiceNotRunning = 4,
    #[doc = " The application has explicitly disabled the overlay through SDK initialization flags."]
    EOS_DCS_OverlayDisabled = 5,
    #[doc = " The overlay is not installed.\n\n As the overlay is automatically installed and kept up-to-date by the redistributable service,\n this indicates that the user may have separately manually removed the installed overlay files."]
    EOS_DCS_OverlayNotInstalled = 6,
    #[doc = " The overlay was not loaded due to failing trust check on the digital signature of the file on disk.\n\n This error typically indicates one of the following root causes:\n - The Operating System's local certificate store is out of date.\n - The local system clock has skewed and is in the wrong time.\n - The file has been tampered with.\n - The file trust check timed out, either due to an issue with the local system or network connectivity.\n\n The first troubleshooting steps should be to check for any available Operating System updates,\n for example using the Windows Update, as well as verifying that the system time is correctly set."]
    EOS_DCS_OverlayTrustCheckFailed = 7,
    #[doc = " The overlay failed to load."]
    EOS_DCS_OverlayLoadFailed = 8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Platform_GetDesktopCrossplayStatusOptions {
    #[doc = " API Version: Set this to EOS_PLATFORM_GETDESKTOPCROSSPLAYSTATUS_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Platform_GetDesktopCrossplayStatusOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Platform_GetDesktopCrossplayStatusOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Platform_GetDesktopCrossplayStatusOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Platform_GetDesktopCrossplayStatusOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Platform_GetDesktopCrossplayStatusOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Platform_GetDesktopCrossplayStatusOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Platform_GetDesktopCrossplayStatusOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Platform_GetDesktopCrossplayStatusOptions =
    _tagEOS_Platform_GetDesktopCrossplayStatusOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Platform_DesktopCrossplayStatusInfo {
    #[doc = " Status for the availability of desktop crossplay functionality.\n\n It is recommended to include this value in application logs, and as part of\n any player-facing error screens to help troubleshooting possible issues."]
    pub Status: EOS_EDesktopCrossplayStatus,
    #[doc = " This field is set when the Status is EOS_DCS_ServiceStartFailed.\n\n Possible values for this field are not documented. However, it is recommended\n to be also included in application logs, and as part of any player-facing\n error screens."]
    pub ServiceInitResult: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Platform_DesktopCrossplayStatusInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Platform_DesktopCrossplayStatusInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Platform_DesktopCrossplayStatusInfo>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Platform_DesktopCrossplayStatusInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Platform_DesktopCrossplayStatusInfo>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Platform_DesktopCrossplayStatusInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Platform_DesktopCrossplayStatusInfo),
            "::",
            stringify!(Status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ServiceInitResult) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Platform_DesktopCrossplayStatusInfo),
            "::",
            stringify!(ServiceInitResult)
        )
    );
}
pub type EOS_Platform_DesktopCrossplayStatusInfo = _tagEOS_Platform_DesktopCrossplayStatusInfo;
#[doc = " Function prototype type definition for functions that allocate memory.\n\n Functions passed to EOS_Initialize to serve as memory allocators should return a pointer to the allocated memory.\n\n The returned pointer should have at least SizeInBytes available capacity and the memory address should be a multiple of Alignment.\n The SDK will always call the provided function with an Alignment that is a power of 2.\n Allocation failures should return a null pointer."]
pub type EOS_AllocateMemoryFunc = ::std::option::Option<
    unsafe extern "C" fn(SizeInBytes: usize, Alignment: usize) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Function prototype type definition for functions that reallocate memory.\n\n Functions passed to EOS_Initialize to serve as memory reallocators should return a pointer to the reallocated memory.\n The returned pointer should have at least SizeInBytes available capacity and the memory address should be a multiple of alignment.\n The SDK will always call the provided function with an Alignment that is a power of 2.\n Reallocation failures should return a null pointer."]
pub type EOS_ReallocateMemoryFunc = ::std::option::Option<
    unsafe extern "C" fn(
        Pointer: *mut ::std::os::raw::c_void,
        SizeInBytes: usize,
        Alignment: usize,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Function prototype type definition for functions that release memory.\n\n When the SDK is done with memory that has been allocated by a custom allocator passed to EOS_Initialize, it will call the corresponding memory release function."]
pub type EOS_ReleaseMemoryFunc =
    ::std::option::Option<unsafe extern "C" fn(Pointer: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Initialize_ThreadAffinity {
    #[doc = " API Version: Set this to EOS_INITIALIZE_THREADAFFINITY_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Any thread related to network management that is not IO."]
    pub NetworkWork: u64,
    #[doc = " Any thread that will interact with a storage device."]
    pub StorageIo: u64,
    #[doc = " Any thread that will generate web socket IO."]
    pub WebSocketIo: u64,
    #[doc = " Any thread that will generate IO related to P2P traffic and management."]
    pub P2PIo: u64,
    #[doc = " Any thread that will generate http request IO."]
    pub HttpRequestIo: u64,
    #[doc = " Any thread that will generate IO related to RTC traffic and management."]
    pub RTCIo: u64,
}
#[test]
fn bindgen_test_layout__tagEOS_Initialize_ThreadAffinity() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Initialize_ThreadAffinity> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Initialize_ThreadAffinity>(),
        56usize,
        concat!("Size of: ", stringify!(_tagEOS_Initialize_ThreadAffinity))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Initialize_ThreadAffinity>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Initialize_ThreadAffinity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Initialize_ThreadAffinity),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NetworkWork) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Initialize_ThreadAffinity),
            "::",
            stringify!(NetworkWork)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StorageIo) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Initialize_ThreadAffinity),
            "::",
            stringify!(StorageIo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WebSocketIo) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Initialize_ThreadAffinity),
            "::",
            stringify!(WebSocketIo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).P2PIo) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Initialize_ThreadAffinity),
            "::",
            stringify!(P2PIo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HttpRequestIo) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Initialize_ThreadAffinity),
            "::",
            stringify!(HttpRequestIo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RTCIo) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Initialize_ThreadAffinity),
            "::",
            stringify!(RTCIo)
        )
    );
}
pub type EOS_Initialize_ThreadAffinity = _tagEOS_Initialize_ThreadAffinity;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_InitializeOptions {
    #[doc = " API Version: Set this to EOS_INITIALIZE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " A custom memory allocator, if desired."]
    pub AllocateMemoryFunction: EOS_AllocateMemoryFunc,
    #[doc = " A corresponding memory reallocator. If the AllocateMemoryFunction is nulled, then this field must also be nulled."]
    pub ReallocateMemoryFunction: EOS_ReallocateMemoryFunc,
    #[doc = " A corresponding memory releaser. If the AllocateMemoryFunction is nulled, then this field must also be nulled."]
    pub ReleaseMemoryFunction: EOS_ReleaseMemoryFunc,
    #[doc = " The name of the product using the Epic Online Services SDK.\n\n The name string is required to be non-empty and at maximum of EOS_INITIALIZEOPTIONS_PRODUCTNAME_MAX_LENGTH bytes long.\n The string buffer can consist of the following characters:\n A-Z, a-z, 0-9, dot, underscore, space, exclamation mark, question mark, and sign, hyphen, parenthesis, plus, minus, colon."]
    pub ProductName: *const ::std::os::raw::c_char,
    #[doc = " Product version of the running application.\n\n The version string is required to be non-empty and at maximum of EOS_INITIALIZEOPTIONS_PRODUCTVERSION_MAX_LENGTH bytes long.\n The string buffer can consist of the following characters:\n A-Z, a-z, 0-9, dot, underscore, space, exclamation mark, question mark, and sign, hyphen, parenthesis, plus, minus, colon."]
    pub ProductVersion: *const ::std::os::raw::c_char,
    #[doc = " A reserved field that should always be nulled."]
    pub Reserved: *mut ::std::os::raw::c_void,
    #[doc = " This field is for system specific initialization if any.\n\n If provided then the structure will be located in <System>/eos_<system>.h.\n The structure will be named EOS_<System>_InitializeOptions."]
    pub SystemInitializeOptions: *mut ::std::os::raw::c_void,
    #[doc = " The thread affinity override values for each category of thread."]
    pub OverrideThreadAffinity: *mut EOS_Initialize_ThreadAffinity,
}
#[test]
fn bindgen_test_layout__tagEOS_InitializeOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_InitializeOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_InitializeOptions>(),
        72usize,
        concat!("Size of: ", stringify!(_tagEOS_InitializeOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_InitializeOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_InitializeOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_InitializeOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocateMemoryFunction) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_InitializeOptions),
            "::",
            stringify!(AllocateMemoryFunction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReallocateMemoryFunction) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_InitializeOptions),
            "::",
            stringify!(ReallocateMemoryFunction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseMemoryFunction) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_InitializeOptions),
            "::",
            stringify!(ReleaseMemoryFunction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProductName) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_InitializeOptions),
            "::",
            stringify!(ProductName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProductVersion) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_InitializeOptions),
            "::",
            stringify!(ProductVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_InitializeOptions),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SystemInitializeOptions) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_InitializeOptions),
            "::",
            stringify!(SystemInitializeOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OverrideThreadAffinity) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_InitializeOptions),
            "::",
            stringify!(OverrideThreadAffinity)
        )
    );
}
pub type EOS_InitializeOptions = _tagEOS_InitializeOptions;
extern "C" {
    #[doc = " Initialize the Epic Online Services SDK.\n\n Before calling any other function in the SDK, clients must call this function.\n\n This function must only be called one time and must have a corresponding EOS_Shutdown call.\n\n @param Options - The initialization options to use for the SDK.\n @return An EOS_EResult is returned to indicate success or an error.\n\n EOS_Success is returned if the SDK successfully initializes.\n EOS_AlreadyConfigured is returned if the function has already been called.\n EOS_InvalidParameters is returned if the provided options are invalid."]
    pub fn EOS_Initialize(Options: *const EOS_InitializeOptions) -> EOS_EResult;
}
extern "C" {
    #[doc = " Tear down the Epic Online Services SDK.\n\n Once this function has been called, no more SDK calls are permitted; calling anything after EOS_Shutdown will result in undefined behavior.\n @return An EOS_EResult is returned to indicate success or an error.\n EOS_Success is returned if the SDK is successfully torn down.\n EOS_NotConfigured is returned if a successful call to EOS_Initialize has not been made.\n EOS_UnexpectedError is returned if EOS_Shutdown has already been called."]
    pub fn EOS_Shutdown() -> EOS_EResult;
}
extern "C" {
    #[doc = " Create a single Epic Online Services Platform Instance.\n\n The platform instance is used to gain access to the various Epic Online Services.\n\n This function returns an opaque handle to the platform instance, and that handle must be passed to EOS_Platform_Release to release the instance.\n\n @return An opaque handle to the platform instance."]
    pub fn EOS_Platform_Create(Options: *const EOS_Platform_Options) -> EOS_HPlatform;
}
extern "C" {
    #[doc = " Release an Epic Online Services platform instance previously returned from EOS_Platform_Create.\n\n This function should only be called once per instance returned by EOS_Platform_Create. Undefined behavior will result in calling it with a single instance more than once.\n Typically only a single platform instance needs to be created during the lifetime of a game.\n You should release each platform instance before calling the EOS_Shutdown function."]
    pub fn EOS_Platform_Release(Handle: EOS_HPlatform);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_MetricsHandle {
    _unused: [u8; 0],
}
pub type EOS_HMetrics = *mut EOS_MetricsHandle;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EUserControllerType {
    #[doc = " The game controller type is unknown."]
    EOS_UCT_Unknown = 0,
    #[doc = " Mouse and keyboard controller."]
    EOS_UCT_MouseKeyboard = 1,
    #[doc = " Gamepad controller."]
    EOS_UCT_GamepadControl = 2,
    #[doc = " Touch controller."]
    EOS_UCT_TouchControl = 3,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EMetricsAccountIdType {
    #[doc = " An Epic Account ID."]
    EOS_MAIT_Epic = 0,
    #[doc = " An external service Account ID."]
    EOS_MAIT_External = 1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _tagEOS_Metrics_BeginPlayerSessionOptions {
    #[doc = " API Version: Set this to EOS_METRICS_BEGINPLAYERSESSION_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Account ID type that is set in the union."]
    pub AccountIdType: EOS_EMetricsAccountIdType,
    #[doc = " The Account ID for the player whose session is beginning."]
    pub AccountId: _tagEOS_Metrics_BeginPlayerSessionOptions__bindgen_ty_1,
    #[doc = " The in-game display name for the user as UTF-8 string."]
    pub DisplayName: *const ::std::os::raw::c_char,
    #[doc = " The user's game controller type."]
    pub ControllerType: EOS_EUserControllerType,
    #[doc = " IP address of the game server hosting the game session. For a localhost session, set to NULL.\n\n @details Must be in either one of the following IPv4 or IPv6 string formats:\n * \"127.0.0.1\".\n * \"1200:0000:AB00:1234:0000:2552:7777:1313\".\n If both IPv4 and IPv6 addresses are available, use the IPv6 address."]
    pub ServerIp: *const ::std::os::raw::c_char,
    #[doc = " Optional, application-defined custom match session identifier. If the identifier is not used, set to NULL.\n\n @details The game can tag each game session with a custom session match identifier,\n which will be shown in the Played Sessions listing at the user profile dashboard."]
    pub GameSessionId: *const ::std::os::raw::c_char,
}
#[doc = " The Account ID for the player whose session is beginning."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _tagEOS_Metrics_BeginPlayerSessionOptions__bindgen_ty_1 {
    #[doc = " An Epic Account ID. Set this field when AccountIdType is set to EOS_MAIT_Epic."]
    pub Epic: EOS_EpicAccountId,
    #[doc = " An Account ID for another service. Set this field when AccountIdType is set to EOS_MAIT_External."]
    pub External: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Metrics_BeginPlayerSessionOptions__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Metrics_BeginPlayerSessionOptions__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Metrics_BeginPlayerSessionOptions__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Metrics_BeginPlayerSessionOptions__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Metrics_BeginPlayerSessionOptions__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Metrics_BeginPlayerSessionOptions__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Epic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Metrics_BeginPlayerSessionOptions__bindgen_ty_1),
            "::",
            stringify!(Epic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).External) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Metrics_BeginPlayerSessionOptions__bindgen_ty_1),
            "::",
            stringify!(External)
        )
    );
}
#[test]
fn bindgen_test_layout__tagEOS_Metrics_BeginPlayerSessionOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Metrics_BeginPlayerSessionOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Metrics_BeginPlayerSessionOptions>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Metrics_BeginPlayerSessionOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Metrics_BeginPlayerSessionOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Metrics_BeginPlayerSessionOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Metrics_BeginPlayerSessionOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccountIdType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Metrics_BeginPlayerSessionOptions),
            "::",
            stringify!(AccountIdType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccountId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Metrics_BeginPlayerSessionOptions),
            "::",
            stringify!(AccountId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisplayName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Metrics_BeginPlayerSessionOptions),
            "::",
            stringify!(DisplayName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ControllerType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Metrics_BeginPlayerSessionOptions),
            "::",
            stringify!(ControllerType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ServerIp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Metrics_BeginPlayerSessionOptions),
            "::",
            stringify!(ServerIp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GameSessionId) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Metrics_BeginPlayerSessionOptions),
            "::",
            stringify!(GameSessionId)
        )
    );
}
pub type EOS_Metrics_BeginPlayerSessionOptions = _tagEOS_Metrics_BeginPlayerSessionOptions;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _tagEOS_Metrics_EndPlayerSessionOptions {
    #[doc = " API Version: Set this to EOS_METRICS_ENDPLAYERSESSION_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Account ID type that is set in the union."]
    pub AccountIdType: EOS_EMetricsAccountIdType,
    #[doc = " The Account ID for the player whose session is ending."]
    pub AccountId: _tagEOS_Metrics_EndPlayerSessionOptions__bindgen_ty_1,
}
#[doc = " The Account ID for the player whose session is ending."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _tagEOS_Metrics_EndPlayerSessionOptions__bindgen_ty_1 {
    #[doc = " An Epic Account ID. Set this field when AccountIdType is set to EOS_MAIT_Epic."]
    pub Epic: EOS_EpicAccountId,
    #[doc = " An Account ID for another service. Set this field when AccountIdType is set to EOS_MAIT_External."]
    pub External: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Metrics_EndPlayerSessionOptions__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Metrics_EndPlayerSessionOptions__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Metrics_EndPlayerSessionOptions__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Metrics_EndPlayerSessionOptions__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Metrics_EndPlayerSessionOptions__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Metrics_EndPlayerSessionOptions__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Epic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Metrics_EndPlayerSessionOptions__bindgen_ty_1),
            "::",
            stringify!(Epic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).External) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Metrics_EndPlayerSessionOptions__bindgen_ty_1),
            "::",
            stringify!(External)
        )
    );
}
#[test]
fn bindgen_test_layout__tagEOS_Metrics_EndPlayerSessionOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Metrics_EndPlayerSessionOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Metrics_EndPlayerSessionOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Metrics_EndPlayerSessionOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Metrics_EndPlayerSessionOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Metrics_EndPlayerSessionOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Metrics_EndPlayerSessionOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccountIdType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Metrics_EndPlayerSessionOptions),
            "::",
            stringify!(AccountIdType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccountId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Metrics_EndPlayerSessionOptions),
            "::",
            stringify!(AccountId)
        )
    );
}
pub type EOS_Metrics_EndPlayerSessionOptions = _tagEOS_Metrics_EndPlayerSessionOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Auth_AccountFeatureRestrictedInfo {
    #[doc = " API Version: Set this to EOS_AUTH_ACCOUNTFEATURERESTRICTEDINFO_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The end-user verification URI. Users must be asked to open the page in a browser to address the restrictions."]
    pub VerificationURI: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Auth_AccountFeatureRestrictedInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Auth_AccountFeatureRestrictedInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Auth_AccountFeatureRestrictedInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Auth_AccountFeatureRestrictedInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Auth_AccountFeatureRestrictedInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Auth_AccountFeatureRestrictedInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_AccountFeatureRestrictedInfo),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VerificationURI) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_AccountFeatureRestrictedInfo),
            "::",
            stringify!(VerificationURI)
        )
    );
}
pub type EOS_Auth_AccountFeatureRestrictedInfo = _tagEOS_Auth_AccountFeatureRestrictedInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_AuthHandle {
    _unused: [u8; 0],
}
pub type EOS_HAuth = *mut EOS_AuthHandle;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_ELoginCredentialType {
    #[doc = " Login using account email address and password.\n\n @note Use of this login method is restricted and cannot be used in general."]
    EOS_LCT_Password = 0,
    #[doc = " A short-lived one-time use exchange code to login the local user.\n\n @details Typically retrieved via command-line parameters provided by a launcher that generated the exchange code for this application.\n When started, the application is expected to consume the exchange code by using the EOS_Auth_Login API as soon as possible.\n This is needed in order to authenticate the local user before the exchange code would expire.\n Attempting to consume an already expired exchange code will return EOS_EResult::EOS_Auth_ExchangeCodeNotFound error by the EOS_Auth_Login API."]
    EOS_LCT_ExchangeCode = 1,
    #[doc = " Used by standalone applications distributed outside the supported game platforms such as Epic Games Store or Steam, and on Nintendo Switch.\n\n Persistent Auth is used in conjuction with the EOS_LCT_AccountPortal login method for automatic login of the local user across multiple runs of the application.\n\n Standalone applications implement the login sequence as follows:\n 1. Application calls EOS_Auth_Login with EOS_LCT_PersistentAuth, using a previously stored Epic refresh token for an automatic user login.\n 2. If automatic login fails, the application discards the Epic refresh token used as defunct, and proceeds to call EOS_Auth_Login with EOS_LCT_AccountPortal to prompt the user for manual login.\n\n @note On Desktop and Mobile platforms, the persistent refresh token is automatically managed by the SDK that stores it in the keychain of the currently logged in user of the local device.\n On Nintendo Switch, after a successful login the refresh token must be retrieved using the EOS_Auth_CopyUserAuthToken API and stored by the application specifically for the active Nintendo Switch user.\n\n @see EOS_LCT_AccountPortal"]
    EOS_LCT_PersistentAuth = 2,
    #[doc = " Not supported. Superseded by EOS_LCT_ExternalAuth login method.\n\n @see EOS_LCT_ExternalAuth"]
    EOS_LCT_DeviceCode = 3,
    #[doc = " Login with named credentials hosted by the EOS SDK Developer Authentication Tool.\n\n @note Used for development purposes only."]
    EOS_LCT_Developer = 4,
    #[doc = " Refresh token that was retrieved from a previous call to EOS_Auth_Login API in another local process context.\n Mainly used in conjunction with custom desktop launcher applications.\n\n @details Can be used for example when launching the game from Epic Games Launcher and having an intermediate process\n in-between that requires authenticating the user before eventually starting the actual game client application.\n In such scenario, an intermediate launcher will log in the user by consuming the exchange code it received from the\n Epic Games Launcher. To allow the game client to also authenticate the user, it can copy the refresh token using the\n EOS_Auth_CopyUserAuthToken API and pass it via launch parameters to the started game client. The game client can then\n use the refresh token to log in the user."]
    EOS_LCT_RefreshToken = 5,
    #[doc = " Used by standalone applications distributed outside the supported game platforms such as Epic Games Store or Steam, and on Nintendo Switch.\n\n Login using the built-in user onboarding experience provided by the SDK, which will automatically store a persistent\n refresh token to enable automatic user login for consecutive application runs on the local device. Applications are\n expected to attempt automatic login using the EOS_LCT_PersistentAuth login method, and fall back to EOS_LCT_AccountPortal\n to prompt users for manual login.\n\n @note On Windows, using this login method requires applications to be started through the EOS Bootstrapper application\n and to have the local Epic Online Services redistributable installed on the local system. See EOS_Platform_GetDesktopCrossplayStatus\n for adding a readiness check prior to calling EOS_Auth_Login.\n\n @see EOS_LCT_PersistentAuth"]
    EOS_LCT_AccountPortal = 6,
    #[doc = " Login using external account provider credentials, such as PlayStation(TM)Network, Steam, and Xbox Live.\n\n This is the intended login method on PlayStation and Xbox console devices.\n On Desktop and Mobile, used when launched through any of the commonly supported platform clients.\n\n @details The user is seamlessly logged in to their Epic account using an external account access token.\n If the local platform account is already linked with the user's Epic account, the login will succeed and EOS_EResult::EOS_Success is returned.\n When the local platform account has not been linked with an Epic account yet,\n EOS_EResult::EOS_InvalidUser is returned and the EOS_ContinuanceToken will be set in the EOS_Auth_LoginCallbackInfo data.\n If EOS_EResult::EOS_InvalidUser is returned,\n the application should proceed to call the EOS_Auth_LinkAccount API with the EOS_ContinuanceToken to continue with the external account login\n and to link the external account at the end of the login flow.\n\n @details Login flow when the platform user account has not been linked with an Epic account yet:\n 1. Game calls EOS_Auth_Login with the EOS_LCT_ExternalAuth credential type.\n 2. EOS_Auth_Login returns EOS_EResult::EOS_InvalidUser with a non-null EOS_ContinuanceToken in the EOS_Auth_LoginCallbackInfo data.\n 3. Game calls EOS_Auth_LinkAccount with the EOS_ContinuanceToken to initiate the login flow for linking the platform account with the user's Epic account.\n 4. The user is taken automatically to the Epic accounts user onboarding flow managed by the SDK.\n 5. Once the user completes the login, cancels it or if the login flow times out, EOS_Auth_LinkAccount invokes the completion callback to the caller.\n    - If the user was logged in successfully, EOS_EResult::EOS_Success is returned in the EOS_Auth_LoginCallbackInfo. Otherwise, an error result code is returned accordingly.\n\n @note On Windows, using this login method requires applications to be started through the EOS Bootstrapper application\n and to have the local Epic Online Services redistributable installed on the local system. See EOS_Platform_GetDesktopCrossplayStatus\n for adding a readiness check prior to calling EOS_Auth_Login."]
    EOS_LCT_ExternalAuth = 7,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EAuthTokenType {
    #[doc = " Auth token is for a validated client"]
    EOS_ATT_Client = 0,
    #[doc = " Auth token is for a validated user"]
    EOS_ATT_User = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Auth_Token {
    #[doc = " API Version: Set this to EOS_AUTH_TOKEN_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Name of the app related to the client ID involved with this token"]
    pub App: *const ::std::os::raw::c_char,
    #[doc = " Client ID that requested this token"]
    pub ClientId: *const ::std::os::raw::c_char,
    #[doc = " The Epic Account ID associated with this auth token"]
    pub AccountId: EOS_EpicAccountId,
    #[doc = " Access token for the current user login session"]
    pub AccessToken: *const ::std::os::raw::c_char,
    #[doc = " Time before the access token expires, in seconds, relative to the call to EOS_Auth_CopyUserAuthToken"]
    pub ExpiresIn: f64,
    #[doc = " Absolute time in UTC before the access token expires, in ISO 8601 format"]
    pub ExpiresAt: *const ::std::os::raw::c_char,
    #[doc = " Type of auth token"]
    pub AuthType: EOS_EAuthTokenType,
    #[doc = " Refresh token.\n\n @see EOS_ELoginCredentialType::EOS_LCT_RefreshToken"]
    pub RefreshToken: *const ::std::os::raw::c_char,
    #[doc = " Time before the access token expires, in seconds, relative to the call to EOS_Auth_CopyUserAuthToken"]
    pub RefreshExpiresIn: f64,
    #[doc = " Absolute time in UTC before the refresh token expires, in ISO 8601 format"]
    pub RefreshExpiresAt: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Auth_Token() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Auth_Token> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Auth_Token>(),
        88usize,
        concat!("Size of: ", stringify!(_tagEOS_Auth_Token))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Auth_Token>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Auth_Token))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_Token),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).App) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_Token),
            "::",
            stringify!(App)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_Token),
            "::",
            stringify!(ClientId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccountId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_Token),
            "::",
            stringify!(AccountId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccessToken) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_Token),
            "::",
            stringify!(AccessToken)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExpiresIn) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_Token),
            "::",
            stringify!(ExpiresIn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExpiresAt) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_Token),
            "::",
            stringify!(ExpiresAt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AuthType) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_Token),
            "::",
            stringify!(AuthType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RefreshToken) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_Token),
            "::",
            stringify!(RefreshToken)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RefreshExpiresIn) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_Token),
            "::",
            stringify!(RefreshExpiresIn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RefreshExpiresAt) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_Token),
            "::",
            stringify!(RefreshExpiresAt)
        )
    );
}
pub type EOS_Auth_Token = _tagEOS_Auth_Token;
extern "C" {
    #[doc = " Release the memory associated with an EOS_Auth_Token structure. This must be called on data retrieved from EOS_Auth_CopyUserAuthToken.\n\n @param AuthToken The auth token structure to be released.\n\n @see EOS_Auth_Token\n @see EOS_Auth_CopyUserAuthToken"]
    pub fn EOS_Auth_Token_Release(AuthToken: *mut EOS_Auth_Token);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Auth_Credentials {
    #[doc = " API Version: Set this to EOS_AUTH_CREDENTIALS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Authentication ID value based on the used EOS_ELoginCredentialType.\n If not used, must be set to NULL."]
    pub Id: *const ::std::os::raw::c_char,
    #[doc = " Authentication Token value based on the used EOS_ELoginCredentialType.\n If not used, must be set to NULL."]
    pub Token: *const ::std::os::raw::c_char,
    #[doc = " Login credentials type based on the authentication method used."]
    pub Type: EOS_ELoginCredentialType,
    #[doc = " This field is for system specific options, if any.\n\n If provided, the structure will be located in (System)/eos_(system).h.\n The structure will be named EOS_(System)_Auth_CredentialsOptions."]
    pub SystemAuthCredentialsOptions: *mut ::std::os::raw::c_void,
    #[doc = " Type of external login. Needed to identify the external auth method to use.\n Used when login type is set to EOS_LCT_ExternalAuth, ignored for other EOS_ELoginCredentialType methods."]
    pub ExternalType: EOS_EExternalCredentialType,
}
#[test]
fn bindgen_test_layout__tagEOS_Auth_Credentials() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Auth_Credentials> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Auth_Credentials>(),
        48usize,
        concat!("Size of: ", stringify!(_tagEOS_Auth_Credentials))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Auth_Credentials>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Auth_Credentials))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_Credentials),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_Credentials),
            "::",
            stringify!(Id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Token) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_Credentials),
            "::",
            stringify!(Token)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_Credentials),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).SystemAuthCredentialsOptions) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_Credentials),
            "::",
            stringify!(SystemAuthCredentialsOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExternalType) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_Credentials),
            "::",
            stringify!(ExternalType)
        )
    );
}
pub type EOS_Auth_Credentials = _tagEOS_Auth_Credentials;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Auth_PinGrantInfo {
    #[doc = " API Version: Set this to EOS_AUTH_PINGRANTINFO_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Code the user must input on an external device to activate the login."]
    pub UserCode: *const ::std::os::raw::c_char,
    #[doc = " The end-user verification URI. Users can be asked to manually type this into their browser."]
    pub VerificationURI: *const ::std::os::raw::c_char,
    #[doc = " Time the user has, in seconds, to complete the process or else timeout."]
    pub ExpiresIn: i32,
    #[doc = " A verification URI that includes the user code. Useful for non-textual transmission."]
    pub VerificationURIComplete: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Auth_PinGrantInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Auth_PinGrantInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Auth_PinGrantInfo>(),
        40usize,
        concat!("Size of: ", stringify!(_tagEOS_Auth_PinGrantInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Auth_PinGrantInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Auth_PinGrantInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_PinGrantInfo),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserCode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_PinGrantInfo),
            "::",
            stringify!(UserCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VerificationURI) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_PinGrantInfo),
            "::",
            stringify!(VerificationURI)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExpiresIn) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_PinGrantInfo),
            "::",
            stringify!(ExpiresIn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VerificationURIComplete) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_PinGrantInfo),
            "::",
            stringify!(VerificationURIComplete)
        )
    );
}
pub type EOS_Auth_PinGrantInfo = _tagEOS_Auth_PinGrantInfo;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EAuthScopeFlags {
    #[doc = " Flags that describe user permissions"]
    EOS_AS_NoFlags = 0,
    #[doc = " Permissions to see your account ID, display name, and language"]
    EOS_AS_BasicProfile = 1,
    #[doc = " Permissions to see a list of your friends who use this application"]
    EOS_AS_FriendsList = 2,
    #[doc = " Permissions to set your online presence and see presence of your friends"]
    EOS_AS_Presence = 4,
    #[doc = " Permissions to manage the Epic friends list. This scope is restricted to Epic first party products, and attempting to use it will result in authentication failures."]
    EOS_AS_FriendsManagement = 8,
    #[doc = " Permissions to see email in the response when fetching information for a user. This scope is restricted to Epic first party products, and attempting to use it will result in authentication failures."]
    EOS_AS_Email = 16,
    #[doc = " Permissions to see your country"]
    EOS_AS_Country = 32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Auth_LoginOptions {
    #[doc = " API Version: Set this to EOS_AUTH_LOGIN_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Credentials specified for a given login method."]
    pub Credentials: *const EOS_Auth_Credentials,
    #[doc = " Auth scope flags are permissions to request from the user while they are logging in. This is a bitwise-or union of EOS_EAuthScopeFlags flags defined above."]
    pub ScopeFlags: EOS_EAuthScopeFlags,
    #[doc = " Optional flags for the desired login behavior, e.g. EOS_LF_NO_USER_INTERFACE. This is a bitwise-or union of the defined flags."]
    pub LoginFlags: u64,
}
#[test]
fn bindgen_test_layout__tagEOS_Auth_LoginOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Auth_LoginOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Auth_LoginOptions>(),
        32usize,
        concat!("Size of: ", stringify!(_tagEOS_Auth_LoginOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Auth_LoginOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Auth_LoginOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LoginOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Credentials) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LoginOptions),
            "::",
            stringify!(Credentials)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ScopeFlags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LoginOptions),
            "::",
            stringify!(ScopeFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LoginFlags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LoginOptions),
            "::",
            stringify!(LoginFlags)
        )
    );
}
pub type EOS_Auth_LoginOptions = _tagEOS_Auth_LoginOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Auth_LoginCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Auth_Login."]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Account ID of the local user who has logged in."]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " Optional data that may be returned in the middle of the login flow, when neither the in-game overlay or a platform browser is used.\n This data is present when the ResultCode is EOS_Auth_PinGrantCode."]
    pub PinGrantInfo: *const EOS_Auth_PinGrantInfo,
    #[doc = " If the user was not found with external auth credentials passed into EOS_Auth_Login, this continuance token can be passed to EOS_Auth_LinkAccount to continue the flow."]
    pub ContinuanceToken: EOS_ContinuanceToken,
    #[doc = " Deprecated field that is no longer used."]
    pub AccountFeatureRestrictedInfo_DEPRECATED: *const EOS_Auth_AccountFeatureRestrictedInfo,
    #[doc = " The Epic Account ID that has been previously selected to be used for the current application.\n Applications should use this ID to authenticate with online backend services that store game-scoped data for users.\n\n Note: This ID may be different from LocalUserId if the user has previously merged Epic accounts into the account\n represented by LocalUserId, and one of the accounts that got merged had game data associated with it for the application."]
    pub SelectedAccountId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Auth_LoginCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Auth_LoginCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Auth_LoginCallbackInfo>(),
        56usize,
        concat!("Size of: ", stringify!(_tagEOS_Auth_LoginCallbackInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Auth_LoginCallbackInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Auth_LoginCallbackInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LoginCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LoginCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LoginCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PinGrantInfo) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LoginCallbackInfo),
            "::",
            stringify!(PinGrantInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ContinuanceToken) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LoginCallbackInfo),
            "::",
            stringify!(ContinuanceToken)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).AccountFeatureRestrictedInfo_DEPRECATED) as usize
                - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LoginCallbackInfo),
            "::",
            stringify!(AccountFeatureRestrictedInfo_DEPRECATED)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SelectedAccountId) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LoginCallbackInfo),
            "::",
            stringify!(SelectedAccountId)
        )
    );
}
pub type EOS_Auth_LoginCallbackInfo = _tagEOS_Auth_LoginCallbackInfo;
pub type EOS_Auth_OnLoginCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Auth_LoginCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Auth_LogoutOptions {
    #[doc = " API Version: Set this to EOS_AUTH_LOGOUT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user who is being logged out"]
    pub LocalUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Auth_LogoutOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Auth_LogoutOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Auth_LogoutOptions>(),
        16usize,
        concat!("Size of: ", stringify!(_tagEOS_Auth_LogoutOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Auth_LogoutOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Auth_LogoutOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LogoutOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LogoutOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Auth_LogoutOptions = _tagEOS_Auth_LogoutOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Auth_LogoutCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Auth_Login"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Account ID of the local user requesting the information"]
    pub LocalUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Auth_LogoutCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Auth_LogoutCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Auth_LogoutCallbackInfo>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Auth_LogoutCallbackInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Auth_LogoutCallbackInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Auth_LogoutCallbackInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LogoutCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LogoutCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LogoutCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Auth_LogoutCallbackInfo = _tagEOS_Auth_LogoutCallbackInfo;
pub type EOS_Auth_OnLogoutCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Auth_LogoutCallbackInfo)>;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_ELinkAccountFlags {
    #[doc = " Default flag used for a standard account linking operation.\n\n This flag is set when using a continuance token received from a previous call to the EOS_Auth_Login API,\n when the local user has not yet been successfully logged in to an Epic Account yet."]
    EOS_LA_NoFlags = 0,
    #[doc = " Specified when the EOS_ContinuanceToken describes a Nintendo NSA ID account type.\n\n This flag is used only with, and must be set, when the continuance token was received from a previous call\n to the EOS_Auth_Login API using the EOS_EExternalCredentialType::EOS_ECT_NINTENDO_NSA_ID_TOKEN login type."]
    EOS_LA_NintendoNsaId = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Auth_LinkAccountOptions {
    #[doc = " API Version: Set this to EOS_AUTH_LINKACCOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Combination of the enumeration flags to specify how the account linking operation will be performed."]
    pub LinkAccountFlags: EOS_ELinkAccountFlags,
    #[doc = " Continuance token received from a previous call to the EOS_Auth_Login API.\n\n A continuance token is received in the case when the external account used for login was not found to be linked\n against any existing Epic Account. In such case, the application needs to proceed with an account linking operation in which case\n the user is first asked to create a new account or login into their existing Epic Account, and then link their external account to it.\n Alternatively, the application may suggest the user to login using another external account that they have already linked to their existing Epic Account.\n In this flow, the external account is typically the currently logged in local platform user account.\n It can also be another external user account that the user is offered to login with."]
    pub ContinuanceToken: EOS_ContinuanceToken,
    #[doc = " The Epic Account ID of the logged in local user whose Epic Account will be linked with the local Nintendo NSA ID Account. By default set to NULL.\n\n This parameter is only used and required to be set when EOS_ELinkAccountFlags::EOS_LA_NintendoNsaId is specified.\n Otherwise, set to NULL, as the standard account linking and login flow using continuance token will handle logging in the user to their Epic Account."]
    pub LocalUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Auth_LinkAccountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Auth_LinkAccountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Auth_LinkAccountOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Auth_LinkAccountOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Auth_LinkAccountOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Auth_LinkAccountOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LinkAccountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LinkAccountFlags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LinkAccountOptions),
            "::",
            stringify!(LinkAccountFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ContinuanceToken) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LinkAccountOptions),
            "::",
            stringify!(ContinuanceToken)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LinkAccountOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Auth_LinkAccountOptions = _tagEOS_Auth_LinkAccountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Auth_LinkAccountCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Auth_LinkAccount."]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Account ID of the local user whose account has been linked during login."]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " Optional data that may be returned in the middle of the login flow, when neither the in-game overlay or a platform browser is used.\n This data is present when the ResultCode is EOS_Auth_PinGrantCode."]
    pub PinGrantInfo: *const EOS_Auth_PinGrantInfo,
    #[doc = " The Epic Account ID that has been previously selected to be used for the current application.\n Applications should use this ID to authenticate with online backend services that store game-scoped data for users.\n\n Note: This ID may be different from LocalUserId if the user has previously merged Epic accounts into the account\n represented by LocalUserId, and one of the accounts that got merged had game data associated with it for the application."]
    pub SelectedAccountId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Auth_LinkAccountCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Auth_LinkAccountCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Auth_LinkAccountCallbackInfo>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Auth_LinkAccountCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Auth_LinkAccountCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Auth_LinkAccountCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LinkAccountCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LinkAccountCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LinkAccountCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PinGrantInfo) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LinkAccountCallbackInfo),
            "::",
            stringify!(PinGrantInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SelectedAccountId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LinkAccountCallbackInfo),
            "::",
            stringify!(SelectedAccountId)
        )
    );
}
pub type EOS_Auth_LinkAccountCallbackInfo = _tagEOS_Auth_LinkAccountCallbackInfo;
pub type EOS_Auth_OnLinkAccountCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Auth_LinkAccountCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Auth_VerifyUserAuthOptions {
    #[doc = " API Version: Set this to EOS_AUTH_VERIFYUSERAUTH_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Auth token to verify against the backend service"]
    pub AuthToken: *const EOS_Auth_Token,
}
#[test]
fn bindgen_test_layout__tagEOS_Auth_VerifyUserAuthOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Auth_VerifyUserAuthOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Auth_VerifyUserAuthOptions>(),
        16usize,
        concat!("Size of: ", stringify!(_tagEOS_Auth_VerifyUserAuthOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Auth_VerifyUserAuthOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Auth_VerifyUserAuthOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_VerifyUserAuthOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AuthToken) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_VerifyUserAuthOptions),
            "::",
            stringify!(AuthToken)
        )
    );
}
pub type EOS_Auth_VerifyUserAuthOptions = _tagEOS_Auth_VerifyUserAuthOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Auth_VerifyUserAuthCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Auth_Login"]
    pub ClientData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_Auth_VerifyUserAuthCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Auth_VerifyUserAuthCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Auth_VerifyUserAuthCallbackInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Auth_VerifyUserAuthCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Auth_VerifyUserAuthCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Auth_VerifyUserAuthCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_VerifyUserAuthCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_VerifyUserAuthCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
}
pub type EOS_Auth_VerifyUserAuthCallbackInfo = _tagEOS_Auth_VerifyUserAuthCallbackInfo;
pub type EOS_Auth_OnVerifyUserAuthCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Auth_VerifyUserAuthCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Auth_CopyUserAuthTokenOptions {
    #[doc = " API Version: Set this to EOS_AUTH_COPYUSERAUTHTOKEN_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Auth_CopyUserAuthTokenOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Auth_CopyUserAuthTokenOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Auth_CopyUserAuthTokenOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Auth_CopyUserAuthTokenOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Auth_CopyUserAuthTokenOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Auth_CopyUserAuthTokenOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_CopyUserAuthTokenOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Auth_CopyUserAuthTokenOptions = _tagEOS_Auth_CopyUserAuthTokenOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Auth_CopyIdTokenOptions {
    #[doc = " API Version: Set this to EOS_AUTH_COPYIDTOKEN_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the user being queried."]
    pub AccountId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Auth_CopyIdTokenOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Auth_CopyIdTokenOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Auth_CopyIdTokenOptions>(),
        16usize,
        concat!("Size of: ", stringify!(_tagEOS_Auth_CopyIdTokenOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Auth_CopyIdTokenOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Auth_CopyIdTokenOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_CopyIdTokenOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccountId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_CopyIdTokenOptions),
            "::",
            stringify!(AccountId)
        )
    );
}
pub type EOS_Auth_CopyIdTokenOptions = _tagEOS_Auth_CopyIdTokenOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Auth_IdToken {
    #[doc = " API Version: Set this to EOS_AUTH_IDTOKEN_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID described by the ID token.\n Use EOS_EpicAccountId_FromString to populate this field when validating a received ID token."]
    pub AccountId: EOS_EpicAccountId,
    #[doc = " The ID token as a Json Web Token (JWT) string."]
    pub JsonWebToken: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Auth_IdToken() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Auth_IdToken> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Auth_IdToken>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Auth_IdToken))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Auth_IdToken>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Auth_IdToken))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_IdToken),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccountId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_IdToken),
            "::",
            stringify!(AccountId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).JsonWebToken) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_IdToken),
            "::",
            stringify!(JsonWebToken)
        )
    );
}
pub type EOS_Auth_IdToken = _tagEOS_Auth_IdToken;
extern "C" {
    #[doc = " Release the memory associated with an EOS_Auth_IdToken structure. This must be called on data retrieved from EOS_Auth_CopyIdToken.\n\n @param IdToken The ID token structure to be released.\n\n @see EOS_Auth_IdToken\n @see EOS_Auth_CopyIdToken"]
    pub fn EOS_Auth_IdToken_Release(IdToken: *mut EOS_Auth_IdToken);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Auth_QueryIdTokenOptions {
    #[doc = " API Version: Set this to EOS_AUTH_QUERYIDTOKEN_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local authenticated user."]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The target Epic Account ID for which to query an ID token.\n This account id may be the same as the input LocalUserId or another merged account id associated with the local user's Epic account.\n\n An ID token for the selected account id of a locally authenticated user will always be readily available.\n To retrieve it for the selected account ID, you can use EOS_Auth_CopyIdToken directly after a successful user login."]
    pub TargetAccountId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Auth_QueryIdTokenOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Auth_QueryIdTokenOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Auth_QueryIdTokenOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Auth_QueryIdTokenOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Auth_QueryIdTokenOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Auth_QueryIdTokenOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_QueryIdTokenOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_QueryIdTokenOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetAccountId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_QueryIdTokenOptions),
            "::",
            stringify!(TargetAccountId)
        )
    );
}
pub type EOS_Auth_QueryIdTokenOptions = _tagEOS_Auth_QueryIdTokenOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Auth_QueryIdTokenCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Auth_QueryIdToken"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Account ID of the local authenticated user."]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The target Epic Account ID for which the ID token was retrieved."]
    pub TargetAccountId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Auth_QueryIdTokenCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Auth_QueryIdTokenCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Auth_QueryIdTokenCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Auth_QueryIdTokenCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Auth_QueryIdTokenCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Auth_QueryIdTokenCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_QueryIdTokenCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_QueryIdTokenCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_QueryIdTokenCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetAccountId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_QueryIdTokenCallbackInfo),
            "::",
            stringify!(TargetAccountId)
        )
    );
}
pub type EOS_Auth_QueryIdTokenCallbackInfo = _tagEOS_Auth_QueryIdTokenCallbackInfo;
pub type EOS_Auth_OnQueryIdTokenCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Auth_QueryIdTokenCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Auth_VerifyIdTokenOptions {
    #[doc = " API Version: Set this to EOS_AUTH_VERIFYIDTOKEN_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The ID token to verify.\n Use EOS_EpicAccountId_FromString to populate the AccountId field of this struct."]
    pub IdToken: *const EOS_Auth_IdToken,
}
#[test]
fn bindgen_test_layout__tagEOS_Auth_VerifyIdTokenOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Auth_VerifyIdTokenOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Auth_VerifyIdTokenOptions>(),
        16usize,
        concat!("Size of: ", stringify!(_tagEOS_Auth_VerifyIdTokenOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Auth_VerifyIdTokenOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Auth_VerifyIdTokenOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_VerifyIdTokenOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IdToken) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_VerifyIdTokenOptions),
            "::",
            stringify!(IdToken)
        )
    );
}
pub type EOS_Auth_VerifyIdTokenOptions = _tagEOS_Auth_VerifyIdTokenOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Auth_VerifyIdTokenCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Auth_VerifyIdToken"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Epic Account Services Application ID."]
    pub ApplicationId: *const ::std::os::raw::c_char,
    #[doc = " Client ID of the authorized client."]
    pub ClientId: *const ::std::os::raw::c_char,
    #[doc = " Product ID."]
    pub ProductId: *const ::std::os::raw::c_char,
    #[doc = " Sandbox ID."]
    pub SandboxId: *const ::std::os::raw::c_char,
    #[doc = " Deployment ID."]
    pub DeploymentId: *const ::std::os::raw::c_char,
    #[doc = " Epic Account display name.\n\n This value may be set to an empty string."]
    pub DisplayName: *const ::std::os::raw::c_char,
    #[doc = " Flag set to indicate whether external account information is present.\n Applications must always first check this value to be set before attempting\n to read the ExternalAccountIdType, ExternalAccountId, ExternalAccountDisplayName and Platform fields.\n\n This flag is set when the user has logged in to their Epic Account using external account credentials, e.g. through local platform authentication."]
    pub bIsExternalAccountInfoPresent: EOS_Bool,
    #[doc = " The identity provider that the user logged in with to their Epic Account.\n\n If bIsExternalAccountInfoPresent is set, this field describes the external account type."]
    pub ExternalAccountIdType: EOS_EExternalAccountType,
    #[doc = " The external account ID of the logged in user.\n\n This value may be set to an empty string."]
    pub ExternalAccountId: *const ::std::os::raw::c_char,
    #[doc = " The external account display name.\n\n This value may be set to an empty string."]
    pub ExternalAccountDisplayName: *const ::std::os::raw::c_char,
    #[doc = " Platform that the user is connected from.\n\n This value may be set to an empty string."]
    pub Platform: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Auth_VerifyIdTokenCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Auth_VerifyIdTokenCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Auth_VerifyIdTokenCallbackInfo>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Auth_VerifyIdTokenCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Auth_VerifyIdTokenCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Auth_VerifyIdTokenCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_VerifyIdTokenCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_VerifyIdTokenCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApplicationId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_VerifyIdTokenCallbackInfo),
            "::",
            stringify!(ApplicationId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_VerifyIdTokenCallbackInfo),
            "::",
            stringify!(ClientId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProductId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_VerifyIdTokenCallbackInfo),
            "::",
            stringify!(ProductId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SandboxId) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_VerifyIdTokenCallbackInfo),
            "::",
            stringify!(SandboxId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DeploymentId) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_VerifyIdTokenCallbackInfo),
            "::",
            stringify!(DeploymentId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisplayName) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_VerifyIdTokenCallbackInfo),
            "::",
            stringify!(DisplayName)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).bIsExternalAccountInfoPresent) as usize - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_VerifyIdTokenCallbackInfo),
            "::",
            stringify!(bIsExternalAccountInfoPresent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExternalAccountIdType) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_VerifyIdTokenCallbackInfo),
            "::",
            stringify!(ExternalAccountIdType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExternalAccountId) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_VerifyIdTokenCallbackInfo),
            "::",
            stringify!(ExternalAccountId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExternalAccountDisplayName) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_VerifyIdTokenCallbackInfo),
            "::",
            stringify!(ExternalAccountDisplayName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Platform) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_VerifyIdTokenCallbackInfo),
            "::",
            stringify!(Platform)
        )
    );
}
pub type EOS_Auth_VerifyIdTokenCallbackInfo = _tagEOS_Auth_VerifyIdTokenCallbackInfo;
pub type EOS_Auth_OnVerifyIdTokenCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Auth_VerifyIdTokenCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Auth_AddNotifyLoginStatusChangedOptions {
    #[doc = " API Version: Set this to EOS_AUTH_ADDNOTIFYLOGINSTATUSCHANGED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Auth_AddNotifyLoginStatusChangedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Auth_AddNotifyLoginStatusChangedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Auth_AddNotifyLoginStatusChangedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Auth_AddNotifyLoginStatusChangedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Auth_AddNotifyLoginStatusChangedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Auth_AddNotifyLoginStatusChangedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_AddNotifyLoginStatusChangedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Auth_AddNotifyLoginStatusChangedOptions =
    _tagEOS_Auth_AddNotifyLoginStatusChangedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Auth_DeletePersistentAuthOptions {
    #[doc = " API Version: Set this to EOS_AUTH_DELETEPERSISTENTAUTH_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " A long-lived refresh token that is used with the EOS_LCT_PersistentAuth login type and is to be revoked from the authentication server. Only used on Console platforms.\n On Desktop and Mobile platforms, set this parameter to NULL."]
    pub RefreshToken: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Auth_DeletePersistentAuthOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Auth_DeletePersistentAuthOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Auth_DeletePersistentAuthOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Auth_DeletePersistentAuthOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Auth_DeletePersistentAuthOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Auth_DeletePersistentAuthOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_DeletePersistentAuthOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RefreshToken) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_DeletePersistentAuthOptions),
            "::",
            stringify!(RefreshToken)
        )
    );
}
pub type EOS_Auth_DeletePersistentAuthOptions = _tagEOS_Auth_DeletePersistentAuthOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Auth_DeletePersistentAuthCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Auth_DeletePersistentAuth"]
    pub ClientData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_Auth_DeletePersistentAuthCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Auth_DeletePersistentAuthCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Auth_DeletePersistentAuthCallbackInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Auth_DeletePersistentAuthCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Auth_DeletePersistentAuthCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Auth_DeletePersistentAuthCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_DeletePersistentAuthCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_DeletePersistentAuthCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
}
pub type EOS_Auth_DeletePersistentAuthCallbackInfo = _tagEOS_Auth_DeletePersistentAuthCallbackInfo;
pub type EOS_Auth_OnDeletePersistentAuthCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Auth_DeletePersistentAuthCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Auth_LoginStatusChangedCallbackInfo {
    #[doc = " Context that was passed into EOS_Auth_AddNotifyLoginStatusChanged"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Account ID of the local user whose status has changed"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The status prior to the change"]
    pub PrevStatus: EOS_ELoginStatus,
    #[doc = " The status at the time of the notification"]
    pub CurrentStatus: EOS_ELoginStatus,
}
#[test]
fn bindgen_test_layout__tagEOS_Auth_LoginStatusChangedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Auth_LoginStatusChangedCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Auth_LoginStatusChangedCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Auth_LoginStatusChangedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Auth_LoginStatusChangedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Auth_LoginStatusChangedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LoginStatusChangedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LoginStatusChangedCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PrevStatus) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LoginStatusChangedCallbackInfo),
            "::",
            stringify!(PrevStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurrentStatus) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Auth_LoginStatusChangedCallbackInfo),
            "::",
            stringify!(CurrentStatus)
        )
    );
}
pub type EOS_Auth_LoginStatusChangedCallbackInfo = _tagEOS_Auth_LoginStatusChangedCallbackInfo;
pub type EOS_Auth_OnLoginStatusChangedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Auth_LoginStatusChangedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_EcomHandle {
    _unused: [u8; 0],
}
pub type EOS_HEcom = *mut EOS_EcomHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_Ecom_TransactionHandle {
    _unused: [u8; 0],
}
#[doc = " This handle is copied when EOS_Ecom_CopyTransactionById or EOS_Ecom_CopyTransactionByIndex is called.\n A EOS_Ecom_CheckoutCallbackInfo provides the ID for the copy.\n After being copied, EOS_Ecom_Transaction_Release must be called.\n\n @see EOS_Ecom_CheckoutCallbackInfo\n @see EOS_Ecom_CopyTransactionById\n @see EOS_Ecom_CopyTransactionByIndex\n @see EOS_Ecom_Transaction_Release"]
pub type EOS_Ecom_HTransaction = *mut EOS_Ecom_TransactionHandle;
#[doc = " A unique identifier for a catalog item defined and stored with the backend catalog service.\n A catalog item represents a distinct object within the catalog.  When acquired by an account, an\n entitlement is granted that references a specific catalog item."]
pub type EOS_Ecom_CatalogItemId = *const ::std::os::raw::c_char;
#[doc = " A unique identifier for a catalog offer defined and stored with the backend catalog service.\n A catalog offer is a purchasable collection of 1 or more items, associated with a price (which\n could be 0).  When an offer is purchased an entitlement is granted for each of the items\n referenced by the offer."]
pub type EOS_Ecom_CatalogOfferId = *const ::std::os::raw::c_char;
#[doc = " An identifier which is defined on a catalog item and stored with the backend catalog service.\n The entitlement name may not be unique.  A catalog may be configured with multiple items with the\n same entitlement name in order to define a logical grouping of entitlements.  This is used to\n retrieve all entitlements granted to an account grouped in this way.\n\n @see EOS_Ecom_QueryEntitlements"]
pub type EOS_Ecom_EntitlementName = *const ::std::os::raw::c_char;
#[doc = " A unique identifier for an entitlement owned by an account.  An entitlement is always associated\n with a single account.  The entitlement ID is provided to allow redeeming the entitlement as\n well as identify individual entitlement grants.\n\n @see EOS_Ecom_QueryEntitlements\n @see EOS_Ecom_RedeemEntitlements"]
pub type EOS_Ecom_EntitlementId = *const ::std::os::raw::c_char;
#[doc = " A unique identifier for the Sandbox.\n\n @see EOS_Ecom_QueryOwnershipBySandboxIds"]
pub type EOS_Ecom_SandboxId = *const ::std::os::raw::c_char;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EOwnershipStatus {
    #[doc = " The catalog item is not owned by the local user"]
    EOS_OS_NotOwned = 0,
    #[doc = " The catalog item is owned by the local user"]
    EOS_OS_Owned = 1,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EEcomItemType {
    #[doc = " This entitlement is intended to persist."]
    EOS_EIT_Durable = 0,
    #[doc = " This entitlement is intended to be transient and redeemed.\n\n @see EOS_Ecom_RedeemEntitlements"]
    EOS_EIT_Consumable = 1,
    #[doc = " This entitlement has a type that is not currently intended for an in-game store."]
    EOS_EIT_Other = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_Entitlement {
    #[doc = " API Version: Set this to EOS_ECOM_ENTITLEMENT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Name of the entitlement"]
    pub EntitlementName: EOS_Ecom_EntitlementName,
    #[doc = " ID of the entitlement owned by an account"]
    pub EntitlementId: EOS_Ecom_EntitlementId,
    #[doc = " ID of the item associated with the offer which granted this entitlement"]
    pub CatalogItemId: EOS_Ecom_CatalogItemId,
    #[doc = " If queried using pagination then ServerIndex represents the index of the entitlement as it\n exists on the server.  If not queried using pagination then ServerIndex will be -1."]
    pub ServerIndex: i32,
    #[doc = " If true then the catalog has this entitlement marked as redeemed"]
    pub bRedeemed: EOS_Bool,
    #[doc = " If not -1 then this is a POSIX timestamp that this entitlement will end"]
    pub EndTimestamp: i64,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_Entitlement() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_Entitlement> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_Entitlement>(),
        48usize,
        concat!("Size of: ", stringify!(_tagEOS_Ecom_Entitlement))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_Entitlement>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Ecom_Entitlement))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_Entitlement),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EntitlementName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_Entitlement),
            "::",
            stringify!(EntitlementName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EntitlementId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_Entitlement),
            "::",
            stringify!(EntitlementId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CatalogItemId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_Entitlement),
            "::",
            stringify!(CatalogItemId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ServerIndex) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_Entitlement),
            "::",
            stringify!(ServerIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bRedeemed) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_Entitlement),
            "::",
            stringify!(bRedeemed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndTimestamp) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_Entitlement),
            "::",
            stringify!(EndTimestamp)
        )
    );
}
pub type EOS_Ecom_Entitlement = _tagEOS_Ecom_Entitlement;
extern "C" {
    #[doc = " Release the memory associated with an EOS_Ecom_Entitlement structure. This must be called on data\n retrieved from EOS_Ecom_CopyEntitlementByIndex and EOS_Ecom_CopyEntitlementById.\n\n @param Entitlement - The entitlement structure to be released\n\n @see EOS_Ecom_Entitlement\n @see EOS_Ecom_CopyEntitlementByIndex\n @see EOS_Ecom_CopyEntitlementById"]
    pub fn EOS_Ecom_Entitlement_Release(Entitlement: *mut EOS_Ecom_Entitlement);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_ItemOwnership {
    #[doc = " API Version: Set this to EOS_ECOM_ITEMOWNERSHIP_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " ID of the catalog item"]
    pub Id: EOS_Ecom_CatalogItemId,
    #[doc = " Is this catalog item owned by the local user"]
    pub OwnershipStatus: EOS_EOwnershipStatus,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_ItemOwnership() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_ItemOwnership> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_ItemOwnership>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Ecom_ItemOwnership))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_ItemOwnership>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Ecom_ItemOwnership))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_ItemOwnership),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_ItemOwnership),
            "::",
            stringify!(Id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OwnershipStatus) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_ItemOwnership),
            "::",
            stringify!(OwnershipStatus)
        )
    );
}
pub type EOS_Ecom_ItemOwnership = _tagEOS_Ecom_ItemOwnership;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_CatalogItem {
    #[doc = " API Version: Set this to EOS_ECOM_CATALOGITEM_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Product namespace in which this item exists"]
    pub CatalogNamespace: *const ::std::os::raw::c_char,
    #[doc = " The ID of this item"]
    pub Id: EOS_Ecom_CatalogItemId,
    #[doc = " The entitlement name associated with this item"]
    pub EntitlementName: EOS_Ecom_EntitlementName,
    #[doc = " Localized UTF-8 title of this item"]
    pub TitleText: *const ::std::os::raw::c_char,
    #[doc = " Localized UTF-8 description of this item"]
    pub DescriptionText: *const ::std::os::raw::c_char,
    #[doc = " Localized UTF-8 long description of this item"]
    pub LongDescriptionText: *const ::std::os::raw::c_char,
    #[doc = " Localized UTF-8 technical details of this item"]
    pub TechnicalDetailsText: *const ::std::os::raw::c_char,
    #[doc = " Localized UTF-8 developer of this item"]
    pub DeveloperText: *const ::std::os::raw::c_char,
    #[doc = " The type of item as defined in the catalog"]
    pub ItemType: EOS_EEcomItemType,
    #[doc = " If not -1 then this is the POSIX timestamp that the entitlement will end"]
    pub EntitlementEndTimestamp: i64,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_CatalogItem() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_CatalogItem> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_CatalogItem>(),
        88usize,
        concat!("Size of: ", stringify!(_tagEOS_Ecom_CatalogItem))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_CatalogItem>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Ecom_CatalogItem))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogItem),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CatalogNamespace) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogItem),
            "::",
            stringify!(CatalogNamespace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogItem),
            "::",
            stringify!(Id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EntitlementName) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogItem),
            "::",
            stringify!(EntitlementName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TitleText) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogItem),
            "::",
            stringify!(TitleText)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DescriptionText) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogItem),
            "::",
            stringify!(DescriptionText)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LongDescriptionText) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogItem),
            "::",
            stringify!(LongDescriptionText)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TechnicalDetailsText) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogItem),
            "::",
            stringify!(TechnicalDetailsText)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DeveloperText) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogItem),
            "::",
            stringify!(DeveloperText)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ItemType) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogItem),
            "::",
            stringify!(ItemType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EntitlementEndTimestamp) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogItem),
            "::",
            stringify!(EntitlementEndTimestamp)
        )
    );
}
pub type EOS_Ecom_CatalogItem = _tagEOS_Ecom_CatalogItem;
extern "C" {
    #[doc = " Release the memory associated with an EOS_Ecom_CatalogItem structure. This must be called on data\n retrieved from EOS_Ecom_CopyOfferItemByIndex.\n\n @param CatalogItem - The catalog item structure to be released\n\n @see EOS_Ecom_CatalogItem\n @see EOS_Ecom_CopyOfferItemByIndex"]
    pub fn EOS_Ecom_CatalogItem_Release(CatalogItem: *mut EOS_Ecom_CatalogItem);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_CatalogOffer {
    #[doc = " API Version: Set this to EOS_ECOM_CATALOGOFFER_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The index of this offer as it exists on the server.\n This is useful for understanding pagination data."]
    pub ServerIndex: i32,
    #[doc = " Product namespace in which this offer exists"]
    pub CatalogNamespace: *const ::std::os::raw::c_char,
    #[doc = " The ID of this offer"]
    pub Id: EOS_Ecom_CatalogOfferId,
    #[doc = " Localized UTF-8 title of this offer"]
    pub TitleText: *const ::std::os::raw::c_char,
    #[doc = " Localized UTF-8 description of this offer"]
    pub DescriptionText: *const ::std::os::raw::c_char,
    #[doc = " Localized UTF-8 long description of this offer"]
    pub LongDescriptionText: *const ::std::os::raw::c_char,
    #[doc = " Deprecated.\n EOS_Ecom_CatalogItem::TechnicalDetailsText is still valid."]
    pub TechnicalDetailsText_DEPRECATED: *const ::std::os::raw::c_char,
    #[doc = " The Currency Code for this offer"]
    pub CurrencyCode: *const ::std::os::raw::c_char,
    #[doc = " If this value is EOS_Success then OriginalPrice, CurrentPrice, and DiscountPercentage contain valid data.\n Otherwise this value represents the error that occurred on the price query."]
    pub PriceResult: EOS_EResult,
    #[doc = " The original price of this offer as a 32-bit number is deprecated."]
    pub OriginalPrice_DEPRECATED: u32,
    #[doc = " The current price including discounts of this offer as a 32-bit number is deprecated.."]
    pub CurrentPrice_DEPRECATED: u32,
    #[doc = " A value from 0 to 100 define the percentage of the OrignalPrice that the CurrentPrice represents"]
    pub DiscountPercentage: u8,
    #[doc = " Contains the POSIX timestamp that the offer expires or -1 if it does not expire"]
    pub ExpirationTimestamp: i64,
    #[doc = " The number of times that the requesting account has purchased this offer.\n This value is deprecated and the backend no longer returns this value."]
    pub PurchasedCount_DEPRECATED: u32,
    #[doc = " The maximum number of times that the offer can be purchased.\n A negative value implies there is no limit."]
    pub PurchaseLimit: i32,
    #[doc = " True if the user can purchase this offer."]
    pub bAvailableForPurchase: EOS_Bool,
    #[doc = " The original price of this offer as a 64-bit number."]
    pub OriginalPrice64: u64,
    #[doc = " The current price including discounts of this offer as a 64-bit number."]
    pub CurrentPrice64: u64,
    #[doc = " The decimal point for the provided price.  For example, DecimalPoint '2' and CurrentPrice64 '12345' would be '123.45'."]
    pub DecimalPoint: u32,
    #[doc = " Timestamp indicating when the time when the offer was released. Can be ignored if set to -1."]
    pub ReleaseDateTimestamp: i64,
    #[doc = " Timestamp indicating the effective date of the offer. Can be ignored if set to -1."]
    pub EffectiveDateTimestamp: i64,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_CatalogOffer() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_CatalogOffer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_CatalogOffer>(),
        144usize,
        concat!("Size of: ", stringify!(_tagEOS_Ecom_CatalogOffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_CatalogOffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Ecom_CatalogOffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogOffer),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ServerIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogOffer),
            "::",
            stringify!(ServerIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CatalogNamespace) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogOffer),
            "::",
            stringify!(CatalogNamespace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogOffer),
            "::",
            stringify!(Id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TitleText) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogOffer),
            "::",
            stringify!(TitleText)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DescriptionText) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogOffer),
            "::",
            stringify!(DescriptionText)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LongDescriptionText) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogOffer),
            "::",
            stringify!(LongDescriptionText)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).TechnicalDetailsText_DEPRECATED) as usize - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogOffer),
            "::",
            stringify!(TechnicalDetailsText_DEPRECATED)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurrencyCode) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogOffer),
            "::",
            stringify!(CurrencyCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PriceResult) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogOffer),
            "::",
            stringify!(PriceResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OriginalPrice_DEPRECATED) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogOffer),
            "::",
            stringify!(OriginalPrice_DEPRECATED)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurrentPrice_DEPRECATED) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogOffer),
            "::",
            stringify!(CurrentPrice_DEPRECATED)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DiscountPercentage) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogOffer),
            "::",
            stringify!(DiscountPercentage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExpirationTimestamp) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogOffer),
            "::",
            stringify!(ExpirationTimestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PurchasedCount_DEPRECATED) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogOffer),
            "::",
            stringify!(PurchasedCount_DEPRECATED)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PurchaseLimit) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogOffer),
            "::",
            stringify!(PurchaseLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bAvailableForPurchase) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogOffer),
            "::",
            stringify!(bAvailableForPurchase)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OriginalPrice64) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogOffer),
            "::",
            stringify!(OriginalPrice64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurrentPrice64) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogOffer),
            "::",
            stringify!(CurrentPrice64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DecimalPoint) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogOffer),
            "::",
            stringify!(DecimalPoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseDateTimestamp) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogOffer),
            "::",
            stringify!(ReleaseDateTimestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EffectiveDateTimestamp) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogOffer),
            "::",
            stringify!(EffectiveDateTimestamp)
        )
    );
}
pub type EOS_Ecom_CatalogOffer = _tagEOS_Ecom_CatalogOffer;
extern "C" {
    #[doc = " Release the memory associated with an EOS_Ecom_CatalogOffer structure. This must be called on data\n retrieved from EOS_Ecom_CopyOfferByIndex.\n\n @param CatalogOffer - The catalog offer structure to be released\n\n @see EOS_Ecom_CatalogOffer\n @see EOS_Ecom_CopyOfferByIndex"]
    pub fn EOS_Ecom_CatalogOffer_Release(CatalogOffer: *mut EOS_Ecom_CatalogOffer);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_KeyImageInfo {
    #[doc = " API Version: Set this to EOS_ECOM_KEYIMAGEINFO_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Describes the usage of the image (ex: home_thumbnail)"]
    pub Type: *const ::std::os::raw::c_char,
    #[doc = " The URL of the image"]
    pub Url: *const ::std::os::raw::c_char,
    #[doc = " The expected width in pixels of the image"]
    pub Width: u32,
    #[doc = " The expected height in pixels of the image"]
    pub Height: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_KeyImageInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_KeyImageInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_KeyImageInfo>(),
        32usize,
        concat!("Size of: ", stringify!(_tagEOS_Ecom_KeyImageInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_KeyImageInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Ecom_KeyImageInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_KeyImageInfo),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_KeyImageInfo),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Url) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_KeyImageInfo),
            "::",
            stringify!(Url)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Width) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_KeyImageInfo),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Height) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_KeyImageInfo),
            "::",
            stringify!(Height)
        )
    );
}
pub type EOS_Ecom_KeyImageInfo = _tagEOS_Ecom_KeyImageInfo;
extern "C" {
    #[doc = " Release the memory associated with an EOS_Ecom_KeyImageInfo structure. This must be called on data\n retrieved from EOS_Ecom_CopyItemImageInfoByIndex.\n\n @param KeyImageInfo - The key image info structure to be released\n\n @see EOS_Ecom_KeyImageInfo\n @see EOS_Ecom_CopyItemImageInfoByIndex"]
    pub fn EOS_Ecom_KeyImageInfo_Release(KeyImageInfo: *mut EOS_Ecom_KeyImageInfo);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_CatalogRelease {
    #[doc = " API Version: Set this to EOS_ECOM_CATALOGRELEASE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The number of APP IDs"]
    pub CompatibleAppIdCount: u32,
    #[doc = " A list of compatible APP IDs"]
    pub CompatibleAppIds: *mut *const ::std::os::raw::c_char,
    #[doc = " The number of platforms"]
    pub CompatiblePlatformCount: u32,
    #[doc = " A list of compatible Platforms"]
    pub CompatiblePlatforms: *mut *const ::std::os::raw::c_char,
    #[doc = " Release note for compatible versions"]
    pub ReleaseNote: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_CatalogRelease() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_CatalogRelease> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_CatalogRelease>(),
        40usize,
        concat!("Size of: ", stringify!(_tagEOS_Ecom_CatalogRelease))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_CatalogRelease>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Ecom_CatalogRelease))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogRelease),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CompatibleAppIdCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogRelease),
            "::",
            stringify!(CompatibleAppIdCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CompatibleAppIds) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogRelease),
            "::",
            stringify!(CompatibleAppIds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CompatiblePlatformCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogRelease),
            "::",
            stringify!(CompatiblePlatformCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CompatiblePlatforms) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogRelease),
            "::",
            stringify!(CompatiblePlatforms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseNote) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CatalogRelease),
            "::",
            stringify!(ReleaseNote)
        )
    );
}
pub type EOS_Ecom_CatalogRelease = _tagEOS_Ecom_CatalogRelease;
extern "C" {
    #[doc = " Release the memory associated with an EOS_Ecom_CatalogRelease structure. This must be called on\n data retrieved from EOS_Ecom_CopyItemReleaseByIndex.\n\n @param CatalogRelease - The catalog release structure to be released\n\n @see EOS_Ecom_CatalogRelease\n @see EOS_Ecom_CopyItemReleaseByIndex"]
    pub fn EOS_Ecom_CatalogRelease_Release(CatalogRelease: *mut EOS_Ecom_CatalogRelease);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_CheckoutEntry {
    #[doc = " API Version: Set this to EOS_ECOM_CHECKOUTENTRY_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The ID of the offer to purchase"]
    pub OfferId: EOS_Ecom_CatalogOfferId,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_CheckoutEntry() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_CheckoutEntry> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_CheckoutEntry>(),
        16usize,
        concat!("Size of: ", stringify!(_tagEOS_Ecom_CheckoutEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_CheckoutEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Ecom_CheckoutEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CheckoutEntry),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OfferId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CheckoutEntry),
            "::",
            stringify!(OfferId)
        )
    );
}
pub type EOS_Ecom_CheckoutEntry = _tagEOS_Ecom_CheckoutEntry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_QueryOwnershipOptions {
    #[doc = " API Version: Set this to EOS_ECOM_QUERYOWNERSHIP_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user whose ownership to query"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The array of Catalog Item IDs to check for ownership"]
    pub CatalogItemIds: *mut EOS_Ecom_CatalogItemId,
    #[doc = " The number of Catalog Item IDs to in the array"]
    pub CatalogItemIdCount: u32,
    #[doc = " Optional product namespace, if not the one specified during initialization"]
    pub CatalogNamespace: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_QueryOwnershipOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_QueryOwnershipOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_QueryOwnershipOptions>(),
        40usize,
        concat!("Size of: ", stringify!(_tagEOS_Ecom_QueryOwnershipOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_QueryOwnershipOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_QueryOwnershipOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CatalogItemIds) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipOptions),
            "::",
            stringify!(CatalogItemIds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CatalogItemIdCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipOptions),
            "::",
            stringify!(CatalogItemIdCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CatalogNamespace) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipOptions),
            "::",
            stringify!(CatalogNamespace)
        )
    );
}
pub type EOS_Ecom_QueryOwnershipOptions = _tagEOS_Ecom_QueryOwnershipOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_QueryOwnershipCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Ecom_QueryOwnership"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Account ID of the local user whose ownership was queried"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " List of catalog items and their ownership status"]
    pub ItemOwnership: *const EOS_Ecom_ItemOwnership,
    #[doc = " Number of ownership results are included in this callback"]
    pub ItemOwnershipCount: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_QueryOwnershipCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_QueryOwnershipCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_QueryOwnershipCallbackInfo>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_QueryOwnershipCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_QueryOwnershipCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ItemOwnership) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipCallbackInfo),
            "::",
            stringify!(ItemOwnership)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ItemOwnershipCount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipCallbackInfo),
            "::",
            stringify!(ItemOwnershipCount)
        )
    );
}
pub type EOS_Ecom_QueryOwnershipCallbackInfo = _tagEOS_Ecom_QueryOwnershipCallbackInfo;
pub type EOS_Ecom_OnQueryOwnershipCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Ecom_QueryOwnershipCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_QueryOwnershipBySandboxIdsOptions {
    #[doc = " API Version: Set this to EOS_ECOM_QUERYOWNERSHIPBYSANDBOXIDSOPTIONS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user whose ownership to query."]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The array of Sandbox IDs to check for ownership."]
    pub SandboxIds: *mut EOS_Ecom_SandboxId,
    #[doc = " The number of Sandbox IDs in the query."]
    pub SandboxIdsCount: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_QueryOwnershipBySandboxIdsOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_QueryOwnershipBySandboxIdsOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_QueryOwnershipBySandboxIdsOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipBySandboxIdsOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_QueryOwnershipBySandboxIdsOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_QueryOwnershipBySandboxIdsOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipBySandboxIdsOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipBySandboxIdsOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SandboxIds) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipBySandboxIdsOptions),
            "::",
            stringify!(SandboxIds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SandboxIdsCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipBySandboxIdsOptions),
            "::",
            stringify!(SandboxIdsCount)
        )
    );
}
pub type EOS_Ecom_QueryOwnershipBySandboxIdsOptions =
    _tagEOS_Ecom_QueryOwnershipBySandboxIdsOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_SandboxIdItemOwnership {
    #[doc = " SandboxId"]
    pub SandboxId: EOS_Ecom_SandboxId,
    #[doc = " List of all owned catalog items for this SandboxId"]
    pub OwnedCatalogItemIds: *const EOS_Ecom_CatalogItemId,
    #[doc = " Number of owned catalog items for this SandboxId"]
    pub OwnedCatalogItemIdsCount: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_SandboxIdItemOwnership() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_SandboxIdItemOwnership> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_SandboxIdItemOwnership>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Ecom_SandboxIdItemOwnership))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_SandboxIdItemOwnership>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_SandboxIdItemOwnership)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SandboxId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_SandboxIdItemOwnership),
            "::",
            stringify!(SandboxId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OwnedCatalogItemIds) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_SandboxIdItemOwnership),
            "::",
            stringify!(OwnedCatalogItemIds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OwnedCatalogItemIdsCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_SandboxIdItemOwnership),
            "::",
            stringify!(OwnedCatalogItemIdsCount)
        )
    );
}
pub type EOS_Ecom_SandboxIdItemOwnership = _tagEOS_Ecom_SandboxIdItemOwnership;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_QueryOwnershipBySandboxIdsCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Ecom_QueryOwnership"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Account ID of the local user whose ownership was queried"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " List of SandboxIds and their corresponding owned catalog item Ids. If there are no ownership items, the OwnedCatalogItemIdsCount is 0 and OwnedCatalogItemIds is null."]
    pub SandboxIdItemOwnerships: *const EOS_Ecom_SandboxIdItemOwnership,
    #[doc = " Number of ownership results are included in this callback"]
    pub SandboxIdItemOwnershipsCount: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_QueryOwnershipBySandboxIdsCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_QueryOwnershipBySandboxIdsCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_QueryOwnershipBySandboxIdsCallbackInfo>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipBySandboxIdsCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_QueryOwnershipBySandboxIdsCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_QueryOwnershipBySandboxIdsCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipBySandboxIdsCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipBySandboxIdsCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipBySandboxIdsCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SandboxIdItemOwnerships) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipBySandboxIdsCallbackInfo),
            "::",
            stringify!(SandboxIdItemOwnerships)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).SandboxIdItemOwnershipsCount) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipBySandboxIdsCallbackInfo),
            "::",
            stringify!(SandboxIdItemOwnershipsCount)
        )
    );
}
pub type EOS_Ecom_QueryOwnershipBySandboxIdsCallbackInfo =
    _tagEOS_Ecom_QueryOwnershipBySandboxIdsCallbackInfo;
pub type EOS_Ecom_OnQueryOwnershipBySandboxIdsCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Ecom_QueryOwnershipBySandboxIdsCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_QueryOwnershipTokenOptions {
    #[doc = " API Version: Set this to EOS_ECOM_QUERYOWNERSHIPTOKEN_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user whose ownership token you want to query"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The array of Catalog Item IDs to check for ownership, matching in number to the CatalogItemIdCount"]
    pub CatalogItemIds: *mut EOS_Ecom_CatalogItemId,
    #[doc = " The number of catalog item IDs to query"]
    pub CatalogItemIdCount: u32,
    #[doc = " Optional product namespace, if not the one specified during initialization"]
    pub CatalogNamespace: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_QueryOwnershipTokenOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_QueryOwnershipTokenOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_QueryOwnershipTokenOptions>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipTokenOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_QueryOwnershipTokenOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_QueryOwnershipTokenOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipTokenOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipTokenOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CatalogItemIds) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipTokenOptions),
            "::",
            stringify!(CatalogItemIds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CatalogItemIdCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipTokenOptions),
            "::",
            stringify!(CatalogItemIdCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CatalogNamespace) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipTokenOptions),
            "::",
            stringify!(CatalogNamespace)
        )
    );
}
pub type EOS_Ecom_QueryOwnershipTokenOptions = _tagEOS_Ecom_QueryOwnershipTokenOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_QueryOwnershipTokenCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Ecom_QueryOwnershipToken"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Account ID of the local user whose ownership token was queried"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " Ownership token containing details about the catalog items queried"]
    pub OwnershipToken: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_QueryOwnershipTokenCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_QueryOwnershipTokenCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_QueryOwnershipTokenCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipTokenCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_QueryOwnershipTokenCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_QueryOwnershipTokenCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipTokenCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipTokenCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipTokenCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OwnershipToken) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOwnershipTokenCallbackInfo),
            "::",
            stringify!(OwnershipToken)
        )
    );
}
pub type EOS_Ecom_QueryOwnershipTokenCallbackInfo = _tagEOS_Ecom_QueryOwnershipTokenCallbackInfo;
pub type EOS_Ecom_OnQueryOwnershipTokenCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Ecom_QueryOwnershipTokenCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_QueryEntitlementsOptions {
    #[doc = " API Version: Set this to EOS_ECOM_QUERYENTITLEMENTS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user whose Entitlements you want to retrieve"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " An array of Entitlement Names that you want to check"]
    pub EntitlementNames: *mut EOS_Ecom_EntitlementName,
    #[doc = " The number of Entitlement Names included in the array, up to EOS_ECOM_QUERYENTITLEMENTS_MAX_ENTITLEMENT_IDS; use zero to request all Entitlements associated with the user's Epic Online Services account."]
    pub EntitlementNameCount: u32,
    #[doc = " If true, Entitlements that have been redeemed will be included in the results."]
    pub bIncludeRedeemed: EOS_Bool,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_QueryEntitlementsOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_QueryEntitlementsOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_QueryEntitlementsOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_QueryEntitlementsOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_QueryEntitlementsOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_QueryEntitlementsOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryEntitlementsOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryEntitlementsOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EntitlementNames) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryEntitlementsOptions),
            "::",
            stringify!(EntitlementNames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EntitlementNameCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryEntitlementsOptions),
            "::",
            stringify!(EntitlementNameCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIncludeRedeemed) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryEntitlementsOptions),
            "::",
            stringify!(bIncludeRedeemed)
        )
    );
}
pub type EOS_Ecom_QueryEntitlementsOptions = _tagEOS_Ecom_QueryEntitlementsOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_QueryEntitlementsCallbackInfo {
    #[doc = " Output parameters for the EOS_Ecom_QueryEntitlements Function."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Ecom_QueryEntitlements"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Account ID of the local user whose entitlement was queried"]
    pub LocalUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_QueryEntitlementsCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_QueryEntitlementsCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_QueryEntitlementsCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_QueryEntitlementsCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_QueryEntitlementsCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_QueryEntitlementsCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryEntitlementsCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryEntitlementsCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryEntitlementsCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Ecom_QueryEntitlementsCallbackInfo = _tagEOS_Ecom_QueryEntitlementsCallbackInfo;
pub type EOS_Ecom_OnQueryEntitlementsCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Ecom_QueryEntitlementsCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_QueryEntitlementTokenOptions {
    #[doc = " API Version: Set this to EOS_ECOM_QUERYENTITLEMENTTOKEN_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user whose Entitlements you want to retrieve"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " An array of Entitlement Names that you want to check"]
    pub EntitlementNames: *mut EOS_Ecom_EntitlementName,
    #[doc = " The number of Entitlement Names included in the array, up to EOS_ECOM_QUERYENTITLEMENTTOKEN_MAX_ENTITLEMENT_IDS; use zero to request all Entitlements associated with the user's Epic Online Services account."]
    pub EntitlementNameCount: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_QueryEntitlementTokenOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_QueryEntitlementTokenOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_QueryEntitlementTokenOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_QueryEntitlementTokenOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_QueryEntitlementTokenOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_QueryEntitlementTokenOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryEntitlementTokenOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryEntitlementTokenOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EntitlementNames) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryEntitlementTokenOptions),
            "::",
            stringify!(EntitlementNames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EntitlementNameCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryEntitlementTokenOptions),
            "::",
            stringify!(EntitlementNameCount)
        )
    );
}
pub type EOS_Ecom_QueryEntitlementTokenOptions = _tagEOS_Ecom_QueryEntitlementTokenOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_QueryEntitlementTokenCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Ecom_QueryEntitlementToken"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Account ID of the local user whose entitlement was queried"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " Entitlements token containing details about the catalog items queried"]
    pub EntitlementToken: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_QueryEntitlementTokenCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_QueryEntitlementTokenCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_QueryEntitlementTokenCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_QueryEntitlementTokenCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_QueryEntitlementTokenCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_QueryEntitlementTokenCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryEntitlementTokenCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryEntitlementTokenCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryEntitlementTokenCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EntitlementToken) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryEntitlementTokenCallbackInfo),
            "::",
            stringify!(EntitlementToken)
        )
    );
}
pub type EOS_Ecom_QueryEntitlementTokenCallbackInfo =
    _tagEOS_Ecom_QueryEntitlementTokenCallbackInfo;
pub type EOS_Ecom_OnQueryEntitlementTokenCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Ecom_QueryEntitlementTokenCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_QueryOffersOptions {
    #[doc = " API Version: Set this to EOS_ECOM_QUERYOFFERS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user whose offer to query"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " If not provided then the SandboxId is used as the catalog namespace"]
    pub OverrideCatalogNamespace: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_QueryOffersOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_QueryOffersOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_QueryOffersOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Ecom_QueryOffersOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_QueryOffersOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Ecom_QueryOffersOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOffersOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOffersOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OverrideCatalogNamespace) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOffersOptions),
            "::",
            stringify!(OverrideCatalogNamespace)
        )
    );
}
pub type EOS_Ecom_QueryOffersOptions = _tagEOS_Ecom_QueryOffersOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_QueryOffersCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Ecom_QueryOffers"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Account ID of the local user whose offer was queried; needed for localization of Catalog Item (Item) description text and pricing information"]
    pub LocalUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_QueryOffersCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_QueryOffersCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_QueryOffersCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_QueryOffersCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_QueryOffersCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_QueryOffersCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOffersCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOffersCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_QueryOffersCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Ecom_QueryOffersCallbackInfo = _tagEOS_Ecom_QueryOffersCallbackInfo;
pub type EOS_Ecom_OnQueryOffersCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Ecom_QueryOffersCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_CheckoutOptions {
    #[doc = " API Version: Set this to EOS_ECOM_CHECKOUT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user who is making the purchase"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The catalog namespace will be the current Sandbox ID (in EOS_Platform_Options) unless overridden by this field"]
    pub OverrideCatalogNamespace: *const ::std::os::raw::c_char,
    #[doc = " The number of EOS_Ecom_CheckoutEntry elements contained in Entries"]
    pub EntryCount: u32,
    #[doc = " An array of EOS_Ecom_CheckoutEntry elements, each containing the details of a single offer"]
    pub Entries: *const EOS_Ecom_CheckoutEntry,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_CheckoutOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_CheckoutOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_CheckoutOptions>(),
        40usize,
        concat!("Size of: ", stringify!(_tagEOS_Ecom_CheckoutOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_CheckoutOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Ecom_CheckoutOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CheckoutOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CheckoutOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OverrideCatalogNamespace) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CheckoutOptions),
            "::",
            stringify!(OverrideCatalogNamespace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EntryCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CheckoutOptions),
            "::",
            stringify!(EntryCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Entries) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CheckoutOptions),
            "::",
            stringify!(Entries)
        )
    );
}
pub type EOS_Ecom_CheckoutOptions = _tagEOS_Ecom_CheckoutOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_CheckoutCallbackInfo {
    #[doc = " Result code for the operation. EOS_Success is returned for a successful request, otherwise one of the error codes is returned. See eos_common.h"]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Ecom_Checkout"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Account ID of the user who initiated the purchase"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The transaction ID which can be used to obtain an EOS_Ecom_HTransaction using EOS_Ecom_CopyTransactionById."]
    pub TransactionId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_CheckoutCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_CheckoutCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_CheckoutCallbackInfo>(),
        32usize,
        concat!("Size of: ", stringify!(_tagEOS_Ecom_CheckoutCallbackInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_CheckoutCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_CheckoutCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CheckoutCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CheckoutCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CheckoutCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TransactionId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CheckoutCallbackInfo),
            "::",
            stringify!(TransactionId)
        )
    );
}
pub type EOS_Ecom_CheckoutCallbackInfo = _tagEOS_Ecom_CheckoutCallbackInfo;
pub type EOS_Ecom_OnCheckoutCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Ecom_CheckoutCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_RedeemEntitlementsOptions {
    #[doc = " API Version: Set this to EOS_ECOM_REDEEMENTITLEMENTS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the user who is redeeming Entitlements"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The number of Entitlements to redeem"]
    pub EntitlementIdCount: u32,
    #[doc = " The array of Entitlements to redeem"]
    pub EntitlementIds: *mut EOS_Ecom_EntitlementId,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_RedeemEntitlementsOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_RedeemEntitlementsOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_RedeemEntitlementsOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_RedeemEntitlementsOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_RedeemEntitlementsOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_RedeemEntitlementsOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_RedeemEntitlementsOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_RedeemEntitlementsOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EntitlementIdCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_RedeemEntitlementsOptions),
            "::",
            stringify!(EntitlementIdCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EntitlementIds) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_RedeemEntitlementsOptions),
            "::",
            stringify!(EntitlementIds)
        )
    );
}
pub type EOS_Ecom_RedeemEntitlementsOptions = _tagEOS_Ecom_RedeemEntitlementsOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_RedeemEntitlementsCallbackInfo {
    #[doc = " Result code for the operation. EOS_Success is returned for a successful request, otherwise one of the error codes is returned. See eos_common.h"]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Ecom_RedeemEntitlements"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Account ID of the user who has redeemed entitlements"]
    pub LocalUserId: EOS_EpicAccountId,
    pub RedeemedEntitlementIdsCount: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_RedeemEntitlementsCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_RedeemEntitlementsCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_RedeemEntitlementsCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_RedeemEntitlementsCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_RedeemEntitlementsCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_RedeemEntitlementsCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_RedeemEntitlementsCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_RedeemEntitlementsCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_RedeemEntitlementsCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RedeemedEntitlementIdsCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_RedeemEntitlementsCallbackInfo),
            "::",
            stringify!(RedeemedEntitlementIdsCount)
        )
    );
}
pub type EOS_Ecom_RedeemEntitlementsCallbackInfo = _tagEOS_Ecom_RedeemEntitlementsCallbackInfo;
pub type EOS_Ecom_OnRedeemEntitlementsCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Ecom_RedeemEntitlementsCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_GetLastRedeemedEntitlementsCountOptions {
    #[doc = " API Version: Set this to EOS_ECOM_GETLASTREDEEMEDENTITLEMENTSCOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user for who to retrieve the last redeemed entitlements count"]
    pub LocalUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_GetLastRedeemedEntitlementsCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_GetLastRedeemedEntitlementsCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_GetLastRedeemedEntitlementsCountOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_GetLastRedeemedEntitlementsCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_GetLastRedeemedEntitlementsCountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_GetLastRedeemedEntitlementsCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_GetLastRedeemedEntitlementsCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_GetLastRedeemedEntitlementsCountOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Ecom_GetLastRedeemedEntitlementsCountOptions =
    _tagEOS_Ecom_GetLastRedeemedEntitlementsCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_CopyLastRedeemedEntitlementByIndexOptions {
    #[doc = " API Version: Set this to EOS_ECOM_COPYLASTREDEEMEDENTITLEMENTBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user whose last redeemed entitlement id is being copied"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " Index of the last redeemed entitlement id to retrieve from the cache"]
    pub RedeemedEntitlementIndex: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_CopyLastRedeemedEntitlementByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_CopyLastRedeemedEntitlementByIndexOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_CopyLastRedeemedEntitlementByIndexOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_CopyLastRedeemedEntitlementByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_CopyLastRedeemedEntitlementByIndexOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_CopyLastRedeemedEntitlementByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyLastRedeemedEntitlementByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyLastRedeemedEntitlementByIndexOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RedeemedEntitlementIndex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyLastRedeemedEntitlementByIndexOptions),
            "::",
            stringify!(RedeemedEntitlementIndex)
        )
    );
}
pub type EOS_Ecom_CopyLastRedeemedEntitlementByIndexOptions =
    _tagEOS_Ecom_CopyLastRedeemedEntitlementByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_GetEntitlementsCountOptions {
    #[doc = " API Version: Set this to EOS_ECOM_GETENTITLEMENTSCOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user for which to retrieve the entitlement count"]
    pub LocalUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_GetEntitlementsCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_GetEntitlementsCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_GetEntitlementsCountOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_GetEntitlementsCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_GetEntitlementsCountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_GetEntitlementsCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_GetEntitlementsCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_GetEntitlementsCountOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Ecom_GetEntitlementsCountOptions = _tagEOS_Ecom_GetEntitlementsCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_GetEntitlementsByNameCountOptions {
    #[doc = " API Version: Set this to EOS_ECOM_GETENTITLEMENTSBYNAMECOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user for which to retrieve the entitlement count"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " Name of the entitlement to count in the cache"]
    pub EntitlementName: EOS_Ecom_EntitlementName,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_GetEntitlementsByNameCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_GetEntitlementsByNameCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_GetEntitlementsByNameCountOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_GetEntitlementsByNameCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_GetEntitlementsByNameCountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_GetEntitlementsByNameCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_GetEntitlementsByNameCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_GetEntitlementsByNameCountOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EntitlementName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_GetEntitlementsByNameCountOptions),
            "::",
            stringify!(EntitlementName)
        )
    );
}
pub type EOS_Ecom_GetEntitlementsByNameCountOptions =
    _tagEOS_Ecom_GetEntitlementsByNameCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_CopyEntitlementByIndexOptions {
    #[doc = " API Version: Set this to EOS_ECOM_COPYENTITLEMENTBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user whose entitlement is being copied"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " Index of the entitlement to retrieve from the cache"]
    pub EntitlementIndex: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_CopyEntitlementByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_CopyEntitlementByIndexOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_CopyEntitlementByIndexOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_CopyEntitlementByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_CopyEntitlementByIndexOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_CopyEntitlementByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyEntitlementByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyEntitlementByIndexOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EntitlementIndex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyEntitlementByIndexOptions),
            "::",
            stringify!(EntitlementIndex)
        )
    );
}
pub type EOS_Ecom_CopyEntitlementByIndexOptions = _tagEOS_Ecom_CopyEntitlementByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_CopyEntitlementByNameAndIndexOptions {
    #[doc = " API Version: Set this to EOS_ECOM_COPYENTITLEMENTBYNAMEANDINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user whose entitlement is being copied"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " Name of the entitlement to retrieve from the cache"]
    pub EntitlementName: EOS_Ecom_EntitlementName,
    #[doc = " Index of the entitlement within the named set to retrieve from the cache."]
    pub Index: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_CopyEntitlementByNameAndIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_CopyEntitlementByNameAndIndexOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_CopyEntitlementByNameAndIndexOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_CopyEntitlementByNameAndIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_CopyEntitlementByNameAndIndexOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_CopyEntitlementByNameAndIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyEntitlementByNameAndIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyEntitlementByNameAndIndexOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EntitlementName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyEntitlementByNameAndIndexOptions),
            "::",
            stringify!(EntitlementName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Index) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyEntitlementByNameAndIndexOptions),
            "::",
            stringify!(Index)
        )
    );
}
pub type EOS_Ecom_CopyEntitlementByNameAndIndexOptions =
    _tagEOS_Ecom_CopyEntitlementByNameAndIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_CopyEntitlementByIdOptions {
    #[doc = " API Version: Set this to EOS_ECOM_COPYENTITLEMENTBYID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user whose entitlement is being copied"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " ID of the entitlement to retrieve from the cache"]
    pub EntitlementId: EOS_Ecom_EntitlementId,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_CopyEntitlementByIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_CopyEntitlementByIdOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_CopyEntitlementByIdOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_CopyEntitlementByIdOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_CopyEntitlementByIdOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_CopyEntitlementByIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyEntitlementByIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyEntitlementByIdOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EntitlementId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyEntitlementByIdOptions),
            "::",
            stringify!(EntitlementId)
        )
    );
}
pub type EOS_Ecom_CopyEntitlementByIdOptions = _tagEOS_Ecom_CopyEntitlementByIdOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_GetOfferCountOptions {
    #[doc = " API Version: Set this to EOS_ECOM_GETOFFERCOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user whose offers are being accessed"]
    pub LocalUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_GetOfferCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_GetOfferCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_GetOfferCountOptions>(),
        16usize,
        concat!("Size of: ", stringify!(_tagEOS_Ecom_GetOfferCountOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_GetOfferCountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_GetOfferCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_GetOfferCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_GetOfferCountOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Ecom_GetOfferCountOptions = _tagEOS_Ecom_GetOfferCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_CopyOfferByIndexOptions {
    #[doc = " API Version: Set this to EOS_ECOM_COPYOFFERBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user whose offer is being copied"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The index of the offer to get."]
    pub OfferIndex: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_CopyOfferByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_CopyOfferByIndexOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_CopyOfferByIndexOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_CopyOfferByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_CopyOfferByIndexOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_CopyOfferByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyOfferByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyOfferByIndexOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OfferIndex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyOfferByIndexOptions),
            "::",
            stringify!(OfferIndex)
        )
    );
}
pub type EOS_Ecom_CopyOfferByIndexOptions = _tagEOS_Ecom_CopyOfferByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_CopyOfferByIdOptions {
    #[doc = " API Version: Set this to EOS_ECOM_COPYOFFERBYID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user whose offer is being copied"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The ID of the offer to get."]
    pub OfferId: EOS_Ecom_CatalogOfferId,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_CopyOfferByIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_CopyOfferByIdOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_CopyOfferByIdOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Ecom_CopyOfferByIdOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_CopyOfferByIdOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_CopyOfferByIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyOfferByIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyOfferByIdOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OfferId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyOfferByIdOptions),
            "::",
            stringify!(OfferId)
        )
    );
}
pub type EOS_Ecom_CopyOfferByIdOptions = _tagEOS_Ecom_CopyOfferByIdOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_GetOfferItemCountOptions {
    #[doc = " API Version: Set this to EOS_ECOM_GETOFFERITEMCOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user who made the initial request for the Catalog Offer through EOS_Ecom_QueryOffers"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " An ID that corresponds to a cached Catalog Offer (retrieved by EOS_Ecom_CopyOfferByIndex)"]
    pub OfferId: EOS_Ecom_CatalogOfferId,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_GetOfferItemCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_GetOfferItemCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_GetOfferItemCountOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_GetOfferItemCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_GetOfferItemCountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_GetOfferItemCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_GetOfferItemCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_GetOfferItemCountOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OfferId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_GetOfferItemCountOptions),
            "::",
            stringify!(OfferId)
        )
    );
}
pub type EOS_Ecom_GetOfferItemCountOptions = _tagEOS_Ecom_GetOfferItemCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_CopyOfferItemByIndexOptions {
    #[doc = " API Version: Set this to EOS_ECOM_COPYOFFERITEMBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user whose item is being copied"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The ID of the offer to get the items for."]
    pub OfferId: EOS_Ecom_CatalogOfferId,
    #[doc = " The index of the item to get."]
    pub ItemIndex: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_CopyOfferItemByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_CopyOfferItemByIndexOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_CopyOfferItemByIndexOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_CopyOfferItemByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_CopyOfferItemByIndexOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_CopyOfferItemByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyOfferItemByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyOfferItemByIndexOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OfferId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyOfferItemByIndexOptions),
            "::",
            stringify!(OfferId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ItemIndex) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyOfferItemByIndexOptions),
            "::",
            stringify!(ItemIndex)
        )
    );
}
pub type EOS_Ecom_CopyOfferItemByIndexOptions = _tagEOS_Ecom_CopyOfferItemByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_CopyItemByIdOptions {
    #[doc = " API Version: Set this to EOS_ECOM_COPYITEMBYID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user whose item is being copied"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The ID of the item to get."]
    pub ItemId: EOS_Ecom_CatalogItemId,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_CopyItemByIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_CopyItemByIdOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_CopyItemByIdOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Ecom_CopyItemByIdOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_CopyItemByIdOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_CopyItemByIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyItemByIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyItemByIdOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ItemId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyItemByIdOptions),
            "::",
            stringify!(ItemId)
        )
    );
}
pub type EOS_Ecom_CopyItemByIdOptions = _tagEOS_Ecom_CopyItemByIdOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_GetOfferImageInfoCountOptions {
    #[doc = " API Version: Set this to EOS_ECOM_GETOFFERIMAGEINFOCOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user whose offer image is being accessed."]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The ID of the offer to get the images for."]
    pub OfferId: EOS_Ecom_CatalogOfferId,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_GetOfferImageInfoCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_GetOfferImageInfoCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_GetOfferImageInfoCountOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_GetOfferImageInfoCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_GetOfferImageInfoCountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_GetOfferImageInfoCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_GetOfferImageInfoCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_GetOfferImageInfoCountOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OfferId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_GetOfferImageInfoCountOptions),
            "::",
            stringify!(OfferId)
        )
    );
}
pub type EOS_Ecom_GetOfferImageInfoCountOptions = _tagEOS_Ecom_GetOfferImageInfoCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_CopyOfferImageInfoByIndexOptions {
    #[doc = " API Version: Set this to EOS_ECOM_COPYOFFERIMAGEINFOBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user whose offer image is being copied."]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The ID of the offer to get the images for."]
    pub OfferId: EOS_Ecom_CatalogOfferId,
    #[doc = " The index of the image to get."]
    pub ImageInfoIndex: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_CopyOfferImageInfoByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_CopyOfferImageInfoByIndexOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_CopyOfferImageInfoByIndexOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_CopyOfferImageInfoByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_CopyOfferImageInfoByIndexOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_CopyOfferImageInfoByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyOfferImageInfoByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyOfferImageInfoByIndexOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OfferId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyOfferImageInfoByIndexOptions),
            "::",
            stringify!(OfferId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ImageInfoIndex) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyOfferImageInfoByIndexOptions),
            "::",
            stringify!(ImageInfoIndex)
        )
    );
}
pub type EOS_Ecom_CopyOfferImageInfoByIndexOptions = _tagEOS_Ecom_CopyOfferImageInfoByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_GetItemImageInfoCountOptions {
    #[doc = " API Version: Set this to EOS_ECOM_GETITEMIMAGEINFOCOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user whose item image is being accessed"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The ID of the item to get the images for."]
    pub ItemId: EOS_Ecom_CatalogItemId,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_GetItemImageInfoCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_GetItemImageInfoCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_GetItemImageInfoCountOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_GetItemImageInfoCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_GetItemImageInfoCountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_GetItemImageInfoCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_GetItemImageInfoCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_GetItemImageInfoCountOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ItemId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_GetItemImageInfoCountOptions),
            "::",
            stringify!(ItemId)
        )
    );
}
pub type EOS_Ecom_GetItemImageInfoCountOptions = _tagEOS_Ecom_GetItemImageInfoCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_CopyItemImageInfoByIndexOptions {
    #[doc = " API Version: Set this to EOS_ECOM_COPYITEMIMAGEINFOBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user whose item image is being copied"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The ID of the item to get the images for."]
    pub ItemId: EOS_Ecom_CatalogItemId,
    #[doc = " The index of the image to get."]
    pub ImageInfoIndex: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_CopyItemImageInfoByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_CopyItemImageInfoByIndexOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_CopyItemImageInfoByIndexOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_CopyItemImageInfoByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_CopyItemImageInfoByIndexOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_CopyItemImageInfoByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyItemImageInfoByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyItemImageInfoByIndexOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ItemId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyItemImageInfoByIndexOptions),
            "::",
            stringify!(ItemId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ImageInfoIndex) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyItemImageInfoByIndexOptions),
            "::",
            stringify!(ImageInfoIndex)
        )
    );
}
pub type EOS_Ecom_CopyItemImageInfoByIndexOptions = _tagEOS_Ecom_CopyItemImageInfoByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_GetItemReleaseCountOptions {
    #[doc = " API Version: Set this to EOS_ECOM_GETITEMRELEASECOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user whose item release is being accessed"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The ID of the item to get the releases for."]
    pub ItemId: EOS_Ecom_CatalogItemId,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_GetItemReleaseCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_GetItemReleaseCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_GetItemReleaseCountOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_GetItemReleaseCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_GetItemReleaseCountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_GetItemReleaseCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_GetItemReleaseCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_GetItemReleaseCountOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ItemId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_GetItemReleaseCountOptions),
            "::",
            stringify!(ItemId)
        )
    );
}
pub type EOS_Ecom_GetItemReleaseCountOptions = _tagEOS_Ecom_GetItemReleaseCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_CopyItemReleaseByIndexOptions {
    #[doc = " API Version: Set this to EOS_ECOM_COPYITEMRELEASEBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user whose item release is being copied"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The ID of the item to get the releases for."]
    pub ItemId: EOS_Ecom_CatalogItemId,
    #[doc = " The index of the release to get."]
    pub ReleaseIndex: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_CopyItemReleaseByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_CopyItemReleaseByIndexOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_CopyItemReleaseByIndexOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_CopyItemReleaseByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_CopyItemReleaseByIndexOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_CopyItemReleaseByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyItemReleaseByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyItemReleaseByIndexOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ItemId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyItemReleaseByIndexOptions),
            "::",
            stringify!(ItemId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReleaseIndex) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyItemReleaseByIndexOptions),
            "::",
            stringify!(ReleaseIndex)
        )
    );
}
pub type EOS_Ecom_CopyItemReleaseByIndexOptions = _tagEOS_Ecom_CopyItemReleaseByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_GetTransactionCountOptions {
    #[doc = " API Version: Set this to EOS_ECOM_GETTRANSACTIONCOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user whose transaction count to get"]
    pub LocalUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_GetTransactionCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_GetTransactionCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_GetTransactionCountOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_GetTransactionCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_GetTransactionCountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_GetTransactionCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_GetTransactionCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_GetTransactionCountOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Ecom_GetTransactionCountOptions = _tagEOS_Ecom_GetTransactionCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_CopyTransactionByIndexOptions {
    #[doc = " API Version: Set this to EOS_ECOM_COPYTRANSACTIONBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user who is associated with the transaction"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The index of the transaction to get"]
    pub TransactionIndex: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_CopyTransactionByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_CopyTransactionByIndexOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_CopyTransactionByIndexOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_CopyTransactionByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_CopyTransactionByIndexOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_CopyTransactionByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyTransactionByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyTransactionByIndexOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TransactionIndex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyTransactionByIndexOptions),
            "::",
            stringify!(TransactionIndex)
        )
    );
}
pub type EOS_Ecom_CopyTransactionByIndexOptions = _tagEOS_Ecom_CopyTransactionByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_CopyTransactionByIdOptions {
    #[doc = " API Version: Set this to EOS_ECOM_COPYTRANSACTIONBYID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local user who is associated with the transaction"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The ID of the transaction to get"]
    pub TransactionId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_CopyTransactionByIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_CopyTransactionByIdOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_CopyTransactionByIdOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_CopyTransactionByIdOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_CopyTransactionByIdOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_CopyTransactionByIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyTransactionByIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyTransactionByIdOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TransactionId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_CopyTransactionByIdOptions),
            "::",
            stringify!(TransactionId)
        )
    );
}
pub type EOS_Ecom_CopyTransactionByIdOptions = _tagEOS_Ecom_CopyTransactionByIdOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_Transaction_GetEntitlementsCountOptions {
    #[doc = " API Version: Set this to EOS_ECOM_TRANSACTION_GETENTITLEMENTSCOUNT_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_Transaction_GetEntitlementsCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_Transaction_GetEntitlementsCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_Transaction_GetEntitlementsCountOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_Transaction_GetEntitlementsCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_Transaction_GetEntitlementsCountOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_Transaction_GetEntitlementsCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_Transaction_GetEntitlementsCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Ecom_Transaction_GetEntitlementsCountOptions =
    _tagEOS_Ecom_Transaction_GetEntitlementsCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Ecom_Transaction_CopyEntitlementByIndexOptions {
    #[doc = " API Version: Set this to EOS_ECOM_TRANSACTION_COPYENTITLEMENTBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The index of the entitlement to get"]
    pub EntitlementIndex: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Ecom_Transaction_CopyEntitlementByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Ecom_Transaction_CopyEntitlementByIndexOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Ecom_Transaction_CopyEntitlementByIndexOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Ecom_Transaction_CopyEntitlementByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Ecom_Transaction_CopyEntitlementByIndexOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Ecom_Transaction_CopyEntitlementByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_Transaction_CopyEntitlementByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EntitlementIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Ecom_Transaction_CopyEntitlementByIndexOptions),
            "::",
            stringify!(EntitlementIndex)
        )
    );
}
pub type EOS_Ecom_Transaction_CopyEntitlementByIndexOptions =
    _tagEOS_Ecom_Transaction_CopyEntitlementByIndexOptions;
extern "C" {
    #[doc = " Release the memory associated with an EOS_Ecom_HTransaction.  Is expected to be called after\n being received from a EOS_Ecom_CheckoutCallbackInfo.\n\n @param Transaction A handle to a transaction.\n\n @see EOS_Ecom_CheckoutCallbackInfo\n @see EOS_Ecom_GetTransactionCount\n @see EOS_Ecom_CopyTransactionByIndex"]
    pub fn EOS_Ecom_Transaction_Release(Transaction: EOS_Ecom_HTransaction);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_UIHandle {
    _unused: [u8; 0],
}
#[doc = " Handle to the UI interface"]
pub type EOS_HUI = *mut EOS_UIHandle;
#[doc = " ID representing a specific UI event."]
pub type EOS_UI_EventId = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UI_ShowFriendsOptions {
    #[doc = " API Version: Set this to EOS_UI_SHOWFRIENDS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the user whose friend list is being shown."]
    pub LocalUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_UI_ShowFriendsOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UI_ShowFriendsOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UI_ShowFriendsOptions>(),
        16usize,
        concat!("Size of: ", stringify!(_tagEOS_UI_ShowFriendsOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UI_ShowFriendsOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_UI_ShowFriendsOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ShowFriendsOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ShowFriendsOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_UI_ShowFriendsOptions = _tagEOS_UI_ShowFriendsOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UI_ShowFriendsCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_UI_ShowFriends"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Account ID of the user whose friend list is being shown."]
    pub LocalUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_UI_ShowFriendsCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UI_ShowFriendsCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UI_ShowFriendsCallbackInfo>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_UI_ShowFriendsCallbackInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UI_ShowFriendsCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UI_ShowFriendsCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ShowFriendsCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ShowFriendsCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ShowFriendsCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_UI_ShowFriendsCallbackInfo = _tagEOS_UI_ShowFriendsCallbackInfo;
pub type EOS_UI_OnShowFriendsCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_UI_ShowFriendsCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UI_HideFriendsOptions {
    #[doc = " API Version: Set this to EOS_UI_HIDEFRIENDS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the user whose friend list is being shown."]
    pub LocalUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_UI_HideFriendsOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UI_HideFriendsOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UI_HideFriendsOptions>(),
        16usize,
        concat!("Size of: ", stringify!(_tagEOS_UI_HideFriendsOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UI_HideFriendsOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_UI_HideFriendsOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_HideFriendsOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_HideFriendsOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_UI_HideFriendsOptions = _tagEOS_UI_HideFriendsOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UI_HideFriendsCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_UI_HideFriends"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Account ID of the user whose friend list is being shown."]
    pub LocalUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_UI_HideFriendsCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UI_HideFriendsCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UI_HideFriendsCallbackInfo>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_UI_HideFriendsCallbackInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UI_HideFriendsCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UI_HideFriendsCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_HideFriendsCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_HideFriendsCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_HideFriendsCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_UI_HideFriendsCallbackInfo = _tagEOS_UI_HideFriendsCallbackInfo;
pub type EOS_UI_OnHideFriendsCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_UI_HideFriendsCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UI_GetFriendsVisibleOptions {
    #[doc = " API Version: Set this to EOS_UI_GETFRIENDSVISIBLE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the user whose overlay is being checked."]
    pub LocalUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_UI_GetFriendsVisibleOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UI_GetFriendsVisibleOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UI_GetFriendsVisibleOptions>(),
        16usize,
        concat!("Size of: ", stringify!(_tagEOS_UI_GetFriendsVisibleOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UI_GetFriendsVisibleOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UI_GetFriendsVisibleOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_GetFriendsVisibleOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_GetFriendsVisibleOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_UI_GetFriendsVisibleOptions = _tagEOS_UI_GetFriendsVisibleOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UI_GetFriendsExclusiveInputOptions {
    #[doc = " API Version: Set this to EOS_UI_GETFRIENDSEXCLUSIVEINPUT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the user whose overlay is being checked."]
    pub LocalUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_UI_GetFriendsExclusiveInputOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UI_GetFriendsExclusiveInputOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UI_GetFriendsExclusiveInputOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UI_GetFriendsExclusiveInputOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UI_GetFriendsExclusiveInputOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UI_GetFriendsExclusiveInputOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_GetFriendsExclusiveInputOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_GetFriendsExclusiveInputOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_UI_GetFriendsExclusiveInputOptions = _tagEOS_UI_GetFriendsExclusiveInputOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UI_AddNotifyDisplaySettingsUpdatedOptions {
    #[doc = " API Version: Set this to EOS_UI_ADDNOTIFYDISPLAYSETTINGSUPDATED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_UI_AddNotifyDisplaySettingsUpdatedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UI_AddNotifyDisplaySettingsUpdatedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UI_AddNotifyDisplaySettingsUpdatedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UI_AddNotifyDisplaySettingsUpdatedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UI_AddNotifyDisplaySettingsUpdatedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UI_AddNotifyDisplaySettingsUpdatedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_AddNotifyDisplaySettingsUpdatedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_UI_AddNotifyDisplaySettingsUpdatedOptions =
    _tagEOS_UI_AddNotifyDisplaySettingsUpdatedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UI_OnDisplaySettingsUpdatedCallbackInfo {
    #[doc = " Context that was passed into EOS_UI_AddNotifyDisplaySettingsUpdated"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " True when any portion of the overlay is visible."]
    pub bIsVisible: EOS_Bool,
    #[doc = " True when the overlay has switched to exclusive input mode.\n While in exclusive input mode, no keyboard or mouse input will be sent to the game."]
    pub bIsExclusiveInput: EOS_Bool,
}
#[test]
fn bindgen_test_layout__tagEOS_UI_OnDisplaySettingsUpdatedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UI_OnDisplaySettingsUpdatedCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UI_OnDisplaySettingsUpdatedCallbackInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UI_OnDisplaySettingsUpdatedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UI_OnDisplaySettingsUpdatedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UI_OnDisplaySettingsUpdatedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_OnDisplaySettingsUpdatedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsVisible) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_OnDisplaySettingsUpdatedCallbackInfo),
            "::",
            stringify!(bIsVisible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsExclusiveInput) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_OnDisplaySettingsUpdatedCallbackInfo),
            "::",
            stringify!(bIsExclusiveInput)
        )
    );
}
pub type EOS_UI_OnDisplaySettingsUpdatedCallbackInfo =
    _tagEOS_UI_OnDisplaySettingsUpdatedCallbackInfo;
pub type EOS_UI_OnDisplaySettingsUpdatedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_UI_OnDisplaySettingsUpdatedCallbackInfo),
>;
impl EOS_UI_EKeyCombination {
    pub const EOS_UIK_Key1: EOS_UI_EKeyCombination = EOS_UI_EKeyCombination::EOS_UIK_ModifierShift;
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_UI_EKeyCombination {
    EOS_UIK_ModifierShift = 16,
    EOS_UIK_KeyTypeMask = 65535,
    EOS_UIK_ModifierMask = -65536,
    EOS_UIK_Shift = 65536,
    EOS_UIK_Control = 131072,
    EOS_UIK_Alt = 262144,
    EOS_UIK_Meta = 524288,
    EOS_UIK_ValidModifierMask = 983040,
    EOS_UIK_None = 0,
    EOS_UIK_Space = 1,
    EOS_UIK_Backspace = 2,
    EOS_UIK_Tab = 3,
    EOS_UIK_Escape = 4,
    EOS_UIK_PageUp = 5,
    EOS_UIK_PageDown = 6,
    EOS_UIK_End = 7,
    EOS_UIK_Home = 8,
    EOS_UIK_Insert = 9,
    EOS_UIK_Delete = 10,
    EOS_UIK_Left = 11,
    EOS_UIK_Up = 12,
    EOS_UIK_Right = 13,
    EOS_UIK_Down = 14,
    EOS_UIK_Key0 = 15,
    EOS_UIK_Key2 = 17,
    EOS_UIK_Key3 = 18,
    EOS_UIK_Key4 = 19,
    EOS_UIK_Key5 = 20,
    EOS_UIK_Key6 = 21,
    EOS_UIK_Key7 = 22,
    EOS_UIK_Key8 = 23,
    EOS_UIK_Key9 = 24,
    EOS_UIK_KeyA = 25,
    EOS_UIK_KeyB = 26,
    EOS_UIK_KeyC = 27,
    EOS_UIK_KeyD = 28,
    EOS_UIK_KeyE = 29,
    EOS_UIK_KeyF = 30,
    EOS_UIK_KeyG = 31,
    EOS_UIK_KeyH = 32,
    EOS_UIK_KeyI = 33,
    EOS_UIK_KeyJ = 34,
    EOS_UIK_KeyK = 35,
    EOS_UIK_KeyL = 36,
    EOS_UIK_KeyM = 37,
    EOS_UIK_KeyN = 38,
    EOS_UIK_KeyO = 39,
    EOS_UIK_KeyP = 40,
    EOS_UIK_KeyQ = 41,
    EOS_UIK_KeyR = 42,
    EOS_UIK_KeyS = 43,
    EOS_UIK_KeyT = 44,
    EOS_UIK_KeyU = 45,
    EOS_UIK_KeyV = 46,
    EOS_UIK_KeyW = 47,
    EOS_UIK_KeyX = 48,
    EOS_UIK_KeyY = 49,
    EOS_UIK_KeyZ = 50,
    EOS_UIK_Numpad0 = 51,
    EOS_UIK_Numpad1 = 52,
    EOS_UIK_Numpad2 = 53,
    EOS_UIK_Numpad3 = 54,
    EOS_UIK_Numpad4 = 55,
    EOS_UIK_Numpad5 = 56,
    EOS_UIK_Numpad6 = 57,
    EOS_UIK_Numpad7 = 58,
    EOS_UIK_Numpad8 = 59,
    EOS_UIK_Numpad9 = 60,
    EOS_UIK_NumpadAsterisk = 61,
    EOS_UIK_NumpadPlus = 62,
    EOS_UIK_NumpadMinus = 63,
    EOS_UIK_NumpadPeriod = 64,
    EOS_UIK_NumpadDivide = 65,
    EOS_UIK_F1 = 66,
    EOS_UIK_F2 = 67,
    EOS_UIK_F3 = 68,
    EOS_UIK_F4 = 69,
    EOS_UIK_F5 = 70,
    EOS_UIK_F6 = 71,
    EOS_UIK_F7 = 72,
    EOS_UIK_F8 = 73,
    EOS_UIK_F9 = 74,
    EOS_UIK_F10 = 75,
    EOS_UIK_F11 = 76,
    EOS_UIK_F12 = 77,
    EOS_UIK_F13 = 78,
    EOS_UIK_F14 = 79,
    EOS_UIK_F15 = 80,
    EOS_UIK_F16 = 81,
    EOS_UIK_F17 = 82,
    EOS_UIK_F18 = 83,
    EOS_UIK_F19 = 84,
    EOS_UIK_F20 = 85,
    EOS_UIK_F21 = 86,
    EOS_UIK_F22 = 87,
    EOS_UIK_F23 = 88,
    EOS_UIK_F24 = 89,
    EOS_UIK_OemPlus = 90,
    EOS_UIK_OemComma = 91,
    EOS_UIK_OemMinus = 92,
    EOS_UIK_OemPeriod = 93,
    EOS_UIK_Oem1 = 94,
    EOS_UIK_Oem2 = 95,
    EOS_UIK_Oem3 = 96,
    EOS_UIK_Oem4 = 97,
    EOS_UIK_Oem5 = 98,
    EOS_UIK_Oem6 = 99,
    EOS_UIK_Oem7 = 100,
    EOS_UIK_Oem8 = 101,
    EOS_UIK_MaxKeyType = 102,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_UI_EInputStateButtonFlags {
    EOS_UISBF_None = 0,
    EOS_UISBF_DPad_Left = 1,
    EOS_UISBF_DPad_Right = 2,
    EOS_UISBF_DPad_Down = 4,
    EOS_UISBF_DPad_Up = 8,
    EOS_UISBF_FaceButton_Left = 16,
    EOS_UISBF_FaceButton_Right = 32,
    EOS_UISBF_FaceButton_Bottom = 64,
    EOS_UISBF_FaceButton_Top = 128,
    EOS_UISBF_LeftShoulder = 256,
    EOS_UISBF_RightShoulder = 512,
    EOS_UISBF_LeftTrigger = 1024,
    EOS_UISBF_RightTrigger = 2048,
    EOS_UISBF_Special_Left = 4096,
    EOS_UISBF_Special_Right = 8192,
    EOS_UISBF_LeftThumbstick = 16384,
    EOS_UISBF_RightThumbstick = 32768,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UI_SetToggleFriendsKeyOptions {
    #[doc = " API Version: Set this to EOS_UI_SETTOGGLEFRIENDSKEY_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The new key combination which will be used to toggle the friends overlay.\n The combination can be any set of modifiers and one key.\n A value of EOS_UIK_None will cause the key to revert to the default."]
    pub KeyCombination: EOS_UI_EKeyCombination,
}
#[test]
fn bindgen_test_layout__tagEOS_UI_SetToggleFriendsKeyOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UI_SetToggleFriendsKeyOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UI_SetToggleFriendsKeyOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UI_SetToggleFriendsKeyOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UI_SetToggleFriendsKeyOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UI_SetToggleFriendsKeyOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_SetToggleFriendsKeyOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).KeyCombination) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_SetToggleFriendsKeyOptions),
            "::",
            stringify!(KeyCombination)
        )
    );
}
pub type EOS_UI_SetToggleFriendsKeyOptions = _tagEOS_UI_SetToggleFriendsKeyOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UI_GetToggleFriendsKeyOptions {
    #[doc = " API Version: Set this to EOS_UI_GETTOGGLEFRIENDSKEY_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_UI_GetToggleFriendsKeyOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UI_GetToggleFriendsKeyOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UI_GetToggleFriendsKeyOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UI_GetToggleFriendsKeyOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UI_GetToggleFriendsKeyOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UI_GetToggleFriendsKeyOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_GetToggleFriendsKeyOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_UI_GetToggleFriendsKeyOptions = _tagEOS_UI_GetToggleFriendsKeyOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UI_SetToggleFriendsButtonOptions {
    #[doc = " API Version: Set this to EOS_UI_SETTOGGLEFRIENDSBUTTON_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The new button which will be used to toggle the friends overlay.\n It can be any combination of buttons.\n A value of EOS_UISBF_None will cause the button to revert to the default."]
    pub ButtonCombination: EOS_UI_EInputStateButtonFlags,
}
#[test]
fn bindgen_test_layout__tagEOS_UI_SetToggleFriendsButtonOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UI_SetToggleFriendsButtonOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UI_SetToggleFriendsButtonOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UI_SetToggleFriendsButtonOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UI_SetToggleFriendsButtonOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UI_SetToggleFriendsButtonOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_SetToggleFriendsButtonOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ButtonCombination) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_SetToggleFriendsButtonOptions),
            "::",
            stringify!(ButtonCombination)
        )
    );
}
pub type EOS_UI_SetToggleFriendsButtonOptions = _tagEOS_UI_SetToggleFriendsButtonOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UI_GetToggleFriendsButtonOptions {
    #[doc = " API Version: Set this to EOS_UI_GETTOGGLEFRIENDSBUTTON_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_UI_GetToggleFriendsButtonOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UI_GetToggleFriendsButtonOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UI_GetToggleFriendsButtonOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UI_GetToggleFriendsButtonOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UI_GetToggleFriendsButtonOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UI_GetToggleFriendsButtonOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_GetToggleFriendsButtonOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_UI_GetToggleFriendsButtonOptions = _tagEOS_UI_GetToggleFriendsButtonOptions;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_UI_ENotificationLocation {
    #[doc = " Notification locations to be used to set the preference\n for pop-up.\n\n @see EOS_UI_SetDisplayPreference"]
    EOS_UNL_TopLeft = 0,
    #[doc = " Notification locations to be used to set the preference\n for pop-up.\n\n @see EOS_UI_SetDisplayPreference"]
    EOS_UNL_TopRight = 1,
    #[doc = " Notification locations to be used to set the preference\n for pop-up.\n\n @see EOS_UI_SetDisplayPreference"]
    EOS_UNL_BottomLeft = 2,
    #[doc = " Notification locations to be used to set the preference\n for pop-up.\n\n @see EOS_UI_SetDisplayPreference"]
    EOS_UNL_BottomRight = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UI_SetDisplayPreferenceOptions {
    #[doc = " API Version: Set this to EOS_UI_SETDISPLAYPREFERENCE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Preference for notification pop-up locations."]
    pub NotificationLocation: EOS_UI_ENotificationLocation,
}
#[test]
fn bindgen_test_layout__tagEOS_UI_SetDisplayPreferenceOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UI_SetDisplayPreferenceOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UI_SetDisplayPreferenceOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UI_SetDisplayPreferenceOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UI_SetDisplayPreferenceOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UI_SetDisplayPreferenceOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_SetDisplayPreferenceOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NotificationLocation) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_SetDisplayPreferenceOptions),
            "::",
            stringify!(NotificationLocation)
        )
    );
}
pub type EOS_UI_SetDisplayPreferenceOptions = _tagEOS_UI_SetDisplayPreferenceOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UI_AcknowledgeEventIdOptions {
    #[doc = " API Version: Set this to EOS_UI_ACKNOWLEDGEEVENTID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The ID being acknowledged."]
    pub UiEventId: EOS_UI_EventId,
    #[doc = " The result to use for the acknowledgment.\n When acknowledging EOS_Presence_JoinGameAcceptedCallbackInfo this should be the\n result code from the JoinSession call."]
    pub Result: EOS_EResult,
}
#[test]
fn bindgen_test_layout__tagEOS_UI_AcknowledgeEventIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UI_AcknowledgeEventIdOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UI_AcknowledgeEventIdOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UI_AcknowledgeEventIdOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UI_AcknowledgeEventIdOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UI_AcknowledgeEventIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_AcknowledgeEventIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UiEventId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_AcknowledgeEventIdOptions),
            "::",
            stringify!(UiEventId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Result) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_AcknowledgeEventIdOptions),
            "::",
            stringify!(Result)
        )
    );
}
pub type EOS_UI_AcknowledgeEventIdOptions = _tagEOS_UI_AcknowledgeEventIdOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UI_ReportInputStateOptions {
    #[doc = " API Version: Set this to EOS_UI_REPORTINPUTSTATE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Flags to identify the current buttons which are pressed."]
    pub ButtonDownFlags: EOS_UI_EInputStateButtonFlags,
    #[doc = " Whether the current platform and configuration uses the right face button as the default accept button.\n When this flag is true, the right face button is the accept action, and the down face button is the cancel action.\n When this flag is false, the right face button is the cancel action, and the down face button is the accept action."]
    pub bAcceptIsFaceButtonRight: EOS_Bool,
    #[doc = " The current state of the mouse button."]
    pub bMouseButtonDown: EOS_Bool,
    #[doc = " The current x-position of the mouse."]
    pub MousePosX: u32,
    #[doc = " The current y-position of the mouse."]
    pub MousePosY: u32,
    #[doc = " The gamepad or player index"]
    pub GamepadIndex: u32,
    #[doc = " Left analog stick horizontal movement in [-1, 1]. Negative for left, positive for right"]
    pub LeftStickX: f32,
    #[doc = " Left analog stick vertical movement in [-1, 1]. Negative for up, positive for down"]
    pub LeftStickY: f32,
    #[doc = " Right analog stick horizontal movement in [-1, 1]. Negative for left, positive for right"]
    pub RightStickX: f32,
    #[doc = " Right analog stick vertical movement in [-1, 1]. Negative for up, positive for down"]
    pub RightStickY: f32,
    #[doc = " Left trigger analog value in [0, 1]"]
    pub LeftTrigger: f32,
    #[doc = " Right trigger analog value in [0, 1]"]
    pub RightTrigger: f32,
}
#[test]
fn bindgen_test_layout__tagEOS_UI_ReportInputStateOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UI_ReportInputStateOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UI_ReportInputStateOptions>(),
        52usize,
        concat!("Size of: ", stringify!(_tagEOS_UI_ReportInputStateOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UI_ReportInputStateOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UI_ReportInputStateOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ReportInputStateOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ButtonDownFlags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ReportInputStateOptions),
            "::",
            stringify!(ButtonDownFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bAcceptIsFaceButtonRight) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ReportInputStateOptions),
            "::",
            stringify!(bAcceptIsFaceButtonRight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bMouseButtonDown) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ReportInputStateOptions),
            "::",
            stringify!(bMouseButtonDown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MousePosX) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ReportInputStateOptions),
            "::",
            stringify!(MousePosX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MousePosY) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ReportInputStateOptions),
            "::",
            stringify!(MousePosY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GamepadIndex) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ReportInputStateOptions),
            "::",
            stringify!(GamepadIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LeftStickX) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ReportInputStateOptions),
            "::",
            stringify!(LeftStickX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LeftStickY) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ReportInputStateOptions),
            "::",
            stringify!(LeftStickY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RightStickX) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ReportInputStateOptions),
            "::",
            stringify!(RightStickX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RightStickY) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ReportInputStateOptions),
            "::",
            stringify!(RightStickY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LeftTrigger) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ReportInputStateOptions),
            "::",
            stringify!(LeftTrigger)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RightTrigger) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ReportInputStateOptions),
            "::",
            stringify!(RightTrigger)
        )
    );
}
pub type EOS_UI_ReportInputStateOptions = _tagEOS_UI_ReportInputStateOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UI_PrePresentOptions {
    #[doc = " API Version: Set this to EOS_UI_PREPRESENT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Platform specific data."]
    pub PlatformSpecificData: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_UI_PrePresentOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UI_PrePresentOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UI_PrePresentOptions>(),
        16usize,
        concat!("Size of: ", stringify!(_tagEOS_UI_PrePresentOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UI_PrePresentOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_UI_PrePresentOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_PrePresentOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PlatformSpecificData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_PrePresentOptions),
            "::",
            stringify!(PlatformSpecificData)
        )
    );
}
pub type EOS_UI_PrePresentOptions = _tagEOS_UI_PrePresentOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UI_ShowBlockPlayerOptions {
    #[doc = " API Version: Set this to EOS_UI_SHOWBLOCKPLAYER_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Online Services Account ID of the user who is requesting the Block."]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Online Services Account ID of the user whose is being Blocked."]
    pub TargetUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_UI_ShowBlockPlayerOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UI_ShowBlockPlayerOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UI_ShowBlockPlayerOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_UI_ShowBlockPlayerOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UI_ShowBlockPlayerOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UI_ShowBlockPlayerOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ShowBlockPlayerOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ShowBlockPlayerOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ShowBlockPlayerOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_UI_ShowBlockPlayerOptions = _tagEOS_UI_ShowBlockPlayerOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UI_OnShowBlockPlayerCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_UI_ShowBlockPlayer"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Online Services Account ID of the user who requested the block."]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Online Services Account ID of the user who was to be blocked."]
    pub TargetUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_UI_OnShowBlockPlayerCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UI_OnShowBlockPlayerCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UI_OnShowBlockPlayerCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UI_OnShowBlockPlayerCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UI_OnShowBlockPlayerCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UI_OnShowBlockPlayerCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_OnShowBlockPlayerCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_OnShowBlockPlayerCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_OnShowBlockPlayerCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_OnShowBlockPlayerCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_UI_OnShowBlockPlayerCallbackInfo = _tagEOS_UI_OnShowBlockPlayerCallbackInfo;
pub type EOS_UI_OnShowBlockPlayerCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_UI_OnShowBlockPlayerCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UI_ShowReportPlayerOptions {
    #[doc = " API Version: Set this to EOS_UI_SHOWREPORTPLAYER_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Online Services Account ID of the user who is requesting the Report."]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Online Services Account ID of the user whose is being Reported."]
    pub TargetUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_UI_ShowReportPlayerOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UI_ShowReportPlayerOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UI_ShowReportPlayerOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_UI_ShowReportPlayerOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UI_ShowReportPlayerOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UI_ShowReportPlayerOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ShowReportPlayerOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ShowReportPlayerOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ShowReportPlayerOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_UI_ShowReportPlayerOptions = _tagEOS_UI_ShowReportPlayerOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UI_OnShowReportPlayerCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_UI_ShowReportPlayer"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Online Services Account ID of the user who requested the Report."]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Online Services Account ID of the user who was to be Reported."]
    pub TargetUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_UI_OnShowReportPlayerCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UI_OnShowReportPlayerCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UI_OnShowReportPlayerCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UI_OnShowReportPlayerCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UI_OnShowReportPlayerCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UI_OnShowReportPlayerCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_OnShowReportPlayerCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_OnShowReportPlayerCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_OnShowReportPlayerCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_OnShowReportPlayerCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_UI_OnShowReportPlayerCallbackInfo = _tagEOS_UI_OnShowReportPlayerCallbackInfo;
pub type EOS_UI_OnShowReportPlayerCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_UI_OnShowReportPlayerCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UI_ShowNativeProfileOptions {
    #[doc = " API Version: Set this to EOS_UI_SHOWNATIVEPROFILE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Online Services Account ID of the user who is requesting the profile."]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Online Services Account ID of the user whose profile is being requested."]
    pub TargetUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_UI_ShowNativeProfileOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UI_ShowNativeProfileOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UI_ShowNativeProfileOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_UI_ShowNativeProfileOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UI_ShowNativeProfileOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UI_ShowNativeProfileOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ShowNativeProfileOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ShowNativeProfileOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ShowNativeProfileOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_UI_ShowNativeProfileOptions = _tagEOS_UI_ShowNativeProfileOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UI_ShowNativeProfileCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_UI_ShowNativeProfile"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Online Services Account ID of the user who requested the profile."]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Online Services Account ID of the user who was to have a profile shown."]
    pub TargetUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_UI_ShowNativeProfileCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UI_ShowNativeProfileCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UI_ShowNativeProfileCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UI_ShowNativeProfileCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UI_ShowNativeProfileCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UI_ShowNativeProfileCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ShowNativeProfileCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ShowNativeProfileCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ShowNativeProfileCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_ShowNativeProfileCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_UI_ShowNativeProfileCallbackInfo = _tagEOS_UI_ShowNativeProfileCallbackInfo;
pub type EOS_UI_OnShowNativeProfileCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_UI_ShowNativeProfileCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UI_PauseSocialOverlayOptions {
    #[doc = " API Version: Set this to EOS_UI_PAUSESOCIALOVERLAY_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The desired bIsPaused state of the overlay."]
    pub bIsPaused: EOS_Bool,
}
#[test]
fn bindgen_test_layout__tagEOS_UI_PauseSocialOverlayOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UI_PauseSocialOverlayOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UI_PauseSocialOverlayOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UI_PauseSocialOverlayOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UI_PauseSocialOverlayOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UI_PauseSocialOverlayOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_PauseSocialOverlayOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsPaused) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_PauseSocialOverlayOptions),
            "::",
            stringify!(bIsPaused)
        )
    );
}
pub type EOS_UI_PauseSocialOverlayOptions = _tagEOS_UI_PauseSocialOverlayOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UI_IsSocialOverlayPausedOptions {
    #[doc = " API Version: Set this to EOS_UI_ISSOCIALOVERLAYPAUSED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_UI_IsSocialOverlayPausedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UI_IsSocialOverlayPausedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UI_IsSocialOverlayPausedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UI_IsSocialOverlayPausedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UI_IsSocialOverlayPausedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UI_IsSocialOverlayPausedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_IsSocialOverlayPausedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_UI_IsSocialOverlayPausedOptions = _tagEOS_UI_IsSocialOverlayPausedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UI_Rect {
    #[doc = " API Version: Set this to EOS_UI_RECT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Left coordinate."]
    pub X: i32,
    #[doc = " Top coordinate."]
    pub Y: i32,
    #[doc = " Width."]
    pub Width: u32,
    #[doc = " Height."]
    pub Height: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_UI_Rect() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UI_Rect> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UI_Rect>(),
        20usize,
        concat!("Size of: ", stringify!(_tagEOS_UI_Rect))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UI_Rect>(),
        4usize,
        concat!("Alignment of ", stringify!(_tagEOS_UI_Rect))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_Rect),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).X) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_Rect),
            "::",
            stringify!(X)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_Rect),
            "::",
            stringify!(Y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Width) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_Rect),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Height) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_Rect),
            "::",
            stringify!(Height)
        )
    );
}
pub type EOS_UI_Rect = _tagEOS_UI_Rect;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UI_MemoryMonitorCallbackInfo {
    #[doc = " Context that was passed into EOS_UI_AddNotifyMemoryMonitor"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " This field is for system specific memory monitor report.\n\n If provided then the structure will be located in eos_<platform>_ui.h\n The structure will be named EOS_<platform>_MemoryMonitorReport."]
    pub SystemMemoryMonitorReport: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_UI_MemoryMonitorCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UI_MemoryMonitorCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UI_MemoryMonitorCallbackInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UI_MemoryMonitorCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UI_MemoryMonitorCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UI_MemoryMonitorCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_MemoryMonitorCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SystemMemoryMonitorReport) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_MemoryMonitorCallbackInfo),
            "::",
            stringify!(SystemMemoryMonitorReport)
        )
    );
}
pub type EOS_UI_MemoryMonitorCallbackInfo = _tagEOS_UI_MemoryMonitorCallbackInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UI_AddNotifyMemoryMonitorOptions {
    #[doc = " API Version: Set this to EOS_UI_ADDNOTIFYMEMORYMONITOR_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_UI_AddNotifyMemoryMonitorOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UI_AddNotifyMemoryMonitorOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UI_AddNotifyMemoryMonitorOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UI_AddNotifyMemoryMonitorOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UI_AddNotifyMemoryMonitorOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UI_AddNotifyMemoryMonitorOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UI_AddNotifyMemoryMonitorOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_UI_AddNotifyMemoryMonitorOptions = _tagEOS_UI_AddNotifyMemoryMonitorOptions;
pub type EOS_UI_OnMemoryMonitorCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_UI_MemoryMonitorCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_FriendsHandle {
    _unused: [u8; 0],
}
pub type EOS_HFriends = *mut EOS_FriendsHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Friends_QueryFriendsOptions {
    #[doc = " API Version: Set this to EOS_FRIENDS_QUERYFRIENDS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local, logged-in user whose friends list you want to retrieve"]
    pub LocalUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Friends_QueryFriendsOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Friends_QueryFriendsOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Friends_QueryFriendsOptions>(),
        16usize,
        concat!("Size of: ", stringify!(_tagEOS_Friends_QueryFriendsOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Friends_QueryFriendsOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Friends_QueryFriendsOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_QueryFriendsOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_QueryFriendsOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Friends_QueryFriendsOptions = _tagEOS_Friends_QueryFriendsOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Friends_QueryFriendsCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Friends_QueryFriends"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Account ID of the user whose friends were queried"]
    pub LocalUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Friends_QueryFriendsCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Friends_QueryFriendsCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Friends_QueryFriendsCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Friends_QueryFriendsCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Friends_QueryFriendsCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Friends_QueryFriendsCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_QueryFriendsCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_QueryFriendsCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_QueryFriendsCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Friends_QueryFriendsCallbackInfo = _tagEOS_Friends_QueryFriendsCallbackInfo;
pub type EOS_Friends_OnQueryFriendsCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Friends_QueryFriendsCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Friends_SendInviteOptions {
    #[doc = " API Version: Set this to EOS_FRIENDS_SENDINVITE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local, logged-in user who is sending the friends list invitation"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Account ID of the user who is receiving the friends list invitation"]
    pub TargetUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Friends_SendInviteOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Friends_SendInviteOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Friends_SendInviteOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Friends_SendInviteOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Friends_SendInviteOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Friends_SendInviteOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_SendInviteOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_SendInviteOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_SendInviteOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Friends_SendInviteOptions = _tagEOS_Friends_SendInviteOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Friends_SendInviteCallbackInfo {
    #[doc = " Result code for the operation. EOS_Success is returned if the invitation was sent, otherwise one of the error codes is returned. See eos_common.h"]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Friends_SendInvite"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Account ID of the user who sent the friends list invitation"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Account ID of the user to whom the friends list invitation was sent"]
    pub TargetUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Friends_SendInviteCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Friends_SendInviteCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Friends_SendInviteCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Friends_SendInviteCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Friends_SendInviteCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Friends_SendInviteCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_SendInviteCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_SendInviteCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_SendInviteCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_SendInviteCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Friends_SendInviteCallbackInfo = _tagEOS_Friends_SendInviteCallbackInfo;
pub type EOS_Friends_OnSendInviteCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Friends_SendInviteCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Friends_AcceptInviteOptions {
    #[doc = " API Version: Set this to EOS_FRIENDS_ACCEPTINVITE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local, logged-in user who is accepting the friends list invitation"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Account ID of the user who sent the friends list invitation"]
    pub TargetUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Friends_AcceptInviteOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Friends_AcceptInviteOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Friends_AcceptInviteOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Friends_AcceptInviteOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Friends_AcceptInviteOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Friends_AcceptInviteOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_AcceptInviteOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_AcceptInviteOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_AcceptInviteOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Friends_AcceptInviteOptions = _tagEOS_Friends_AcceptInviteOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Friends_AcceptInviteCallbackInfo {
    #[doc = " Result code for the operation. EOS_Success is returned if an invite was accepted, otherwise one of the error codes is returned. See eos_common.h"]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that is passed into EOS_Friends_AcceptInvite"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Account ID of the user who is accepting the friends list invitation"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Account ID of the user who sent the local user a friends list invitation"]
    pub TargetUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Friends_AcceptInviteCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Friends_AcceptInviteCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Friends_AcceptInviteCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Friends_AcceptInviteCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Friends_AcceptInviteCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Friends_AcceptInviteCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_AcceptInviteCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_AcceptInviteCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_AcceptInviteCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_AcceptInviteCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Friends_AcceptInviteCallbackInfo = _tagEOS_Friends_AcceptInviteCallbackInfo;
pub type EOS_Friends_OnAcceptInviteCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Friends_AcceptInviteCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Friends_RejectInviteOptions {
    #[doc = " API Version: Set this to EOS_FRIENDS_REJECTINVITE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local, logged-in user who is rejecting a friends list invitation"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Account ID of the user who sent the friends list invitation"]
    pub TargetUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Friends_RejectInviteOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Friends_RejectInviteOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Friends_RejectInviteOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Friends_RejectInviteOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Friends_RejectInviteOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Friends_RejectInviteOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_RejectInviteOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_RejectInviteOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_RejectInviteOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Friends_RejectInviteOptions = _tagEOS_Friends_RejectInviteOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Friends_RejectInviteCallbackInfo {
    #[doc = " Result code for the operation. EOS_Success is returned if an invite was accepted, otherwise one of the error codes is returned. See eos_common.h"]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that is passed into EOS_Friends_RejectInvite"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Account ID of the user who is rejecting the friends list invitation"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Account ID of the user who sent the friends list invitation"]
    pub TargetUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Friends_RejectInviteCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Friends_RejectInviteCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Friends_RejectInviteCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Friends_RejectInviteCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Friends_RejectInviteCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Friends_RejectInviteCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_RejectInviteCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_RejectInviteCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_RejectInviteCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_RejectInviteCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Friends_RejectInviteCallbackInfo = _tagEOS_Friends_RejectInviteCallbackInfo;
pub type EOS_Friends_OnRejectInviteCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Friends_RejectInviteCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Friends_GetFriendsCountOptions {
    #[doc = " API Version: Set this to EOS_FRIENDS_GETFRIENDSCOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the user whose friends should be counted"]
    pub LocalUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Friends_GetFriendsCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Friends_GetFriendsCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Friends_GetFriendsCountOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Friends_GetFriendsCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Friends_GetFriendsCountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Friends_GetFriendsCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_GetFriendsCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_GetFriendsCountOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Friends_GetFriendsCountOptions = _tagEOS_Friends_GetFriendsCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Friends_GetFriendAtIndexOptions {
    #[doc = " API Version: Set this to EOS_FRIENDS_GETFRIENDATINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the user whose friend list is being queried"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " Index into the friend list. This value must be between 0 and EOS_Friends_GetFriendsCount-1 inclusively."]
    pub Index: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Friends_GetFriendAtIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Friends_GetFriendAtIndexOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Friends_GetFriendAtIndexOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Friends_GetFriendAtIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Friends_GetFriendAtIndexOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Friends_GetFriendAtIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_GetFriendAtIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_GetFriendAtIndexOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Index) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_GetFriendAtIndexOptions),
            "::",
            stringify!(Index)
        )
    );
}
pub type EOS_Friends_GetFriendAtIndexOptions = _tagEOS_Friends_GetFriendAtIndexOptions;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EFriendsStatus {
    #[doc = " The two accounts have no friendship status"]
    EOS_FS_NotFriends = 0,
    #[doc = " The local account has sent a friend invite to the other account"]
    EOS_FS_InviteSent = 1,
    #[doc = " The other account has sent a friend invite to the local account"]
    EOS_FS_InviteReceived = 2,
    #[doc = " The accounts have accepted friendship"]
    EOS_FS_Friends = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Friends_GetStatusOptions {
    #[doc = " API Version: Set this to EOS_FRIENDS_GETSTATUS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local, logged in user"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Account ID of the user whose friendship status with the local user is being queried"]
    pub TargetUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Friends_GetStatusOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Friends_GetStatusOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Friends_GetStatusOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Friends_GetStatusOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Friends_GetStatusOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Friends_GetStatusOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_GetStatusOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_GetStatusOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_GetStatusOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Friends_GetStatusOptions = _tagEOS_Friends_GetStatusOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Friends_AddNotifyFriendsUpdateOptions {
    #[doc = " API Version: Set this to EOS_FRIENDS_ADDNOTIFYFRIENDSUPDATE_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Friends_AddNotifyFriendsUpdateOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Friends_AddNotifyFriendsUpdateOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Friends_AddNotifyFriendsUpdateOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Friends_AddNotifyFriendsUpdateOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Friends_AddNotifyFriendsUpdateOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Friends_AddNotifyFriendsUpdateOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_AddNotifyFriendsUpdateOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Friends_AddNotifyFriendsUpdateOptions = _tagEOS_Friends_AddNotifyFriendsUpdateOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Friends_OnFriendsUpdateInfo {
    #[doc = " Client-specified data passed into EOS_Friends_AddNotifyFriendsUpdate"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Account ID of the local user who is receiving the update"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Account ID of the user whose status is being updated."]
    pub TargetUserId: EOS_EpicAccountId,
    #[doc = " The previous status of the user."]
    pub PreviousStatus: EOS_EFriendsStatus,
    #[doc = " The current status of the user."]
    pub CurrentStatus: EOS_EFriendsStatus,
}
#[test]
fn bindgen_test_layout__tagEOS_Friends_OnFriendsUpdateInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Friends_OnFriendsUpdateInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Friends_OnFriendsUpdateInfo>(),
        32usize,
        concat!("Size of: ", stringify!(_tagEOS_Friends_OnFriendsUpdateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Friends_OnFriendsUpdateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Friends_OnFriendsUpdateInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_OnFriendsUpdateInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_OnFriendsUpdateInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_OnFriendsUpdateInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PreviousStatus) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_OnFriendsUpdateInfo),
            "::",
            stringify!(PreviousStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurrentStatus) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_OnFriendsUpdateInfo),
            "::",
            stringify!(CurrentStatus)
        )
    );
}
pub type EOS_Friends_OnFriendsUpdateInfo = _tagEOS_Friends_OnFriendsUpdateInfo;
pub type EOS_Friends_OnFriendsUpdateCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Friends_OnFriendsUpdateInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Friends_GetBlockedUsersCountOptions {
    #[doc = " API Version: Set this to EOS_FRIENDS_GETBLOCKEDUSERSCOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the user whose blocked users should be counted."]
    pub LocalUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Friends_GetBlockedUsersCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Friends_GetBlockedUsersCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Friends_GetBlockedUsersCountOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Friends_GetBlockedUsersCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Friends_GetBlockedUsersCountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Friends_GetBlockedUsersCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_GetBlockedUsersCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_GetBlockedUsersCountOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Friends_GetBlockedUsersCountOptions = _tagEOS_Friends_GetBlockedUsersCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Friends_GetBlockedUserAtIndexOptions {
    #[doc = " API Version: Set this to EOS_FRIENDS_GETBLOCKEDUSERATINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the user whose blocked users list is being queried."]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " Index into the blocked users list. This value must be between 0 and EOS_Friends_GetBlockedUsersCount-1 inclusively."]
    pub Index: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Friends_GetBlockedUserAtIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Friends_GetBlockedUserAtIndexOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Friends_GetBlockedUserAtIndexOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Friends_GetBlockedUserAtIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Friends_GetBlockedUserAtIndexOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Friends_GetBlockedUserAtIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_GetBlockedUserAtIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_GetBlockedUserAtIndexOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Index) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_GetBlockedUserAtIndexOptions),
            "::",
            stringify!(Index)
        )
    );
}
pub type EOS_Friends_GetBlockedUserAtIndexOptions = _tagEOS_Friends_GetBlockedUserAtIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Friends_AddNotifyBlockedUsersUpdateOptions {
    #[doc = " API Version: Set this to EOS_FRIENDS_ADDNOTIFYBLOCKEDUSERSUPDATE_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Friends_AddNotifyBlockedUsersUpdateOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Friends_AddNotifyBlockedUsersUpdateOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Friends_AddNotifyBlockedUsersUpdateOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Friends_AddNotifyBlockedUsersUpdateOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Friends_AddNotifyBlockedUsersUpdateOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Friends_AddNotifyBlockedUsersUpdateOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_AddNotifyBlockedUsersUpdateOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Friends_AddNotifyBlockedUsersUpdateOptions =
    _tagEOS_Friends_AddNotifyBlockedUsersUpdateOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Friends_OnBlockedUsersUpdateInfo {
    #[doc = " Client-specified data passed into EOS_Friends_AddNotifyBlockedUsersUpdate"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Account ID of the local user who is receiving the update"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Account ID of the user whose blocked status is being updated."]
    pub TargetUserId: EOS_EpicAccountId,
    #[doc = " TargetUserId block status (blocked or not)."]
    pub bBlocked: EOS_Bool,
}
#[test]
fn bindgen_test_layout__tagEOS_Friends_OnBlockedUsersUpdateInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Friends_OnBlockedUsersUpdateInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Friends_OnBlockedUsersUpdateInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Friends_OnBlockedUsersUpdateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Friends_OnBlockedUsersUpdateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Friends_OnBlockedUsersUpdateInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_OnBlockedUsersUpdateInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_OnBlockedUsersUpdateInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_OnBlockedUsersUpdateInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bBlocked) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Friends_OnBlockedUsersUpdateInfo),
            "::",
            stringify!(bBlocked)
        )
    );
}
pub type EOS_Friends_OnBlockedUsersUpdateInfo = _tagEOS_Friends_OnBlockedUsersUpdateInfo;
pub type EOS_Friends_OnBlockedUsersUpdateCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Friends_OnBlockedUsersUpdateInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_PresenceHandle {
    _unused: [u8; 0],
}
pub type EOS_HPresence = *mut EOS_PresenceHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_PresenceModificationHandle {
    _unused: [u8; 0],
}
pub type EOS_HPresenceModification = *mut EOS_PresenceModificationHandle;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_Presence_EStatus {
    #[doc = " The status of the account is offline or not known"]
    EOS_PS_Offline = 0,
    #[doc = " The status of the account is online"]
    EOS_PS_Online = 1,
    #[doc = " The status of the account is away"]
    EOS_PS_Away = 2,
    #[doc = " The status of the account is away, and has been away for a while"]
    EOS_PS_ExtendedAway = 3,
    #[doc = " The status of the account is do-not-disturb"]
    EOS_PS_DoNotDisturb = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Presence_DataRecord {
    #[doc = " API Version: Set this to EOS_PRESENCE_DATARECORD_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The name of this data"]
    pub Key: *const ::std::os::raw::c_char,
    #[doc = " The value of this data"]
    pub Value: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Presence_DataRecord() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Presence_DataRecord> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Presence_DataRecord>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Presence_DataRecord))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Presence_DataRecord>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Presence_DataRecord))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_DataRecord),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_DataRecord),
            "::",
            stringify!(Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_DataRecord),
            "::",
            stringify!(Value)
        )
    );
}
pub type EOS_Presence_DataRecord = _tagEOS_Presence_DataRecord;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Presence_Info {
    #[doc = " API Version: Set this to EOS_PRESENCE_INFO_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The status of the user"]
    pub Status: EOS_Presence_EStatus,
    #[doc = " The Epic Account ID of the user"]
    pub UserId: EOS_EpicAccountId,
    #[doc = " The product ID that the user is logged in from"]
    pub ProductId: *const ::std::os::raw::c_char,
    #[doc = " The version of the product the user is logged in from"]
    pub ProductVersion: *const ::std::os::raw::c_char,
    #[doc = " The platform of that the user is logged in from"]
    pub Platform: *const ::std::os::raw::c_char,
    #[doc = " The rich-text of the user"]
    pub RichText: *const ::std::os::raw::c_char,
    #[doc = " The count of records available"]
    pub RecordsCount: i32,
    #[doc = " The first data record, or NULL if RecordsCount is not at least 1"]
    pub Records: *const EOS_Presence_DataRecord,
    #[doc = " The user-facing name for the product the user is logged in from"]
    pub ProductName: *const ::std::os::raw::c_char,
    #[doc = " The integrated platform that the user is logged in with"]
    pub IntegratedPlatform: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Presence_Info() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Presence_Info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Presence_Info>(),
        80usize,
        concat!("Size of: ", stringify!(_tagEOS_Presence_Info))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Presence_Info>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Presence_Info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_Info),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_Info),
            "::",
            stringify!(Status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_Info),
            "::",
            stringify!(UserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProductId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_Info),
            "::",
            stringify!(ProductId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProductVersion) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_Info),
            "::",
            stringify!(ProductVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Platform) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_Info),
            "::",
            stringify!(Platform)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RichText) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_Info),
            "::",
            stringify!(RichText)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RecordsCount) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_Info),
            "::",
            stringify!(RecordsCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Records) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_Info),
            "::",
            stringify!(Records)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProductName) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_Info),
            "::",
            stringify!(ProductName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IntegratedPlatform) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_Info),
            "::",
            stringify!(IntegratedPlatform)
        )
    );
}
pub type EOS_Presence_Info = _tagEOS_Presence_Info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Presence_QueryPresenceOptions {
    #[doc = " API Version: Set this to EOS_PRESENCE_QUERYPRESENCE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local, logged-in user making the request"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Account ID of the user whose presence data you want to retrieve; this value must be either the user making the request, or a friend of that user"]
    pub TargetUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Presence_QueryPresenceOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Presence_QueryPresenceOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Presence_QueryPresenceOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Presence_QueryPresenceOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Presence_QueryPresenceOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Presence_QueryPresenceOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_QueryPresenceOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_QueryPresenceOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_QueryPresenceOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Presence_QueryPresenceOptions = _tagEOS_Presence_QueryPresenceOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Presence_QueryPresenceCallbackInfo {
    #[doc = " Result code for the operation. EOS_Success is returned for a successful query, other codes indicate an error"]
    pub ResultCode: EOS_EResult,
    #[doc = " Client-specified data passed into EOS_Presence_QueryPresence"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Account ID of the local user who made this request"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Account ID of the user whose presence was potentially queried"]
    pub TargetUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Presence_QueryPresenceCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Presence_QueryPresenceCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Presence_QueryPresenceCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Presence_QueryPresenceCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Presence_QueryPresenceCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Presence_QueryPresenceCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_QueryPresenceCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_QueryPresenceCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_QueryPresenceCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_QueryPresenceCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Presence_QueryPresenceCallbackInfo = _tagEOS_Presence_QueryPresenceCallbackInfo;
pub type EOS_Presence_OnQueryPresenceCompleteCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Presence_QueryPresenceCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Presence_HasPresenceOptions {
    #[doc = " API Version: Set this to EOS_PRESENCE_HASPRESENCE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local, logged-in user making the request"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Account ID of the user whose cached presence data you want to locate"]
    pub TargetUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Presence_HasPresenceOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Presence_HasPresenceOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Presence_HasPresenceOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Presence_HasPresenceOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Presence_HasPresenceOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Presence_HasPresenceOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_HasPresenceOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_HasPresenceOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_HasPresenceOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Presence_HasPresenceOptions = _tagEOS_Presence_HasPresenceOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Presence_CopyPresenceOptions {
    #[doc = " API Version: Set this to EOS_PRESENCE_COPYPRESENCE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local, logged-in user making the request"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Account ID of the user whose cached presence data you want to copy from the cache"]
    pub TargetUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Presence_CopyPresenceOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Presence_CopyPresenceOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Presence_CopyPresenceOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Presence_CopyPresenceOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Presence_CopyPresenceOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Presence_CopyPresenceOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_CopyPresenceOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_CopyPresenceOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_CopyPresenceOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Presence_CopyPresenceOptions = _tagEOS_Presence_CopyPresenceOptions;
extern "C" {
    #[doc = " Release the memory associated with an EOS_Presence_Info structure and its sub-objects. This must be called on data retrieved from EOS_Presence_CopyPresence.\n This can be safely called on a NULL presence info object.\n\n @param PresenceInfo The presence info structure to be release"]
    pub fn EOS_Presence_Info_Release(PresenceInfo: *mut EOS_Presence_Info);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Presence_CreatePresenceModificationOptions {
    #[doc = " API Version: Set this to EOS_PRESENCE_CREATEPRESENCEMODIFICATION_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local, logged-in user making the request"]
    pub LocalUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Presence_CreatePresenceModificationOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Presence_CreatePresenceModificationOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Presence_CreatePresenceModificationOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Presence_CreatePresenceModificationOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Presence_CreatePresenceModificationOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Presence_CreatePresenceModificationOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_CreatePresenceModificationOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_CreatePresenceModificationOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Presence_CreatePresenceModificationOptions =
    _tagEOS_Presence_CreatePresenceModificationOptions;
extern "C" {
    #[doc = " Release the memory associated with an EOS_HPresenceModification handle. This must be called on Handles retrieved from EOS_Presence_CreatePresenceModification.\n This can be safely called on a NULL presence modification handle. This also may be safely called while a call to SetPresence is still pending.\n\n @param PresenceModificationHandle The presence modification handle to release\n\n @see EOS_Presence_CreatePresenceModification"]
    pub fn EOS_PresenceModification_Release(PresenceModificationHandle: EOS_HPresenceModification);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Presence_SetPresenceOptions {
    #[doc = " API Version: Set this to EOS_PRESENCE_SETPRESENCE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local, logged-in user making the request"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The handle to the presence update"]
    pub PresenceModificationHandle: EOS_HPresenceModification,
}
#[test]
fn bindgen_test_layout__tagEOS_Presence_SetPresenceOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Presence_SetPresenceOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Presence_SetPresenceOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Presence_SetPresenceOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Presence_SetPresenceOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Presence_SetPresenceOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_SetPresenceOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_SetPresenceOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PresenceModificationHandle) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_SetPresenceOptions),
            "::",
            stringify!(PresenceModificationHandle)
        )
    );
}
pub type EOS_Presence_SetPresenceOptions = _tagEOS_Presence_SetPresenceOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Presence_SetPresenceCallbackInfo {
    #[doc = " Result code for the operation. EOS_Success is returned if presence was successfully set, other codes indicate an error"]
    pub ResultCode: EOS_EResult,
    #[doc = " Client-specified data passed into EOS_Presence_SetPresence"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Account ID of the local user that had their presence set"]
    pub LocalUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Presence_SetPresenceCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Presence_SetPresenceCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Presence_SetPresenceCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Presence_SetPresenceCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Presence_SetPresenceCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Presence_SetPresenceCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_SetPresenceCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_SetPresenceCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_SetPresenceCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Presence_SetPresenceCallbackInfo = _tagEOS_Presence_SetPresenceCallbackInfo;
pub type EOS_Presence_SetPresenceCompleteCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Presence_SetPresenceCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Presence_AddNotifyOnPresenceChangedOptions {
    #[doc = " API Version: Set this to EOS_PRESENCE_ADDNOTIFYONPRESENCECHANGED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Presence_AddNotifyOnPresenceChangedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Presence_AddNotifyOnPresenceChangedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Presence_AddNotifyOnPresenceChangedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Presence_AddNotifyOnPresenceChangedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Presence_AddNotifyOnPresenceChangedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Presence_AddNotifyOnPresenceChangedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_AddNotifyOnPresenceChangedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Presence_AddNotifyOnPresenceChangedOptions =
    _tagEOS_Presence_AddNotifyOnPresenceChangedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Presence_PresenceChangedCallbackInfo {
    #[doc = " Client-specified data passed into EOS_Presence_AddNotifyOnPresenceChanged"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Account ID of the local user who is being informed for PresenceUserId's presence change"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Account ID of the user who had their presence changed"]
    pub PresenceUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Presence_PresenceChangedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Presence_PresenceChangedCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Presence_PresenceChangedCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Presence_PresenceChangedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Presence_PresenceChangedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Presence_PresenceChangedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_PresenceChangedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_PresenceChangedCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PresenceUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_PresenceChangedCallbackInfo),
            "::",
            stringify!(PresenceUserId)
        )
    );
}
pub type EOS_Presence_PresenceChangedCallbackInfo = _tagEOS_Presence_PresenceChangedCallbackInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Presence_AddNotifyJoinGameAcceptedOptions {
    #[doc = " API Version: Set this to EOS_PRESENCE_ADDNOTIFYJOINGAMEACCEPTED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Presence_AddNotifyJoinGameAcceptedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Presence_AddNotifyJoinGameAcceptedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Presence_AddNotifyJoinGameAcceptedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Presence_AddNotifyJoinGameAcceptedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Presence_AddNotifyJoinGameAcceptedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Presence_AddNotifyJoinGameAcceptedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_AddNotifyJoinGameAcceptedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Presence_AddNotifyJoinGameAcceptedOptions =
    _tagEOS_Presence_AddNotifyJoinGameAcceptedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Presence_JoinGameAcceptedCallbackInfo {
    #[doc = " Context that was passed into EOS_Presence_AddNotifyJoinGameAccepted"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Join Info custom game-data string to use to join the target user.\n Set to a null pointer to delete the value."]
    pub JoinInfo: *const ::std::os::raw::c_char,
    #[doc = " The Epic Account ID of the user who accepted the invitation"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Account ID of the user who sent the invitation"]
    pub TargetUserId: EOS_EpicAccountId,
    #[doc = " If the value is not EOS_UI_EVENTID_INVALID then it must be passed back to the SDK using EOS_UI_AcknowledgeEventId.\n This should be done after attempting to join the game and either succeeding or failing to connect.\n This is necessary to allow the Social Overlay UI to manage the `Join` button."]
    pub UiEventId: EOS_UI_EventId,
}
#[test]
fn bindgen_test_layout__tagEOS_Presence_JoinGameAcceptedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Presence_JoinGameAcceptedCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Presence_JoinGameAcceptedCallbackInfo>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Presence_JoinGameAcceptedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Presence_JoinGameAcceptedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Presence_JoinGameAcceptedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_JoinGameAcceptedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).JoinInfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_JoinGameAcceptedCallbackInfo),
            "::",
            stringify!(JoinInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_JoinGameAcceptedCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_JoinGameAcceptedCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UiEventId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_JoinGameAcceptedCallbackInfo),
            "::",
            stringify!(UiEventId)
        )
    );
}
pub type EOS_Presence_JoinGameAcceptedCallbackInfo = _tagEOS_Presence_JoinGameAcceptedCallbackInfo;
pub type EOS_Presence_OnJoinGameAcceptedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Presence_JoinGameAcceptedCallbackInfo),
>;
pub type EOS_Presence_OnPresenceChangedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Presence_PresenceChangedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Presence_GetJoinInfoOptions {
    #[doc = " API Version: Set this to EOS_PRESENCE_GETJOININFO_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The local user's Epic Account ID"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Account ID to query for join info; this value must either be a logged-in local user, or a friend of that user"]
    pub TargetUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_Presence_GetJoinInfoOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Presence_GetJoinInfoOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Presence_GetJoinInfoOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Presence_GetJoinInfoOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Presence_GetJoinInfoOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Presence_GetJoinInfoOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_GetJoinInfoOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_GetJoinInfoOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Presence_GetJoinInfoOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Presence_GetJoinInfoOptions = _tagEOS_Presence_GetJoinInfoOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PresenceModification_SetJoinInfoOptions {
    #[doc = " API Version: Set this to EOS_PRESENCEMODIFICATION_SETJOININFO_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The string which will be advertised as this player's join info.\n An application is expected to freely define the meaning of this string to use for connecting to an active game session.\n The string should not exceed EOS_PRESENCEMODIFICATION_JOININFO_MAX_LENGTH in length.\n This affects the ability of the Social Overlay to show game related actions to take in the player's social graph.\n\n @note The Social Overlay can handle only one of the following three options at a time:\n * using the bPresenceEnabled flags within the Sessions interface\n * using the bPresenceEnabled flags within the Lobby interface\n * using EOS_PresenceModification_SetJoinInfo\n\n @see EOS_Lobby_CreateLobbyOptions\n @see EOS_Lobby_JoinLobbyOptions\n @see EOS_Sessions_CreateSessionModificationOptions\n @see EOS_Sessions_JoinSessionOptions"]
    pub JoinInfo: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_PresenceModification_SetJoinInfoOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_PresenceModification_SetJoinInfoOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PresenceModification_SetJoinInfoOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_PresenceModification_SetJoinInfoOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PresenceModification_SetJoinInfoOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_PresenceModification_SetJoinInfoOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PresenceModification_SetJoinInfoOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).JoinInfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PresenceModification_SetJoinInfoOptions),
            "::",
            stringify!(JoinInfo)
        )
    );
}
pub type EOS_PresenceModification_SetJoinInfoOptions =
    _tagEOS_PresenceModification_SetJoinInfoOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PresenceModification_SetStatusOptions {
    #[doc = " API Version: Set this to EOS_PRESENCEMODIFICATION_SETSTATUS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The status of the user"]
    pub Status: EOS_Presence_EStatus,
}
#[test]
fn bindgen_test_layout__tagEOS_PresenceModification_SetStatusOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_PresenceModification_SetStatusOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PresenceModification_SetStatusOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_PresenceModification_SetStatusOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PresenceModification_SetStatusOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_PresenceModification_SetStatusOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PresenceModification_SetStatusOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PresenceModification_SetStatusOptions),
            "::",
            stringify!(Status)
        )
    );
}
pub type EOS_PresenceModification_SetStatusOptions = _tagEOS_PresenceModification_SetStatusOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PresenceModification_SetRawRichTextOptions {
    #[doc = " API Version: Set this to EOS_PRESENCEMODIFICATION_SETRAWRICHTEXT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The status of the user"]
    pub RichText: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_PresenceModification_SetRawRichTextOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_PresenceModification_SetRawRichTextOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PresenceModification_SetRawRichTextOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_PresenceModification_SetRawRichTextOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PresenceModification_SetRawRichTextOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_PresenceModification_SetRawRichTextOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PresenceModification_SetRawRichTextOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RichText) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PresenceModification_SetRawRichTextOptions),
            "::",
            stringify!(RichText)
        )
    );
}
pub type EOS_PresenceModification_SetRawRichTextOptions =
    _tagEOS_PresenceModification_SetRawRichTextOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PresenceModification_SetDataOptions {
    #[doc = " API Version: Set this to EOS_PRESENCEMODIFICATION_SETDATA_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The count of records to set"]
    pub RecordsCount: i32,
    #[doc = " The pointer to start of a sequential array of Presence DataRecords"]
    pub Records: *const EOS_Presence_DataRecord,
}
#[test]
fn bindgen_test_layout__tagEOS_PresenceModification_SetDataOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_PresenceModification_SetDataOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PresenceModification_SetDataOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_PresenceModification_SetDataOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PresenceModification_SetDataOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_PresenceModification_SetDataOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PresenceModification_SetDataOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RecordsCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PresenceModification_SetDataOptions),
            "::",
            stringify!(RecordsCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Records) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PresenceModification_SetDataOptions),
            "::",
            stringify!(Records)
        )
    );
}
pub type EOS_PresenceModification_SetDataOptions = _tagEOS_PresenceModification_SetDataOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PresenceModification_DataRecordId {
    #[doc = " API Version: Set this to EOS_PRESENCEMODIFICATION_DATARECORDID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The key to be deleted from the data record"]
    pub Key: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_PresenceModification_DataRecordId() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_PresenceModification_DataRecordId> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PresenceModification_DataRecordId>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_PresenceModification_DataRecordId)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PresenceModification_DataRecordId>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_PresenceModification_DataRecordId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PresenceModification_DataRecordId),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PresenceModification_DataRecordId),
            "::",
            stringify!(Key)
        )
    );
}
pub type EOS_PresenceModification_DataRecordId = _tagEOS_PresenceModification_DataRecordId;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PresenceModification_DeleteDataOptions {
    #[doc = " API Version: Set this to EOS_PRESENCEMODIFICATION_DELETEDATA_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The count of data keys to delete"]
    pub RecordsCount: i32,
    #[doc = " The pointer to start of a sequential array"]
    pub Records: *const EOS_PresenceModification_DataRecordId,
}
#[test]
fn bindgen_test_layout__tagEOS_PresenceModification_DeleteDataOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_PresenceModification_DeleteDataOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PresenceModification_DeleteDataOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_PresenceModification_DeleteDataOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PresenceModification_DeleteDataOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_PresenceModification_DeleteDataOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PresenceModification_DeleteDataOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RecordsCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PresenceModification_DeleteDataOptions),
            "::",
            stringify!(RecordsCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Records) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PresenceModification_DeleteDataOptions),
            "::",
            stringify!(Records)
        )
    );
}
pub type EOS_PresenceModification_DeleteDataOptions =
    _tagEOS_PresenceModification_DeleteDataOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_P2PHandle {
    _unused: [u8; 0],
}
pub type EOS_HP2P = *mut EOS_P2PHandle;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_ENATType {
    #[doc = " NAT type either unknown (remote) or we are unable to determine it (local)"]
    EOS_NAT_Unknown = 0,
    #[doc = " All peers can directly-connect to you"]
    EOS_NAT_Open = 1,
    #[doc = " You can directly-connect to other Moderate and Open peers"]
    EOS_NAT_Moderate = 2,
    #[doc = " You can only directly-connect to Open peers"]
    EOS_NAT_Strict = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_SocketId {
    #[doc = " API Version: Set this to EOS_P2P_SOCKETID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " A name for the connection. Must be a NULL-terminated string of between 1-32 alpha-numeric characters (A-Z, a-z, 0-9, '-', '_', ' ', '+', '=', '.')"]
    pub SocketName: [::std::os::raw::c_char; 33usize],
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_SocketId() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_SocketId> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_SocketId>(),
        40usize,
        concat!("Size of: ", stringify!(_tagEOS_P2P_SocketId))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_SocketId>(),
        4usize,
        concat!("Alignment of ", stringify!(_tagEOS_P2P_SocketId))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_SocketId),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SocketName) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_SocketId),
            "::",
            stringify!(SocketName)
        )
    );
}
pub type EOS_P2P_SocketId = _tagEOS_P2P_SocketId;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EPacketReliability {
    #[doc = " Packets will only be sent once and may be received out of order"]
    EOS_PR_UnreliableUnordered = 0,
    #[doc = " Packets may be sent multiple times and may be received out of order"]
    EOS_PR_ReliableUnordered = 1,
    #[doc = " Packets may be sent multiple times and will be received in order"]
    EOS_PR_ReliableOrdered = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_SendPacketOptions {
    #[doc = " API Version: Set this to EOS_P2P_SENDPACKET_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user who is sending this packet"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The Product User ID of the Peer you would like to send a packet to"]
    pub RemoteUserId: EOS_ProductUserId,
    #[doc = " The socket ID for data you are sending in this packet"]
    pub SocketId: *const EOS_P2P_SocketId,
    #[doc = " Channel associated with this data"]
    pub Channel: u8,
    #[doc = " The size of the data to be sent to the RemoteUser"]
    pub DataLengthBytes: u32,
    #[doc = " The data to be sent to the RemoteUser"]
    pub Data: *const ::std::os::raw::c_void,
    #[doc = " If false and we do not already have an established connection to the peer, this data will be dropped"]
    pub bAllowDelayedDelivery: EOS_Bool,
    #[doc = " Setting to control the delivery reliability of this packet"]
    pub Reliability: EOS_EPacketReliability,
    #[doc = " If set to EOS_TRUE, EOS_P2P_SendPacket will not automatically establish a connection with the RemoteUserId and will require explicit calls to\n EOS_P2P_AcceptConnection first whenever the connection is closed. If set to EOS_FALSE, EOS_P2P_SendPacket will automatically accept and start\n the connection any time it is called and the connection is not already open."]
    pub bDisableAutoAcceptConnection: EOS_Bool,
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_SendPacketOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_SendPacketOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_SendPacketOptions>(),
        64usize,
        concat!("Size of: ", stringify!(_tagEOS_P2P_SendPacketOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_SendPacketOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_P2P_SendPacketOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_SendPacketOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_SendPacketOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RemoteUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_SendPacketOptions),
            "::",
            stringify!(RemoteUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SocketId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_SendPacketOptions),
            "::",
            stringify!(SocketId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Channel) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_SendPacketOptions),
            "::",
            stringify!(Channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataLengthBytes) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_SendPacketOptions),
            "::",
            stringify!(DataLengthBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_SendPacketOptions),
            "::",
            stringify!(Data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bAllowDelayedDelivery) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_SendPacketOptions),
            "::",
            stringify!(bAllowDelayedDelivery)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reliability) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_SendPacketOptions),
            "::",
            stringify!(Reliability)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).bDisableAutoAcceptConnection) as usize - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_SendPacketOptions),
            "::",
            stringify!(bDisableAutoAcceptConnection)
        )
    );
}
pub type EOS_P2P_SendPacketOptions = _tagEOS_P2P_SendPacketOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_GetNextReceivedPacketSizeOptions {
    #[doc = " API Version: Set this to EOS_P2P_GETNEXTRECEIVEDPACKETSIZE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user who is receiving the packet"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " An optional channel to request the data for. If NULL, we're retrieving the size of the next packet on any channel."]
    pub RequestedChannel: *const u8,
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_GetNextReceivedPacketSizeOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_GetNextReceivedPacketSizeOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_GetNextReceivedPacketSizeOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_P2P_GetNextReceivedPacketSizeOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_GetNextReceivedPacketSizeOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_P2P_GetNextReceivedPacketSizeOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_GetNextReceivedPacketSizeOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_GetNextReceivedPacketSizeOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RequestedChannel) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_GetNextReceivedPacketSizeOptions),
            "::",
            stringify!(RequestedChannel)
        )
    );
}
pub type EOS_P2P_GetNextReceivedPacketSizeOptions = _tagEOS_P2P_GetNextReceivedPacketSizeOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_ReceivePacketOptions {
    #[doc = " API Version: Set this to EOS_P2P_RECEIVEPACKET_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the user who is receiving the packet"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The maximum amount of data in bytes that can be safely copied to OutData in the function call"]
    pub MaxDataSizeBytes: u32,
    #[doc = " An optional channel to request the data for. If NULL, we're retrieving the next packet on any channel"]
    pub RequestedChannel: *const u8,
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_ReceivePacketOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_ReceivePacketOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_ReceivePacketOptions>(),
        32usize,
        concat!("Size of: ", stringify!(_tagEOS_P2P_ReceivePacketOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_ReceivePacketOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_P2P_ReceivePacketOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_ReceivePacketOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_ReceivePacketOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxDataSizeBytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_ReceivePacketOptions),
            "::",
            stringify!(MaxDataSizeBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RequestedChannel) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_ReceivePacketOptions),
            "::",
            stringify!(RequestedChannel)
        )
    );
}
pub type EOS_P2P_ReceivePacketOptions = _tagEOS_P2P_ReceivePacketOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_AddNotifyPeerConnectionRequestOptions {
    #[doc = " API Version: Set this to EOS_P2P_ADDNOTIFYPEERCONNECTIONREQUEST_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the user who is listening for incoming connection requests"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The optional socket ID to listen for, used as a filter for incoming connection requests; If NULL, incoming connection requests will not be filtered"]
    pub SocketId: *const EOS_P2P_SocketId,
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_AddNotifyPeerConnectionRequestOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_AddNotifyPeerConnectionRequestOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_AddNotifyPeerConnectionRequestOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_P2P_AddNotifyPeerConnectionRequestOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_AddNotifyPeerConnectionRequestOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_P2P_AddNotifyPeerConnectionRequestOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_AddNotifyPeerConnectionRequestOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_AddNotifyPeerConnectionRequestOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SocketId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_AddNotifyPeerConnectionRequestOptions),
            "::",
            stringify!(SocketId)
        )
    );
}
pub type EOS_P2P_AddNotifyPeerConnectionRequestOptions =
    _tagEOS_P2P_AddNotifyPeerConnectionRequestOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_OnIncomingConnectionRequestInfo {
    #[doc = " Client-specified data passed into EOS_Presence_AddNotifyOnPresenceChanged"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the local user who is being requested to open a P2P session with RemoteUserId"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The Product User ID of the remote user who requested a peer connection with the local user"]
    pub RemoteUserId: EOS_ProductUserId,
    #[doc = " The ID of the socket the Remote User wishes to communicate on"]
    pub SocketId: *const EOS_P2P_SocketId,
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_OnIncomingConnectionRequestInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_OnIncomingConnectionRequestInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_OnIncomingConnectionRequestInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_P2P_OnIncomingConnectionRequestInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_OnIncomingConnectionRequestInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_P2P_OnIncomingConnectionRequestInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnIncomingConnectionRequestInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnIncomingConnectionRequestInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RemoteUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnIncomingConnectionRequestInfo),
            "::",
            stringify!(RemoteUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SocketId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnIncomingConnectionRequestInfo),
            "::",
            stringify!(SocketId)
        )
    );
}
pub type EOS_P2P_OnIncomingConnectionRequestInfo = _tagEOS_P2P_OnIncomingConnectionRequestInfo;
pub type EOS_P2P_OnIncomingConnectionRequestCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_P2P_OnIncomingConnectionRequestInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_AddNotifyPeerConnectionEstablishedOptions {
    #[doc = " API Version: Set this to EOS_P2P_ADDNOTIFYPEERCONNECTIONESTABLISHED_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user who would like to receive notifications"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The optional socket ID, used as a filter for established connections. If NULL, this function handler will be called for all sockets"]
    pub SocketId: *const EOS_P2P_SocketId,
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_AddNotifyPeerConnectionEstablishedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_AddNotifyPeerConnectionEstablishedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_AddNotifyPeerConnectionEstablishedOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_P2P_AddNotifyPeerConnectionEstablishedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_AddNotifyPeerConnectionEstablishedOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_P2P_AddNotifyPeerConnectionEstablishedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_AddNotifyPeerConnectionEstablishedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_AddNotifyPeerConnectionEstablishedOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SocketId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_AddNotifyPeerConnectionEstablishedOptions),
            "::",
            stringify!(SocketId)
        )
    );
}
pub type EOS_P2P_AddNotifyPeerConnectionEstablishedOptions =
    _tagEOS_P2P_AddNotifyPeerConnectionEstablishedOptions;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EConnectionEstablishedType {
    #[doc = " The connection is brand new"]
    EOS_CET_NewConnection = 0,
    #[doc = " The connection is reestablished (reconnection)"]
    EOS_CET_Reconnection = 1,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_ENetworkConnectionType {
    #[doc = " There is no established connection"]
    EOS_NCT_NoConnection = 0,
    #[doc = " A direct connection to the peer over the Internet or Local Network"]
    EOS_NCT_DirectConnection = 1,
    #[doc = " A relayed connection using Epic-provided servers to the peer over the Internet"]
    EOS_NCT_RelayedConnection = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_OnPeerConnectionEstablishedInfo {
    #[doc = " Client-specified data passed into EOS_P2P_AddNotifyPeerConnectionEstablished"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the local user who is being notified of a connection being established"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The Product User ID of the remote user who this connection was with"]
    pub RemoteUserId: EOS_ProductUserId,
    #[doc = " The socket ID of the connection being established"]
    pub SocketId: *const EOS_P2P_SocketId,
    #[doc = " Information if this is a new connection or reconnection"]
    pub ConnectionType: EOS_EConnectionEstablishedType,
    #[doc = " What type of network connection is being used for this connection"]
    pub NetworkType: EOS_ENetworkConnectionType,
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_OnPeerConnectionEstablishedInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_OnPeerConnectionEstablishedInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_OnPeerConnectionEstablishedInfo>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_P2P_OnPeerConnectionEstablishedInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_OnPeerConnectionEstablishedInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_P2P_OnPeerConnectionEstablishedInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnPeerConnectionEstablishedInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnPeerConnectionEstablishedInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RemoteUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnPeerConnectionEstablishedInfo),
            "::",
            stringify!(RemoteUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SocketId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnPeerConnectionEstablishedInfo),
            "::",
            stringify!(SocketId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectionType) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnPeerConnectionEstablishedInfo),
            "::",
            stringify!(ConnectionType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NetworkType) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnPeerConnectionEstablishedInfo),
            "::",
            stringify!(NetworkType)
        )
    );
}
pub type EOS_P2P_OnPeerConnectionEstablishedInfo = _tagEOS_P2P_OnPeerConnectionEstablishedInfo;
pub type EOS_P2P_OnPeerConnectionEstablishedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_P2P_OnPeerConnectionEstablishedInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_AddNotifyPeerConnectionInterruptedOptions {
    #[doc = " API Version: Set this to EOS_P2P_ADDNOTIFYPEERCONNECTIONINTERRUPTED_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user who would like notifications"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " An optional socket ID to filter interrupted connections on. If NULL, this function handler will be called for all interrupted connections"]
    pub SocketId: *const EOS_P2P_SocketId,
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_AddNotifyPeerConnectionInterruptedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_AddNotifyPeerConnectionInterruptedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_AddNotifyPeerConnectionInterruptedOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_P2P_AddNotifyPeerConnectionInterruptedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_AddNotifyPeerConnectionInterruptedOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_P2P_AddNotifyPeerConnectionInterruptedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_AddNotifyPeerConnectionInterruptedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_AddNotifyPeerConnectionInterruptedOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SocketId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_AddNotifyPeerConnectionInterruptedOptions),
            "::",
            stringify!(SocketId)
        )
    );
}
pub type EOS_P2P_AddNotifyPeerConnectionInterruptedOptions =
    _tagEOS_P2P_AddNotifyPeerConnectionInterruptedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_OnPeerConnectionInterruptedInfo {
    #[doc = " Client-specified data passed into EOS_Presence_AddNotifyOnPresenceChanged"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The local user who is being notified of a connection that was interrupted"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The Product User ID of the remote user who this connection was with"]
    pub RemoteUserId: EOS_ProductUserId,
    #[doc = " The socket ID of the connection that was interrupted"]
    pub SocketId: *const EOS_P2P_SocketId,
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_OnPeerConnectionInterruptedInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_OnPeerConnectionInterruptedInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_OnPeerConnectionInterruptedInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_P2P_OnPeerConnectionInterruptedInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_OnPeerConnectionInterruptedInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_P2P_OnPeerConnectionInterruptedInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnPeerConnectionInterruptedInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnPeerConnectionInterruptedInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RemoteUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnPeerConnectionInterruptedInfo),
            "::",
            stringify!(RemoteUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SocketId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnPeerConnectionInterruptedInfo),
            "::",
            stringify!(SocketId)
        )
    );
}
pub type EOS_P2P_OnPeerConnectionInterruptedInfo = _tagEOS_P2P_OnPeerConnectionInterruptedInfo;
pub type EOS_P2P_OnPeerConnectionInterruptedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_P2P_OnPeerConnectionInterruptedInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_AddNotifyPeerConnectionClosedOptions {
    #[doc = " API Version: Set this to EOS_P2P_ADDNOTIFYPEERCONNECTIONCLOSED_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user who would like notifications"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The optional socket ID to listen for to be closed. If NULL, this function handler will be called for all closed connections"]
    pub SocketId: *const EOS_P2P_SocketId,
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_AddNotifyPeerConnectionClosedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_AddNotifyPeerConnectionClosedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_AddNotifyPeerConnectionClosedOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_P2P_AddNotifyPeerConnectionClosedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_AddNotifyPeerConnectionClosedOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_P2P_AddNotifyPeerConnectionClosedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_AddNotifyPeerConnectionClosedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_AddNotifyPeerConnectionClosedOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SocketId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_AddNotifyPeerConnectionClosedOptions),
            "::",
            stringify!(SocketId)
        )
    );
}
pub type EOS_P2P_AddNotifyPeerConnectionClosedOptions =
    _tagEOS_P2P_AddNotifyPeerConnectionClosedOptions;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EConnectionClosedReason {
    #[doc = " The connection was closed for unknown reasons. This most notably happens during application shutdown."]
    EOS_CCR_Unknown = 0,
    #[doc = " The connection was at least locally accepted, but was closed by the local user via a call to EOS_P2P_CloseConnection / EOS_P2P_CloseConnections."]
    EOS_CCR_ClosedByLocalUser = 1,
    #[doc = " The connection was at least locally accepted, but was gracefully closed by the remote user via a call to EOS_P2P_CloseConnection / EOS_P2P_CloseConnections."]
    EOS_CCR_ClosedByPeer = 2,
    #[doc = " The connection was at least locally accepted, but was not remotely accepted in time."]
    EOS_CCR_TimedOut = 3,
    #[doc = " The connection was accepted, but the connection could not be created due to too many other existing connections"]
    EOS_CCR_TooManyConnections = 4,
    #[doc = " The connection was accepted, The remote user sent an invalid message"]
    EOS_CCR_InvalidMessage = 5,
    #[doc = " The connection was accepted, but the remote user sent us invalid data"]
    EOS_CCR_InvalidData = 6,
    #[doc = " The connection was accepted, but we failed to ever establish a connection with the remote user due to connectivity issues."]
    EOS_CCR_ConnectionFailed = 7,
    #[doc = " The connection was accepted and established, but the peer silently went away."]
    EOS_CCR_ConnectionClosed = 8,
    #[doc = " The connection was locally accepted, but we failed to negotiate a connection with the remote user. This most commonly occurs if the local user goes offline or is logged-out during the connection process."]
    EOS_CCR_NegotiationFailed = 9,
    #[doc = " The connection was accepted, but there was an internal error occurred and the connection cannot be created or continue."]
    EOS_CCR_UnexpectedError = 10,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_OnRemoteConnectionClosedInfo {
    #[doc = " Client-specified data passed into EOS_Presence_AddNotifyOnPresenceChanged"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The local user who is being notified of a connection being closed"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The Product User ID of the remote user who this connection was with"]
    pub RemoteUserId: EOS_ProductUserId,
    #[doc = " The socket ID of the connection being closed"]
    pub SocketId: *const EOS_P2P_SocketId,
    #[doc = " The reason the connection was closed (if known)"]
    pub Reason: EOS_EConnectionClosedReason,
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_OnRemoteConnectionClosedInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_OnRemoteConnectionClosedInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_OnRemoteConnectionClosedInfo>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_P2P_OnRemoteConnectionClosedInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_OnRemoteConnectionClosedInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_P2P_OnRemoteConnectionClosedInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnRemoteConnectionClosedInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnRemoteConnectionClosedInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RemoteUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnRemoteConnectionClosedInfo),
            "::",
            stringify!(RemoteUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SocketId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnRemoteConnectionClosedInfo),
            "::",
            stringify!(SocketId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reason) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnRemoteConnectionClosedInfo),
            "::",
            stringify!(Reason)
        )
    );
}
pub type EOS_P2P_OnRemoteConnectionClosedInfo = _tagEOS_P2P_OnRemoteConnectionClosedInfo;
pub type EOS_P2P_OnRemoteConnectionClosedCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_P2P_OnRemoteConnectionClosedInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_AcceptConnectionOptions {
    #[doc = " API Version: Set this to EOS_P2P_ACCEPTCONNECTION_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user who is accepting any pending or future connections with RemoteUserId"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The Product User ID of the remote user who has either sent a connection request or is expected to in the future"]
    pub RemoteUserId: EOS_ProductUserId,
    #[doc = " The socket ID of the connection to accept on"]
    pub SocketId: *const EOS_P2P_SocketId,
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_AcceptConnectionOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_AcceptConnectionOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_AcceptConnectionOptions>(),
        32usize,
        concat!("Size of: ", stringify!(_tagEOS_P2P_AcceptConnectionOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_AcceptConnectionOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_P2P_AcceptConnectionOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_AcceptConnectionOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_AcceptConnectionOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RemoteUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_AcceptConnectionOptions),
            "::",
            stringify!(RemoteUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SocketId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_AcceptConnectionOptions),
            "::",
            stringify!(SocketId)
        )
    );
}
pub type EOS_P2P_AcceptConnectionOptions = _tagEOS_P2P_AcceptConnectionOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_CloseConnectionOptions {
    #[doc = " API Version: Set this to EOS_P2P_CLOSECONNECTION_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user who would like to close a previously accepted connection (or decline a pending invite)"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The Product User ID of the remote user to disconnect from (or to reject a pending invite from)"]
    pub RemoteUserId: EOS_ProductUserId,
    #[doc = " The socket ID of the connection to close (or optionally NULL to not accept any connection requests from the Remote User)"]
    pub SocketId: *const EOS_P2P_SocketId,
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_CloseConnectionOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_CloseConnectionOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_CloseConnectionOptions>(),
        32usize,
        concat!("Size of: ", stringify!(_tagEOS_P2P_CloseConnectionOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_CloseConnectionOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_P2P_CloseConnectionOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_CloseConnectionOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_CloseConnectionOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RemoteUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_CloseConnectionOptions),
            "::",
            stringify!(RemoteUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SocketId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_CloseConnectionOptions),
            "::",
            stringify!(SocketId)
        )
    );
}
pub type EOS_P2P_CloseConnectionOptions = _tagEOS_P2P_CloseConnectionOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_CloseConnectionsOptions {
    #[doc = " API Version: Set this to EOS_P2P_CLOSECONNECTIONS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user who would like to close all connections that use a particular socket ID"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The socket ID of the connections to close"]
    pub SocketId: *const EOS_P2P_SocketId,
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_CloseConnectionsOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_CloseConnectionsOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_CloseConnectionsOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_P2P_CloseConnectionsOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_CloseConnectionsOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_P2P_CloseConnectionsOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_CloseConnectionsOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_CloseConnectionsOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SocketId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_CloseConnectionsOptions),
            "::",
            stringify!(SocketId)
        )
    );
}
pub type EOS_P2P_CloseConnectionsOptions = _tagEOS_P2P_CloseConnectionsOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_QueryNATTypeOptions {
    #[doc = " API Version: Set this to EOS_P2P_QUERYNATTYPE_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_QueryNATTypeOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_QueryNATTypeOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_QueryNATTypeOptions>(),
        4usize,
        concat!("Size of: ", stringify!(_tagEOS_P2P_QueryNATTypeOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_QueryNATTypeOptions>(),
        4usize,
        concat!("Alignment of ", stringify!(_tagEOS_P2P_QueryNATTypeOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_QueryNATTypeOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_P2P_QueryNATTypeOptions = _tagEOS_P2P_QueryNATTypeOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_OnQueryNATTypeCompleteInfo {
    #[doc = " Result code for the operation. EOS_Success is returned for a successful query, other codes indicate an error"]
    pub ResultCode: EOS_EResult,
    #[doc = " Client-specified data passed into EOS_P2P_QueryNATType"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The queried NAT type"]
    pub NATType: EOS_ENATType,
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_OnQueryNATTypeCompleteInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_OnQueryNATTypeCompleteInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_OnQueryNATTypeCompleteInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_P2P_OnQueryNATTypeCompleteInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_OnQueryNATTypeCompleteInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_P2P_OnQueryNATTypeCompleteInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnQueryNATTypeCompleteInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnQueryNATTypeCompleteInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NATType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnQueryNATTypeCompleteInfo),
            "::",
            stringify!(NATType)
        )
    );
}
pub type EOS_P2P_OnQueryNATTypeCompleteInfo = _tagEOS_P2P_OnQueryNATTypeCompleteInfo;
pub type EOS_P2P_OnQueryNATTypeCompleteCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_P2P_OnQueryNATTypeCompleteInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_GetNATTypeOptions {
    #[doc = " API Version: Set this to EOS_P2P_GETNATTYPE_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_GetNATTypeOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_GetNATTypeOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_GetNATTypeOptions>(),
        4usize,
        concat!("Size of: ", stringify!(_tagEOS_P2P_GetNATTypeOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_GetNATTypeOptions>(),
        4usize,
        concat!("Alignment of ", stringify!(_tagEOS_P2P_GetNATTypeOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_GetNATTypeOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_P2P_GetNATTypeOptions = _tagEOS_P2P_GetNATTypeOptions;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_ERelayControl {
    #[doc = " Peer connections will never attempt to use relay servers. Clients with restrictive NATs may not be able to connect to peers."]
    EOS_RC_NoRelays = 0,
    #[doc = " Peer connections will attempt to use relay servers, but only after direct connection attempts fail. This is the default value if not changed."]
    EOS_RC_AllowRelays = 1,
    #[doc = " Peer connections will only ever use relay servers. This will add latency to all connections, but will hide IP Addresses from peers."]
    EOS_RC_ForceRelays = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_SetRelayControlOptions {
    #[doc = " API Version: Set this to EOS_P2P_SETRELAYCONTROL_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The requested level of relay servers for P2P connections. This setting is only applied to new P2P connections, or when existing P2P connections\n reconnect during a temporary connectivity outage. Peers with an incompatible setting to the local setting will not be able to connect."]
    pub RelayControl: EOS_ERelayControl,
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_SetRelayControlOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_SetRelayControlOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_SetRelayControlOptions>(),
        8usize,
        concat!("Size of: ", stringify!(_tagEOS_P2P_SetRelayControlOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_SetRelayControlOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_P2P_SetRelayControlOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_SetRelayControlOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RelayControl) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_SetRelayControlOptions),
            "::",
            stringify!(RelayControl)
        )
    );
}
pub type EOS_P2P_SetRelayControlOptions = _tagEOS_P2P_SetRelayControlOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_GetRelayControlOptions {
    #[doc = " API Version: Set this to EOS_P2P_GETRELAYCONTROL_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_GetRelayControlOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_GetRelayControlOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_GetRelayControlOptions>(),
        4usize,
        concat!("Size of: ", stringify!(_tagEOS_P2P_GetRelayControlOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_GetRelayControlOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_P2P_GetRelayControlOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_GetRelayControlOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_P2P_GetRelayControlOptions = _tagEOS_P2P_GetRelayControlOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_SetPortRangeOptions {
    #[doc = " API Version: Set this to EOS_P2P_SETPORTRANGE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The ideal port to use for P2P traffic. The default value is 7777. If set to 0, the OS will choose a port. If set to 0, MaxAdditionalPortsToTry must be set to 0."]
    pub Port: u16,
    #[doc = " The maximum amount of additional ports to try if Port is unavailable. Ports will be tried from Port to Port + MaxAdditionalPortsToTry\n inclusive, until one is available or we run out of ports. If no ports are available, P2P connections will fail. The default value is 99."]
    pub MaxAdditionalPortsToTry: u16,
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_SetPortRangeOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_SetPortRangeOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_SetPortRangeOptions>(),
        8usize,
        concat!("Size of: ", stringify!(_tagEOS_P2P_SetPortRangeOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_SetPortRangeOptions>(),
        4usize,
        concat!("Alignment of ", stringify!(_tagEOS_P2P_SetPortRangeOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_SetPortRangeOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Port) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_SetPortRangeOptions),
            "::",
            stringify!(Port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxAdditionalPortsToTry) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_SetPortRangeOptions),
            "::",
            stringify!(MaxAdditionalPortsToTry)
        )
    );
}
pub type EOS_P2P_SetPortRangeOptions = _tagEOS_P2P_SetPortRangeOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_GetPortRangeOptions {
    #[doc = " API Version: Set this to EOS_P2P_GETPORTRANGE_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_GetPortRangeOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_GetPortRangeOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_GetPortRangeOptions>(),
        4usize,
        concat!("Size of: ", stringify!(_tagEOS_P2P_GetPortRangeOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_GetPortRangeOptions>(),
        4usize,
        concat!("Alignment of ", stringify!(_tagEOS_P2P_GetPortRangeOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_GetPortRangeOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_P2P_GetPortRangeOptions = _tagEOS_P2P_GetPortRangeOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_SetPacketQueueSizeOptions {
    #[doc = " API Version: Set this to EOS_P2P_SETPACKETQUEUESIZE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The ideal maximum amount of bytes the Incoming packet queue can consume"]
    pub IncomingPacketQueueMaxSizeBytes: u64,
    #[doc = " The ideal maximum amount of bytes the Outgoing packet queue can consume"]
    pub OutgoingPacketQueueMaxSizeBytes: u64,
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_SetPacketQueueSizeOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_SetPacketQueueSizeOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_SetPacketQueueSizeOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_P2P_SetPacketQueueSizeOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_SetPacketQueueSizeOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_P2P_SetPacketQueueSizeOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_SetPacketQueueSizeOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).IncomingPacketQueueMaxSizeBytes) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_SetPacketQueueSizeOptions),
            "::",
            stringify!(IncomingPacketQueueMaxSizeBytes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).OutgoingPacketQueueMaxSizeBytes) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_SetPacketQueueSizeOptions),
            "::",
            stringify!(OutgoingPacketQueueMaxSizeBytes)
        )
    );
}
pub type EOS_P2P_SetPacketQueueSizeOptions = _tagEOS_P2P_SetPacketQueueSizeOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_GetPacketQueueInfoOptions {
    #[doc = " API Version: Set this to EOS_P2P_GETPACKETQUEUEINFO_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_GetPacketQueueInfoOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_GetPacketQueueInfoOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_GetPacketQueueInfoOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_P2P_GetPacketQueueInfoOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_GetPacketQueueInfoOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_P2P_GetPacketQueueInfoOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_GetPacketQueueInfoOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_P2P_GetPacketQueueInfoOptions = _tagEOS_P2P_GetPacketQueueInfoOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_PacketQueueInfo {
    #[doc = " The maximum size in bytes of the incoming packet queue"]
    pub IncomingPacketQueueMaxSizeBytes: u64,
    #[doc = " The current size in bytes of the incoming packet queue"]
    pub IncomingPacketQueueCurrentSizeBytes: u64,
    #[doc = " The current number of queued packets in the incoming packet queue"]
    pub IncomingPacketQueueCurrentPacketCount: u64,
    #[doc = " The maximum size in bytes of the outgoing packet queue"]
    pub OutgoingPacketQueueMaxSizeBytes: u64,
    #[doc = " The current size in bytes of the outgoing packet queue"]
    pub OutgoingPacketQueueCurrentSizeBytes: u64,
    #[doc = " The current amount of queued packets in the outgoing packet queue"]
    pub OutgoingPacketQueueCurrentPacketCount: u64,
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_PacketQueueInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_PacketQueueInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_PacketQueueInfo>(),
        48usize,
        concat!("Size of: ", stringify!(_tagEOS_P2P_PacketQueueInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_PacketQueueInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_P2P_PacketQueueInfo))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).IncomingPacketQueueMaxSizeBytes) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_PacketQueueInfo),
            "::",
            stringify!(IncomingPacketQueueMaxSizeBytes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).IncomingPacketQueueCurrentSizeBytes) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_PacketQueueInfo),
            "::",
            stringify!(IncomingPacketQueueCurrentSizeBytes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).IncomingPacketQueueCurrentPacketCount) as usize
                - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_PacketQueueInfo),
            "::",
            stringify!(IncomingPacketQueueCurrentPacketCount)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).OutgoingPacketQueueMaxSizeBytes) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_PacketQueueInfo),
            "::",
            stringify!(OutgoingPacketQueueMaxSizeBytes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).OutgoingPacketQueueCurrentSizeBytes) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_PacketQueueInfo),
            "::",
            stringify!(OutgoingPacketQueueCurrentSizeBytes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).OutgoingPacketQueueCurrentPacketCount) as usize
                - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_PacketQueueInfo),
            "::",
            stringify!(OutgoingPacketQueueCurrentPacketCount)
        )
    );
}
pub type EOS_P2P_PacketQueueInfo = _tagEOS_P2P_PacketQueueInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_AddNotifyIncomingPacketQueueFullOptions {
    #[doc = " API Version: Set this to EOS_P2P_ADDNOTIFYINCOMINGPACKETQUEUEFULL_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_AddNotifyIncomingPacketQueueFullOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_AddNotifyIncomingPacketQueueFullOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_AddNotifyIncomingPacketQueueFullOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_P2P_AddNotifyIncomingPacketQueueFullOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_AddNotifyIncomingPacketQueueFullOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_P2P_AddNotifyIncomingPacketQueueFullOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_AddNotifyIncomingPacketQueueFullOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_P2P_AddNotifyIncomingPacketQueueFullOptions =
    _tagEOS_P2P_AddNotifyIncomingPacketQueueFullOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_OnIncomingPacketQueueFullInfo {
    #[doc = " Client-specified data passed into AddNotifyIncomingPacketQueueFull"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The maximum size in bytes the incoming packet queue is allowed to use"]
    pub PacketQueueMaxSizeBytes: u64,
    #[doc = " The current size in bytes the incoming packet queue is currently using"]
    pub PacketQueueCurrentSizeBytes: u64,
    #[doc = " The Product User ID of the local user who is receiving the packet that would overflow the queue"]
    pub OverflowPacketLocalUserId: EOS_ProductUserId,
    #[doc = " The channel the incoming packet is for"]
    pub OverflowPacketChannel: u8,
    #[doc = " The size in bytes of the incoming packet (and related metadata) that would overflow the queue"]
    pub OverflowPacketSizeBytes: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_OnIncomingPacketQueueFullInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_OnIncomingPacketQueueFullInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_OnIncomingPacketQueueFullInfo>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_P2P_OnIncomingPacketQueueFullInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_OnIncomingPacketQueueFullInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_P2P_OnIncomingPacketQueueFullInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnIncomingPacketQueueFullInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PacketQueueMaxSizeBytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnIncomingPacketQueueFullInfo),
            "::",
            stringify!(PacketQueueMaxSizeBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PacketQueueCurrentSizeBytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnIncomingPacketQueueFullInfo),
            "::",
            stringify!(PacketQueueCurrentSizeBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OverflowPacketLocalUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnIncomingPacketQueueFullInfo),
            "::",
            stringify!(OverflowPacketLocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OverflowPacketChannel) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnIncomingPacketQueueFullInfo),
            "::",
            stringify!(OverflowPacketChannel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OverflowPacketSizeBytes) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_OnIncomingPacketQueueFullInfo),
            "::",
            stringify!(OverflowPacketSizeBytes)
        )
    );
}
pub type EOS_P2P_OnIncomingPacketQueueFullInfo = _tagEOS_P2P_OnIncomingPacketQueueFullInfo;
pub type EOS_P2P_OnIncomingPacketQueueFullCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_P2P_OnIncomingPacketQueueFullInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_P2P_ClearPacketQueueOptions {
    #[doc = " API Version: Set this to EOS_P2P_CLEARPACKETQUEUE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user for whom we want to clear the queued packets"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The Product User ID to who (outgoing) or from who (incoming) packets are queued"]
    pub RemoteUserId: EOS_ProductUserId,
    #[doc = " The socket used for packets to be cleared"]
    pub SocketId: *const EOS_P2P_SocketId,
}
#[test]
fn bindgen_test_layout__tagEOS_P2P_ClearPacketQueueOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_P2P_ClearPacketQueueOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_P2P_ClearPacketQueueOptions>(),
        32usize,
        concat!("Size of: ", stringify!(_tagEOS_P2P_ClearPacketQueueOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_P2P_ClearPacketQueueOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_P2P_ClearPacketQueueOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_ClearPacketQueueOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_ClearPacketQueueOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RemoteUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_ClearPacketQueueOptions),
            "::",
            stringify!(RemoteUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SocketId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_P2P_ClearPacketQueueOptions),
            "::",
            stringify!(SocketId)
        )
    );
}
pub type EOS_P2P_ClearPacketQueueOptions = _tagEOS_P2P_ClearPacketQueueOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_SessionsHandle {
    _unused: [u8; 0],
}
#[doc = " Handle to the sessions interface"]
pub type EOS_HSessions = *mut EOS_SessionsHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_SessionModificationHandle {
    _unused: [u8; 0],
}
#[doc = " Handle to the calls responsible for creating/updating sessions"]
pub type EOS_HSessionModification = *mut EOS_SessionModificationHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_ActiveSessionHandle {
    _unused: [u8; 0],
}
#[doc = " Handle to a single named session that exists locally"]
pub type EOS_HActiveSession = *mut EOS_ActiveSessionHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_SessionDetailsHandle {
    _unused: [u8; 0],
}
#[doc = " Handle to a single session that may be part of a named session, search result, or invite"]
pub type EOS_HSessionDetails = *mut EOS_SessionDetailsHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_SessionSearchHandle {
    _unused: [u8; 0],
}
#[doc = " Handle to the calls responsible for creating a search object"]
pub type EOS_HSessionSearch = *mut EOS_SessionSearchHandle;
extern "C" {
    #[doc = " Release the memory associated with session modification.\n This must be called on data retrieved from EOS_Sessions_CreateSessionModification or EOS_Sessions_UpdateSessionModification\n\n @param SessionModificationHandle - The session modification handle to release\n\n @see EOS_Sessions_CreateSessionModification\n @see EOS_Sessions_UpdateSessionModification"]
    pub fn EOS_SessionModification_Release(SessionModificationHandle: EOS_HSessionModification);
}
extern "C" {
    #[doc = " Release the memory associated with an active session.\n This must be called on data retrieved from EOS_Sessions_CopyActiveSessionHandle\n\n @param ActiveSessionHandle - The active session handle to release\n\n @see EOS_Sessions_CopyActiveSessionHandle"]
    pub fn EOS_ActiveSession_Release(ActiveSessionHandle: EOS_HActiveSession);
}
extern "C" {
    #[doc = " Release the memory associated with a single session. This must be called on data retrieved from EOS_SessionSearch_CopySearchResultByIndex.\n\n @param SessionHandle - The session handle to release\n\n @see EOS_SessionSearch_CopySearchResultByIndex"]
    pub fn EOS_SessionDetails_Release(SessionHandle: EOS_HSessionDetails);
}
extern "C" {
    #[doc = " Release the memory associated with a session search. This must be called on data retrieved from EOS_Sessions_CreateSessionSearch.\n\n @param SessionSearchHandle - The session search handle to release\n\n @see EOS_Sessions_CreateSessionSearch"]
    pub fn EOS_SessionSearch_Release(SessionSearchHandle: EOS_HSessionSearch);
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EOnlineSessionState {
    #[doc = " An online session has not been created yet"]
    EOS_OSS_NoSession = 0,
    #[doc = " An online session is in the process of being created"]
    EOS_OSS_Creating = 1,
    #[doc = " Session has been created but the session hasn't started (pre match lobby)"]
    EOS_OSS_Pending = 2,
    #[doc = " Session has been asked to start (may take time due to communication with backend)"]
    EOS_OSS_Starting = 3,
    #[doc = " The current session has started. Sessions with join in progress disabled are no longer joinable"]
    EOS_OSS_InProgress = 4,
    #[doc = " The session is still valid, but the session is no longer being played (post match lobby)"]
    EOS_OSS_Ending = 5,
    #[doc = " The session is closed and any stats committed"]
    EOS_OSS_Ended = 6,
    #[doc = " The session is being destroyed"]
    EOS_OSS_Destroying = 7,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_ESessionAttributeAdvertisementType {
    #[doc = " Don't advertise via the online service"]
    EOS_SAAT_DontAdvertise = 0,
    #[doc = " Advertise via the online service only"]
    EOS_SAAT_Advertise = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_CreateSessionModificationOptions {
    #[doc = " API Version: Set this to EOS_SESSIONS_CREATESESSIONMODIFICATION_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Name of the session to create"]
    pub SessionName: *const ::std::os::raw::c_char,
    #[doc = " Bucket ID associated with the session"]
    pub BucketId: *const ::std::os::raw::c_char,
    #[doc = " Maximum number of players allowed in the session"]
    pub MaxPlayers: u32,
    #[doc = " The Product User ID of the local user associated with the session"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Determines whether or not this session should be the one associated with the local user's presence information.\n If true, this session will be associated with presence. Only one session at a time can have this flag true.\n This affects the ability of the Social Overlay to show game related actions to take in the user's social graph.\n\n @note The Social Overlay can handle only one of the following three options at a time:\n * using the bPresenceEnabled flags within the Sessions interface\n * using the bPresenceEnabled flags within the Lobby interface\n * using EOS_PresenceModification_SetJoinInfo\n\n @see EOS_PresenceModification_SetJoinInfoOptions\n @see EOS_Lobby_CreateLobbyOptions\n @see EOS_Lobby_JoinLobbyOptions\n @see EOS_Sessions_JoinSessionOptions"]
    pub bPresenceEnabled: EOS_Bool,
    #[doc = " Optional session id - set to a globally unique value to override the backend assignment\n If not specified the backend service will assign one to the session.  Do not mix and match.\n This value can be of size [EOS_SESSIONMODIFICATION_MIN_SESSIONIDOVERRIDE_LENGTH, EOS_SESSIONMODIFICATION_MAX_SESSIONIDOVERRIDE_LENGTH]"]
    pub SessionId: *const ::std::os::raw::c_char,
    #[doc = " If true, sanctioned players can neither join nor register with this session and, in the case of join,\n will return EOS_EResult code EOS_Sessions_PlayerSanctioned"]
    pub bSanctionsEnabled: EOS_Bool,
    #[doc = " Array of platform IDs indicating the player platforms allowed to register with the session. Platform IDs are\n found in the EOS header file, e.g. EOS_OPT_Epic. For some platforms, the value will be in the EOS Platform specific\n header file. If null, the session will be unrestricted."]
    pub AllowedPlatformIds: *const u32,
    #[doc = " Number of platform IDs in the array"]
    pub AllowedPlatformIdsCount: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_CreateSessionModificationOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_CreateSessionModificationOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_CreateSessionModificationOptions>(),
        80usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_CreateSessionModificationOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_CreateSessionModificationOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_CreateSessionModificationOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_CreateSessionModificationOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_CreateSessionModificationOptions),
            "::",
            stringify!(SessionName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BucketId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_CreateSessionModificationOptions),
            "::",
            stringify!(BucketId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxPlayers) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_CreateSessionModificationOptions),
            "::",
            stringify!(MaxPlayers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_CreateSessionModificationOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bPresenceEnabled) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_CreateSessionModificationOptions),
            "::",
            stringify!(bPresenceEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionId) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_CreateSessionModificationOptions),
            "::",
            stringify!(SessionId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bSanctionsEnabled) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_CreateSessionModificationOptions),
            "::",
            stringify!(bSanctionsEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllowedPlatformIds) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_CreateSessionModificationOptions),
            "::",
            stringify!(AllowedPlatformIds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllowedPlatformIdsCount) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_CreateSessionModificationOptions),
            "::",
            stringify!(AllowedPlatformIdsCount)
        )
    );
}
pub type EOS_Sessions_CreateSessionModificationOptions =
    _tagEOS_Sessions_CreateSessionModificationOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_UpdateSessionModificationOptions {
    #[doc = " API Version: Set this to EOS_SESSIONS_UPDATESESSIONMODIFICATION_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Name of the session to update"]
    pub SessionName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_UpdateSessionModificationOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_UpdateSessionModificationOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_UpdateSessionModificationOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_UpdateSessionModificationOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_UpdateSessionModificationOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_UpdateSessionModificationOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_UpdateSessionModificationOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_UpdateSessionModificationOptions),
            "::",
            stringify!(SessionName)
        )
    );
}
pub type EOS_Sessions_UpdateSessionModificationOptions =
    _tagEOS_Sessions_UpdateSessionModificationOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_SendInviteOptions {
    #[doc = " API Version: Set this to EOS_SESSIONS_SENDINVITE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Name of the session associated with the invite"]
    pub SessionName: *const ::std::os::raw::c_char,
    #[doc = " The Product User ID of the local user sending the invitation"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The Product User of the remote user receiving the invitation"]
    pub TargetUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_SendInviteOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_SendInviteOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_SendInviteOptions>(),
        32usize,
        concat!("Size of: ", stringify!(_tagEOS_Sessions_SendInviteOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_SendInviteOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_SendInviteOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_SendInviteOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_SendInviteOptions),
            "::",
            stringify!(SessionName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_SendInviteOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_SendInviteOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Sessions_SendInviteOptions = _tagEOS_Sessions_SendInviteOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_SendInviteCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Sessions_SendInvite"]
    pub ClientData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_SendInviteCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_SendInviteCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_SendInviteCallbackInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_SendInviteCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_SendInviteCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_SendInviteCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_SendInviteCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_SendInviteCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
}
pub type EOS_Sessions_SendInviteCallbackInfo = _tagEOS_Sessions_SendInviteCallbackInfo;
pub type EOS_Sessions_OnSendInviteCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Sessions_SendInviteCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_RejectInviteOptions {
    #[doc = " API Version: Set this to EOS_SESSIONS_REJECTINVITE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user rejecting the invitation"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The invite ID to reject"]
    pub InviteId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_RejectInviteOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_RejectInviteOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_RejectInviteOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_RejectInviteOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_RejectInviteOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_RejectInviteOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_RejectInviteOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_RejectInviteOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InviteId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_RejectInviteOptions),
            "::",
            stringify!(InviteId)
        )
    );
}
pub type EOS_Sessions_RejectInviteOptions = _tagEOS_Sessions_RejectInviteOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_RejectInviteCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Sessions_RejectInvite"]
    pub ClientData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_RejectInviteCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_RejectInviteCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_RejectInviteCallbackInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_RejectInviteCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_RejectInviteCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_RejectInviteCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_RejectInviteCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_RejectInviteCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
}
pub type EOS_Sessions_RejectInviteCallbackInfo = _tagEOS_Sessions_RejectInviteCallbackInfo;
pub type EOS_Sessions_OnRejectInviteCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Sessions_RejectInviteCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_QueryInvitesOptions {
    #[doc = " API Version: Set this to EOS_SESSIONS_QUERYINVITES_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID to query for invitations"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_QueryInvitesOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_QueryInvitesOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_QueryInvitesOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_QueryInvitesOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_QueryInvitesOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_QueryInvitesOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_QueryInvitesOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_QueryInvitesOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Sessions_QueryInvitesOptions = _tagEOS_Sessions_QueryInvitesOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_QueryInvitesCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Sessions_QueryInvites"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User of the local user who made the request"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_QueryInvitesCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_QueryInvitesCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_QueryInvitesCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_QueryInvitesCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_QueryInvitesCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_QueryInvitesCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_QueryInvitesCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_QueryInvitesCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_QueryInvitesCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Sessions_QueryInvitesCallbackInfo = _tagEOS_Sessions_QueryInvitesCallbackInfo;
pub type EOS_Sessions_OnQueryInvitesCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Sessions_QueryInvitesCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_GetInviteCountOptions {
    #[doc = " API Version: Set this to EOS_SESSIONS_GETINVITECOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user who has one or more invitations in the cache"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_GetInviteCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_GetInviteCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_GetInviteCountOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_GetInviteCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_GetInviteCountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_GetInviteCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_GetInviteCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_GetInviteCountOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Sessions_GetInviteCountOptions = _tagEOS_Sessions_GetInviteCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_GetInviteIdByIndexOptions {
    #[doc = " API Version: Set this to EOS_SESSIONS_GETINVITEIDBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user who has an invitation in the cache"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Index of the invite ID to retrieve"]
    pub Index: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_GetInviteIdByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_GetInviteIdByIndexOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_GetInviteIdByIndexOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_GetInviteIdByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_GetInviteIdByIndexOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_GetInviteIdByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_GetInviteIdByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_GetInviteIdByIndexOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Index) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_GetInviteIdByIndexOptions),
            "::",
            stringify!(Index)
        )
    );
}
pub type EOS_Sessions_GetInviteIdByIndexOptions = _tagEOS_Sessions_GetInviteIdByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_CreateSessionSearchOptions {
    #[doc = " API Version: Set this to EOS_SESSIONS_CREATESESSIONSEARCH_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Max number of results to return"]
    pub MaxSearchResults: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_CreateSessionSearchOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_CreateSessionSearchOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_CreateSessionSearchOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_CreateSessionSearchOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_CreateSessionSearchOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_CreateSessionSearchOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_CreateSessionSearchOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxSearchResults) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_CreateSessionSearchOptions),
            "::",
            stringify!(MaxSearchResults)
        )
    );
}
pub type EOS_Sessions_CreateSessionSearchOptions = _tagEOS_Sessions_CreateSessionSearchOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_UpdateSessionOptions {
    #[doc = " API Version: Set this to EOS_SESSIONS_UPDATESESSION_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Builder handle"]
    pub SessionModificationHandle: EOS_HSessionModification,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_UpdateSessionOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_UpdateSessionOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_UpdateSessionOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_UpdateSessionOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_UpdateSessionOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_UpdateSessionOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_UpdateSessionOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionModificationHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_UpdateSessionOptions),
            "::",
            stringify!(SessionModificationHandle)
        )
    );
}
pub type EOS_Sessions_UpdateSessionOptions = _tagEOS_Sessions_UpdateSessionOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_UpdateSessionCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Sessions_UpdateSession"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Name of the session that was created/modified"]
    pub SessionName: *const ::std::os::raw::c_char,
    #[doc = " ID of the session that was created/modified"]
    pub SessionId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_UpdateSessionCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_UpdateSessionCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_UpdateSessionCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_UpdateSessionCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_UpdateSessionCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_UpdateSessionCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_UpdateSessionCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_UpdateSessionCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_UpdateSessionCallbackInfo),
            "::",
            stringify!(SessionName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_UpdateSessionCallbackInfo),
            "::",
            stringify!(SessionId)
        )
    );
}
pub type EOS_Sessions_UpdateSessionCallbackInfo = _tagEOS_Sessions_UpdateSessionCallbackInfo;
pub type EOS_Sessions_OnUpdateSessionCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Sessions_UpdateSessionCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_DestroySessionOptions {
    #[doc = " API Version: Set this to EOS_SESSIONS_DESTROYSESSION_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Name of the session to destroy"]
    pub SessionName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_DestroySessionOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_DestroySessionOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_DestroySessionOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_DestroySessionOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_DestroySessionOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_DestroySessionOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_DestroySessionOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_DestroySessionOptions),
            "::",
            stringify!(SessionName)
        )
    );
}
pub type EOS_Sessions_DestroySessionOptions = _tagEOS_Sessions_DestroySessionOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_DestroySessionCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Sessions_DestroySession"]
    pub ClientData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_DestroySessionCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_DestroySessionCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_DestroySessionCallbackInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_DestroySessionCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_DestroySessionCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_DestroySessionCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_DestroySessionCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_DestroySessionCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
}
pub type EOS_Sessions_DestroySessionCallbackInfo = _tagEOS_Sessions_DestroySessionCallbackInfo;
pub type EOS_Sessions_OnDestroySessionCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Sessions_DestroySessionCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_JoinSessionOptions {
    #[doc = " API Version: Set this to EOS_SESSIONS_JOINSESSION_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Name of the session to create after joining session"]
    pub SessionName: *const ::std::os::raw::c_char,
    #[doc = " Session handle to join"]
    pub SessionHandle: EOS_HSessionDetails,
    #[doc = " The Product User ID of the local user who is joining the session"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Determines whether or not this session should be the one associated with the local user's presence information.\n If true, this session will be associated with presence. Only one session at a time can have this flag true.\n This affects the ability of the Social Overlay to show game related actions to take in the user's social graph.\n\n @note The Social Overlay can handle only one of the following three options at a time:\n * using the bPresenceEnabled flags within the Sessions interface\n * using the bPresenceEnabled flags within the Lobby interface\n * using EOS_PresenceModification_SetJoinInfo\n\n @see EOS_PresenceModification_SetJoinInfoOptions\n @see EOS_Lobby_CreateLobbyOptions\n @see EOS_Lobby_JoinLobbyOptions\n @see EOS_Sessions_CreateSessionModificationOptions"]
    pub bPresenceEnabled: EOS_Bool,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_JoinSessionOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_JoinSessionOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_JoinSessionOptions>(),
        40usize,
        concat!("Size of: ", stringify!(_tagEOS_Sessions_JoinSessionOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_JoinSessionOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_JoinSessionOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_JoinSessionOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_JoinSessionOptions),
            "::",
            stringify!(SessionName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionHandle) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_JoinSessionOptions),
            "::",
            stringify!(SessionHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_JoinSessionOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bPresenceEnabled) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_JoinSessionOptions),
            "::",
            stringify!(bPresenceEnabled)
        )
    );
}
pub type EOS_Sessions_JoinSessionOptions = _tagEOS_Sessions_JoinSessionOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_JoinSessionCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Sessions_JoinSession"]
    pub ClientData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_JoinSessionCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_JoinSessionCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_JoinSessionCallbackInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_JoinSessionCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_JoinSessionCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_JoinSessionCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_JoinSessionCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_JoinSessionCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
}
pub type EOS_Sessions_JoinSessionCallbackInfo = _tagEOS_Sessions_JoinSessionCallbackInfo;
pub type EOS_Sessions_OnJoinSessionCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Sessions_JoinSessionCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_StartSessionOptions {
    #[doc = " API Version: Set this to EOS_SESSIONS_STARTSESSION_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Name of the session to set in progress"]
    pub SessionName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_StartSessionOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_StartSessionOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_StartSessionOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_StartSessionOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_StartSessionOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_StartSessionOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_StartSessionOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_StartSessionOptions),
            "::",
            stringify!(SessionName)
        )
    );
}
pub type EOS_Sessions_StartSessionOptions = _tagEOS_Sessions_StartSessionOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_StartSessionCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Sessions_StartSession"]
    pub ClientData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_StartSessionCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_StartSessionCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_StartSessionCallbackInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_StartSessionCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_StartSessionCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_StartSessionCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_StartSessionCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_StartSessionCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
}
pub type EOS_Sessions_StartSessionCallbackInfo = _tagEOS_Sessions_StartSessionCallbackInfo;
pub type EOS_Sessions_OnStartSessionCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Sessions_StartSessionCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_EndSessionOptions {
    #[doc = " API Version: Set this to EOS_SESSIONS_ENDSESSION_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Name of the session to set as no long in progress"]
    pub SessionName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_EndSessionOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_EndSessionOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_EndSessionOptions>(),
        16usize,
        concat!("Size of: ", stringify!(_tagEOS_Sessions_EndSessionOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_EndSessionOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_EndSessionOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_EndSessionOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_EndSessionOptions),
            "::",
            stringify!(SessionName)
        )
    );
}
pub type EOS_Sessions_EndSessionOptions = _tagEOS_Sessions_EndSessionOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_EndSessionCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Sessions_EndSession"]
    pub ClientData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_EndSessionCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_EndSessionCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_EndSessionCallbackInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_EndSessionCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_EndSessionCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_EndSessionCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_EndSessionCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_EndSessionCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
}
pub type EOS_Sessions_EndSessionCallbackInfo = _tagEOS_Sessions_EndSessionCallbackInfo;
pub type EOS_Sessions_OnEndSessionCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Sessions_EndSessionCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_RegisterPlayersOptions {
    #[doc = " API Version: Set this to EOS_SESSIONS_REGISTERPLAYERS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Name of the session for which to register players"]
    pub SessionName: *const ::std::os::raw::c_char,
    #[doc = " Array of players to register with the session"]
    pub PlayersToRegister: *mut EOS_ProductUserId,
    #[doc = " Number of players in the array"]
    pub PlayersToRegisterCount: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_RegisterPlayersOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_RegisterPlayersOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_RegisterPlayersOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_RegisterPlayersOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_RegisterPlayersOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_RegisterPlayersOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_RegisterPlayersOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_RegisterPlayersOptions),
            "::",
            stringify!(SessionName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PlayersToRegister) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_RegisterPlayersOptions),
            "::",
            stringify!(PlayersToRegister)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PlayersToRegisterCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_RegisterPlayersOptions),
            "::",
            stringify!(PlayersToRegisterCount)
        )
    );
}
pub type EOS_Sessions_RegisterPlayersOptions = _tagEOS_Sessions_RegisterPlayersOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_RegisterPlayersCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Sessions_RegisterPlayers"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The players that were successfully registered"]
    pub RegisteredPlayers: *mut EOS_ProductUserId,
    #[doc = " The number of players successfully registered"]
    pub RegisteredPlayersCount: u32,
    #[doc = " The players that failed to register because they are sanctioned"]
    pub SanctionedPlayers: *mut EOS_ProductUserId,
    #[doc = " The number of players that failed to register because they are sanctioned"]
    pub SanctionedPlayersCount: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_RegisterPlayersCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_RegisterPlayersCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_RegisterPlayersCallbackInfo>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_RegisterPlayersCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_RegisterPlayersCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_RegisterPlayersCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_RegisterPlayersCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_RegisterPlayersCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RegisteredPlayers) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_RegisterPlayersCallbackInfo),
            "::",
            stringify!(RegisteredPlayers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RegisteredPlayersCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_RegisterPlayersCallbackInfo),
            "::",
            stringify!(RegisteredPlayersCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SanctionedPlayers) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_RegisterPlayersCallbackInfo),
            "::",
            stringify!(SanctionedPlayers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SanctionedPlayersCount) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_RegisterPlayersCallbackInfo),
            "::",
            stringify!(SanctionedPlayersCount)
        )
    );
}
pub type EOS_Sessions_RegisterPlayersCallbackInfo = _tagEOS_Sessions_RegisterPlayersCallbackInfo;
pub type EOS_Sessions_OnRegisterPlayersCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Sessions_RegisterPlayersCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_UnregisterPlayersOptions {
    #[doc = " API Version: Set this to EOS_SESSIONS_UNREGISTERPLAYERS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Name of the session for which to unregister players"]
    pub SessionName: *const ::std::os::raw::c_char,
    #[doc = " Array of players to unregister from the session"]
    pub PlayersToUnregister: *mut EOS_ProductUserId,
    #[doc = " Number of players in the array"]
    pub PlayersToUnregisterCount: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_UnregisterPlayersOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_UnregisterPlayersOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_UnregisterPlayersOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_UnregisterPlayersOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_UnregisterPlayersOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_UnregisterPlayersOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_UnregisterPlayersOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_UnregisterPlayersOptions),
            "::",
            stringify!(SessionName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PlayersToUnregister) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_UnregisterPlayersOptions),
            "::",
            stringify!(PlayersToUnregister)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PlayersToUnregisterCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_UnregisterPlayersOptions),
            "::",
            stringify!(PlayersToUnregisterCount)
        )
    );
}
pub type EOS_Sessions_UnregisterPlayersOptions = _tagEOS_Sessions_UnregisterPlayersOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_UnregisterPlayersCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Sessions_UnregisterPlayers"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The players that successfully unregistered"]
    pub UnregisteredPlayers: *mut EOS_ProductUserId,
    #[doc = " The number of players that successfully unregistered"]
    pub UnregisteredPlayersCount: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_UnregisterPlayersCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_UnregisterPlayersCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_UnregisterPlayersCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_UnregisterPlayersCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_UnregisterPlayersCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_UnregisterPlayersCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_UnregisterPlayersCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_UnregisterPlayersCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UnregisteredPlayers) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_UnregisterPlayersCallbackInfo),
            "::",
            stringify!(UnregisteredPlayers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UnregisteredPlayersCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_UnregisterPlayersCallbackInfo),
            "::",
            stringify!(UnregisteredPlayersCount)
        )
    );
}
pub type EOS_Sessions_UnregisterPlayersCallbackInfo =
    _tagEOS_Sessions_UnregisterPlayersCallbackInfo;
pub type EOS_Sessions_OnUnregisterPlayersCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Sessions_UnregisterPlayersCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_SessionModification_SetBucketIdOptions {
    #[doc = " API Version: Set this to EOS_SESSIONMODIFICATION_SETBUCKETID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The new bucket id associated with the session"]
    pub BucketId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_SessionModification_SetBucketIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_SessionModification_SetBucketIdOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_SessionModification_SetBucketIdOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_SessionModification_SetBucketIdOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_SessionModification_SetBucketIdOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_SessionModification_SetBucketIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionModification_SetBucketIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BucketId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionModification_SetBucketIdOptions),
            "::",
            stringify!(BucketId)
        )
    );
}
pub type EOS_SessionModification_SetBucketIdOptions =
    _tagEOS_SessionModification_SetBucketIdOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_SessionModification_SetHostAddressOptions {
    #[doc = " API Version: Set this to EOS_SESSIONMODIFICATION_SETHOSTADDRESS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " A string representing the host address for the session, its meaning is up to the application"]
    pub HostAddress: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_SessionModification_SetHostAddressOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_SessionModification_SetHostAddressOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_SessionModification_SetHostAddressOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_SessionModification_SetHostAddressOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_SessionModification_SetHostAddressOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_SessionModification_SetHostAddressOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionModification_SetHostAddressOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HostAddress) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionModification_SetHostAddressOptions),
            "::",
            stringify!(HostAddress)
        )
    );
}
pub type EOS_SessionModification_SetHostAddressOptions =
    _tagEOS_SessionModification_SetHostAddressOptions;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EOnlineSessionPermissionLevel {
    #[doc = " Anyone can find this session as long as it isn't full"]
    EOS_OSPF_PublicAdvertised = 0,
    #[doc = " Players who have access to presence can see this session"]
    EOS_OSPF_JoinViaPresence = 1,
    #[doc = " Only players with invites registered can see this session"]
    EOS_OSPF_InviteOnly = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_SessionModification_SetPermissionLevelOptions {
    #[doc = " API Version: Set this to EOS_SESSIONMODIFICATION_SETPERMISSIONLEVEL_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Permission level to set on the session"]
    pub PermissionLevel: EOS_EOnlineSessionPermissionLevel,
}
#[test]
fn bindgen_test_layout__tagEOS_SessionModification_SetPermissionLevelOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_SessionModification_SetPermissionLevelOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_SessionModification_SetPermissionLevelOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_SessionModification_SetPermissionLevelOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_SessionModification_SetPermissionLevelOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_SessionModification_SetPermissionLevelOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionModification_SetPermissionLevelOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PermissionLevel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionModification_SetPermissionLevelOptions),
            "::",
            stringify!(PermissionLevel)
        )
    );
}
pub type EOS_SessionModification_SetPermissionLevelOptions =
    _tagEOS_SessionModification_SetPermissionLevelOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_SessionModification_SetJoinInProgressAllowedOptions {
    #[doc = " API Version: Set this to EOS_SESSIONMODIFICATION_SETJOININPROGRESSALLOWED_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Does the session allow join in progress"]
    pub bAllowJoinInProgress: EOS_Bool,
}
#[test]
fn bindgen_test_layout__tagEOS_SessionModification_SetJoinInProgressAllowedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_SessionModification_SetJoinInProgressAllowedOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_SessionModification_SetJoinInProgressAllowedOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_SessionModification_SetJoinInProgressAllowedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_SessionModification_SetJoinInProgressAllowedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_SessionModification_SetJoinInProgressAllowedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionModification_SetJoinInProgressAllowedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bAllowJoinInProgress) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionModification_SetJoinInProgressAllowedOptions),
            "::",
            stringify!(bAllowJoinInProgress)
        )
    );
}
pub type EOS_SessionModification_SetJoinInProgressAllowedOptions =
    _tagEOS_SessionModification_SetJoinInProgressAllowedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_SessionModification_SetMaxPlayersOptions {
    #[doc = " API Version: Set this to EOS_SESSIONMODIFICATION_SETMAXPLAYERS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Max number of players to allow in the session"]
    pub MaxPlayers: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_SessionModification_SetMaxPlayersOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_SessionModification_SetMaxPlayersOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_SessionModification_SetMaxPlayersOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_SessionModification_SetMaxPlayersOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_SessionModification_SetMaxPlayersOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_SessionModification_SetMaxPlayersOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionModification_SetMaxPlayersOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxPlayers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionModification_SetMaxPlayersOptions),
            "::",
            stringify!(MaxPlayers)
        )
    );
}
pub type EOS_SessionModification_SetMaxPlayersOptions =
    _tagEOS_SessionModification_SetMaxPlayersOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_SessionModification_SetInvitesAllowedOptions {
    #[doc = " API Version: Set this to EOS_SESSIONMODIFICATION_SETINVITESALLOWED_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " If true then invites can currently be sent for the associated session"]
    pub bInvitesAllowed: EOS_Bool,
}
#[test]
fn bindgen_test_layout__tagEOS_SessionModification_SetInvitesAllowedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_SessionModification_SetInvitesAllowedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_SessionModification_SetInvitesAllowedOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_SessionModification_SetInvitesAllowedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_SessionModification_SetInvitesAllowedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_SessionModification_SetInvitesAllowedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionModification_SetInvitesAllowedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bInvitesAllowed) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionModification_SetInvitesAllowedOptions),
            "::",
            stringify!(bInvitesAllowed)
        )
    );
}
pub type EOS_SessionModification_SetInvitesAllowedOptions =
    _tagEOS_SessionModification_SetInvitesAllowedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_SessionModification_SetAllowedPlatformIdsOptions {
    #[doc = " API Version: Set this to EOS_SESSIONMODIFICATION_SETALLOWEDPLATFORMIDS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Array of platform IDs indicating the player platforms allowed to register with the session. Platform IDs are\n found in the EOS header file, e.g. EOS_OPT_Epic. For some platforms, the value will be in the EOS Platform specific\n header file. If null, the session will be unrestricted."]
    pub AllowedPlatformIds: *const u32,
    #[doc = " Number of platform IDs in the array"]
    pub AllowedPlatformIdsCount: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_SessionModification_SetAllowedPlatformIdsOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_SessionModification_SetAllowedPlatformIdsOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_SessionModification_SetAllowedPlatformIdsOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_SessionModification_SetAllowedPlatformIdsOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_SessionModification_SetAllowedPlatformIdsOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_SessionModification_SetAllowedPlatformIdsOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionModification_SetAllowedPlatformIdsOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllowedPlatformIds) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionModification_SetAllowedPlatformIdsOptions),
            "::",
            stringify!(AllowedPlatformIds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllowedPlatformIdsCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionModification_SetAllowedPlatformIdsOptions),
            "::",
            stringify!(AllowedPlatformIdsCount)
        )
    );
}
pub type EOS_SessionModification_SetAllowedPlatformIdsOptions =
    _tagEOS_SessionModification_SetAllowedPlatformIdsOptions;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _tagEOS_Sessions_AttributeData {
    #[doc = " API Version: Set this to EOS_SESSIONS_ATTRIBUTEDATA_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Name of the session attribute"]
    pub Key: *const ::std::os::raw::c_char,
    pub Value: _tagEOS_Sessions_AttributeData__bindgen_ty_1,
    #[doc = " Type of value stored in the union"]
    pub ValueType: EOS_ESessionAttributeType,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _tagEOS_Sessions_AttributeData__bindgen_ty_1 {
    #[doc = " Stored as an 8 byte integer"]
    pub AsInt64: i64,
    #[doc = " Stored as a double precision floating point"]
    pub AsDouble: f64,
    #[doc = " Stored as a boolean"]
    pub AsBool: EOS_Bool,
    #[doc = " Stored as a null terminated UTF8 string. Should not be nullptr"]
    pub AsUtf8: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_AttributeData__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_AttributeData__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_AttributeData__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_AttributeData__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_AttributeData__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_AttributeData__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AsInt64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_AttributeData__bindgen_ty_1),
            "::",
            stringify!(AsInt64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AsDouble) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_AttributeData__bindgen_ty_1),
            "::",
            stringify!(AsDouble)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AsBool) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_AttributeData__bindgen_ty_1),
            "::",
            stringify!(AsBool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AsUtf8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_AttributeData__bindgen_ty_1),
            "::",
            stringify!(AsUtf8)
        )
    );
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_AttributeData() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_AttributeData> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_AttributeData>(),
        32usize,
        concat!("Size of: ", stringify!(_tagEOS_Sessions_AttributeData))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_AttributeData>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Sessions_AttributeData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_AttributeData),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_AttributeData),
            "::",
            stringify!(Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_AttributeData),
            "::",
            stringify!(Value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ValueType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_AttributeData),
            "::",
            stringify!(ValueType)
        )
    );
}
pub type EOS_Sessions_AttributeData = _tagEOS_Sessions_AttributeData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_ActiveSession_CopyInfoOptions {
    #[doc = " API Version: Set this to EOS_ACTIVESESSION_COPYINFO_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_ActiveSession_CopyInfoOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_ActiveSession_CopyInfoOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_ActiveSession_CopyInfoOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_ActiveSession_CopyInfoOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_ActiveSession_CopyInfoOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_ActiveSession_CopyInfoOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_ActiveSession_CopyInfoOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_ActiveSession_CopyInfoOptions = _tagEOS_ActiveSession_CopyInfoOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_ActiveSession_GetRegisteredPlayerCountOptions {
    #[doc = " API Version: Set this to EOS_ACTIVESESSION_GETREGISTEREDPLAYERCOUNT_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_ActiveSession_GetRegisteredPlayerCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_ActiveSession_GetRegisteredPlayerCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_ActiveSession_GetRegisteredPlayerCountOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_ActiveSession_GetRegisteredPlayerCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_ActiveSession_GetRegisteredPlayerCountOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_ActiveSession_GetRegisteredPlayerCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_ActiveSession_GetRegisteredPlayerCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_ActiveSession_GetRegisteredPlayerCountOptions =
    _tagEOS_ActiveSession_GetRegisteredPlayerCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_ActiveSession_GetRegisteredPlayerByIndexOptions {
    #[doc = " API Version: Set this to EOS_ACTIVESESSION_GETREGISTEREDPLAYERBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Index of the registered player to retrieve"]
    pub PlayerIndex: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_ActiveSession_GetRegisteredPlayerByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_ActiveSession_GetRegisteredPlayerByIndexOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_ActiveSession_GetRegisteredPlayerByIndexOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_ActiveSession_GetRegisteredPlayerByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_ActiveSession_GetRegisteredPlayerByIndexOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_ActiveSession_GetRegisteredPlayerByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_ActiveSession_GetRegisteredPlayerByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PlayerIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_ActiveSession_GetRegisteredPlayerByIndexOptions),
            "::",
            stringify!(PlayerIndex)
        )
    );
}
pub type EOS_ActiveSession_GetRegisteredPlayerByIndexOptions =
    _tagEOS_ActiveSession_GetRegisteredPlayerByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_SessionDetails_Attribute {
    #[doc = " API Version: Set this to EOS_SESSIONDETAILS_ATTRIBUTE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Key/Value pair describing the attribute"]
    pub Data: *mut EOS_Sessions_AttributeData,
    #[doc = " Is this attribution advertised with the backend or simply stored locally"]
    pub AdvertisementType: EOS_ESessionAttributeAdvertisementType,
}
#[test]
fn bindgen_test_layout__tagEOS_SessionDetails_Attribute() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_SessionDetails_Attribute> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_SessionDetails_Attribute>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_SessionDetails_Attribute))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_SessionDetails_Attribute>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_SessionDetails_Attribute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionDetails_Attribute),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionDetails_Attribute),
            "::",
            stringify!(Data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AdvertisementType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionDetails_Attribute),
            "::",
            stringify!(AdvertisementType)
        )
    );
}
pub type EOS_SessionDetails_Attribute = _tagEOS_SessionDetails_Attribute;
extern "C" {
    #[doc = " Release the memory associated with a session attribute. This must be called on data retrieved from EOS_SessionDetails_CopySessionAttributeByIndex.\n\n @param SessionAttribute - The session attribute to release\n\n @see EOS_SessionDetails_CopySessionAttributeByIndex"]
    pub fn EOS_SessionDetails_Attribute_Release(
        SessionAttribute: *mut EOS_SessionDetails_Attribute,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_SessionModification_AddAttributeOptions {
    #[doc = " API Version: Set this to EOS_SESSIONMODIFICATION_ADDATTRIBUTE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Key/Value pair describing the attribute to add to the session"]
    pub SessionAttribute: *const EOS_Sessions_AttributeData,
    #[doc = " Is this attribution advertised with the backend or simply stored locally"]
    pub AdvertisementType: EOS_ESessionAttributeAdvertisementType,
}
#[test]
fn bindgen_test_layout__tagEOS_SessionModification_AddAttributeOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_SessionModification_AddAttributeOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_SessionModification_AddAttributeOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_SessionModification_AddAttributeOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_SessionModification_AddAttributeOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_SessionModification_AddAttributeOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionModification_AddAttributeOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionAttribute) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionModification_AddAttributeOptions),
            "::",
            stringify!(SessionAttribute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AdvertisementType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionModification_AddAttributeOptions),
            "::",
            stringify!(AdvertisementType)
        )
    );
}
pub type EOS_SessionModification_AddAttributeOptions =
    _tagEOS_SessionModification_AddAttributeOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_SessionModification_RemoveAttributeOptions {
    #[doc = " API Version: Set this to EOS_SESSIONMODIFICATION_REMOVEATTRIBUTE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Session attribute to remove from the session"]
    pub Key: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_SessionModification_RemoveAttributeOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_SessionModification_RemoveAttributeOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_SessionModification_RemoveAttributeOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_SessionModification_RemoveAttributeOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_SessionModification_RemoveAttributeOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_SessionModification_RemoveAttributeOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionModification_RemoveAttributeOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionModification_RemoveAttributeOptions),
            "::",
            stringify!(Key)
        )
    );
}
pub type EOS_SessionModification_RemoveAttributeOptions =
    _tagEOS_SessionModification_RemoveAttributeOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_SessionSearch_SetMaxResultsOptions {
    #[doc = " API Version: Set this to EOS_SESSIONSEARCH_SETMAXSEARCHRESULTS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Maximum number of search results returned with this query, may not exceed EOS_SESSIONS_MAX_SEARCH_RESULTS"]
    pub MaxSearchResults: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_SessionSearch_SetMaxResultsOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_SessionSearch_SetMaxResultsOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_SessionSearch_SetMaxResultsOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_SessionSearch_SetMaxResultsOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_SessionSearch_SetMaxResultsOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_SessionSearch_SetMaxResultsOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionSearch_SetMaxResultsOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxSearchResults) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionSearch_SetMaxResultsOptions),
            "::",
            stringify!(MaxSearchResults)
        )
    );
}
pub type EOS_SessionSearch_SetMaxResultsOptions = _tagEOS_SessionSearch_SetMaxResultsOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_SessionSearch_FindOptions {
    #[doc = " API Version: Set this to EOS_SESSIONSEARCH_FIND_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user who is searching"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_SessionSearch_FindOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_SessionSearch_FindOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_SessionSearch_FindOptions>(),
        16usize,
        concat!("Size of: ", stringify!(_tagEOS_SessionSearch_FindOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_SessionSearch_FindOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_SessionSearch_FindOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionSearch_FindOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionSearch_FindOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_SessionSearch_FindOptions = _tagEOS_SessionSearch_FindOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_SessionSearch_FindCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_SessionSearch_Find"]
    pub ClientData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_SessionSearch_FindCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_SessionSearch_FindCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_SessionSearch_FindCallbackInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_SessionSearch_FindCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_SessionSearch_FindCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_SessionSearch_FindCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionSearch_FindCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionSearch_FindCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
}
pub type EOS_SessionSearch_FindCallbackInfo = _tagEOS_SessionSearch_FindCallbackInfo;
pub type EOS_SessionSearch_OnFindCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_SessionSearch_FindCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_SessionSearch_GetSearchResultCountOptions {
    #[doc = " API Version: Set this to EOS_SESSIONSEARCH_GETSEARCHRESULTCOUNT_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_SessionSearch_GetSearchResultCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_SessionSearch_GetSearchResultCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_SessionSearch_GetSearchResultCountOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_SessionSearch_GetSearchResultCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_SessionSearch_GetSearchResultCountOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_SessionSearch_GetSearchResultCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionSearch_GetSearchResultCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_SessionSearch_GetSearchResultCountOptions =
    _tagEOS_SessionSearch_GetSearchResultCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_SessionSearch_CopySearchResultByIndexOptions {
    #[doc = " API Version: Set this to EOS_SESSIONSEARCH_COPYSEARCHRESULTBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The index of the session to retrieve within the completed search query\n @see EOS_SessionSearch_GetSearchResultCount"]
    pub SessionIndex: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_SessionSearch_CopySearchResultByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_SessionSearch_CopySearchResultByIndexOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_SessionSearch_CopySearchResultByIndexOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_SessionSearch_CopySearchResultByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_SessionSearch_CopySearchResultByIndexOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_SessionSearch_CopySearchResultByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionSearch_CopySearchResultByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionSearch_CopySearchResultByIndexOptions),
            "::",
            stringify!(SessionIndex)
        )
    );
}
pub type EOS_SessionSearch_CopySearchResultByIndexOptions =
    _tagEOS_SessionSearch_CopySearchResultByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_SessionSearch_SetSessionIdOptions {
    #[doc = " API Version: Set this to EOS_SESSIONSEARCH_SETSESSIONID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Search sessions for a specific session ID, returning at most one session"]
    pub SessionId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_SessionSearch_SetSessionIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_SessionSearch_SetSessionIdOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_SessionSearch_SetSessionIdOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_SessionSearch_SetSessionIdOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_SessionSearch_SetSessionIdOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_SessionSearch_SetSessionIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionSearch_SetSessionIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionSearch_SetSessionIdOptions),
            "::",
            stringify!(SessionId)
        )
    );
}
pub type EOS_SessionSearch_SetSessionIdOptions = _tagEOS_SessionSearch_SetSessionIdOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_SessionSearch_SetTargetUserIdOptions {
    #[doc = " API Version: Set this to EOS_SESSIONSEARCH_SETTARGETUSERID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID to find; return any sessions where the user matching this ID is currently registered"]
    pub TargetUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_SessionSearch_SetTargetUserIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_SessionSearch_SetTargetUserIdOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_SessionSearch_SetTargetUserIdOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_SessionSearch_SetTargetUserIdOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_SessionSearch_SetTargetUserIdOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_SessionSearch_SetTargetUserIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionSearch_SetTargetUserIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionSearch_SetTargetUserIdOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_SessionSearch_SetTargetUserIdOptions = _tagEOS_SessionSearch_SetTargetUserIdOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_SessionSearch_SetParameterOptions {
    #[doc = " API Version: Set this to EOS_SESSIONSEARCH_SETPARAMETER_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Search parameter describing a key and a value to compare"]
    pub Parameter: *const EOS_Sessions_AttributeData,
    #[doc = " The type of comparison to make against the search parameter"]
    pub ComparisonOp: EOS_EOnlineComparisonOp,
}
#[test]
fn bindgen_test_layout__tagEOS_SessionSearch_SetParameterOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_SessionSearch_SetParameterOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_SessionSearch_SetParameterOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_SessionSearch_SetParameterOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_SessionSearch_SetParameterOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_SessionSearch_SetParameterOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionSearch_SetParameterOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Parameter) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionSearch_SetParameterOptions),
            "::",
            stringify!(Parameter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ComparisonOp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionSearch_SetParameterOptions),
            "::",
            stringify!(ComparisonOp)
        )
    );
}
pub type EOS_SessionSearch_SetParameterOptions = _tagEOS_SessionSearch_SetParameterOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_SessionSearch_RemoveParameterOptions {
    #[doc = " API Version: Set this to EOS_SESSIONSEARCH_REMOVEPARAMETER_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Search parameter key to remove from the search"]
    pub Key: *const ::std::os::raw::c_char,
    #[doc = " Search comparison operation associated with the key to remove"]
    pub ComparisonOp: EOS_EOnlineComparisonOp,
}
#[test]
fn bindgen_test_layout__tagEOS_SessionSearch_RemoveParameterOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_SessionSearch_RemoveParameterOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_SessionSearch_RemoveParameterOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_SessionSearch_RemoveParameterOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_SessionSearch_RemoveParameterOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_SessionSearch_RemoveParameterOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionSearch_RemoveParameterOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionSearch_RemoveParameterOptions),
            "::",
            stringify!(Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ComparisonOp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionSearch_RemoveParameterOptions),
            "::",
            stringify!(ComparisonOp)
        )
    );
}
pub type EOS_SessionSearch_RemoveParameterOptions = _tagEOS_SessionSearch_RemoveParameterOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_SessionDetails_Settings {
    #[doc = " API Version: Set this to EOS_SESSIONDETAILS_SETTINGS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The main indexed parameter for this session, can be any string (i.e. \"Region:GameMode\")"]
    pub BucketId: *const ::std::os::raw::c_char,
    #[doc = " Number of total players allowed in the session"]
    pub NumPublicConnections: u32,
    #[doc = " Are players allowed to join the session while it is in the \"in progress\" state"]
    pub bAllowJoinInProgress: EOS_Bool,
    #[doc = " Permission level describing allowed access to the session when joining or searching for the session"]
    pub PermissionLevel: EOS_EOnlineSessionPermissionLevel,
    #[doc = " Are players allowed to send invites for the session"]
    pub bInvitesAllowed: EOS_Bool,
    #[doc = " Are sanctioned players allowed to join - sanctioned players will be rejected if set to true"]
    pub bSanctionsEnabled: EOS_Bool,
    #[doc = " Array of platform IDs indicating the player platforms allowed to register with the session. Platform IDs are\n found in the EOS header file, e.g. EOS_OPT_Epic. For some platforms, the value will be in the EOS Platform specific\n header file. If null, the session will be unrestricted."]
    pub AllowedPlatformIds: *const u32,
    #[doc = " Number of platform IDs in the array"]
    pub AllowedPlatformIdsCount: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_SessionDetails_Settings() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_SessionDetails_Settings> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_SessionDetails_Settings>(),
        56usize,
        concat!("Size of: ", stringify!(_tagEOS_SessionDetails_Settings))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_SessionDetails_Settings>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_SessionDetails_Settings))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionDetails_Settings),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BucketId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionDetails_Settings),
            "::",
            stringify!(BucketId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumPublicConnections) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionDetails_Settings),
            "::",
            stringify!(NumPublicConnections)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bAllowJoinInProgress) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionDetails_Settings),
            "::",
            stringify!(bAllowJoinInProgress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PermissionLevel) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionDetails_Settings),
            "::",
            stringify!(PermissionLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bInvitesAllowed) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionDetails_Settings),
            "::",
            stringify!(bInvitesAllowed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bSanctionsEnabled) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionDetails_Settings),
            "::",
            stringify!(bSanctionsEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllowedPlatformIds) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionDetails_Settings),
            "::",
            stringify!(AllowedPlatformIds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllowedPlatformIdsCount) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionDetails_Settings),
            "::",
            stringify!(AllowedPlatformIdsCount)
        )
    );
}
pub type EOS_SessionDetails_Settings = _tagEOS_SessionDetails_Settings;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_SessionDetails_Info {
    #[doc = " API Version: Set this to EOS_SESSIONDETAILS_INFO_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Session ID assigned by the backend service"]
    pub SessionId: *const ::std::os::raw::c_char,
    #[doc = " IP address of this session as visible by the backend service"]
    pub HostAddress: *const ::std::os::raw::c_char,
    #[doc = " Number of remaining open spaces on the session (NumPublicConnections - RegisteredPlayers"]
    pub NumOpenPublicConnections: u32,
    #[doc = " Reference to the additional settings associated with this session"]
    pub Settings: *const EOS_SessionDetails_Settings,
    #[doc = " The Product User ID of the session owner. Null if the session is not owned by a user."]
    pub OwnerUserId: EOS_ProductUserId,
    #[doc = " The client id of the session owner. Null if the session is not owned by a server. The session is owned by a server if EOS_Platform_Options::bIsServer is EOS_TRUE."]
    pub OwnerServerClientId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_SessionDetails_Info() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_SessionDetails_Info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_SessionDetails_Info>(),
        56usize,
        concat!("Size of: ", stringify!(_tagEOS_SessionDetails_Info))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_SessionDetails_Info>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_SessionDetails_Info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionDetails_Info),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionDetails_Info),
            "::",
            stringify!(SessionId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HostAddress) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionDetails_Info),
            "::",
            stringify!(HostAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumOpenPublicConnections) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionDetails_Info),
            "::",
            stringify!(NumOpenPublicConnections)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Settings) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionDetails_Info),
            "::",
            stringify!(Settings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OwnerUserId) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionDetails_Info),
            "::",
            stringify!(OwnerUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OwnerServerClientId) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionDetails_Info),
            "::",
            stringify!(OwnerServerClientId)
        )
    );
}
pub type EOS_SessionDetails_Info = _tagEOS_SessionDetails_Info;
extern "C" {
    pub fn EOS_SessionDetails_Info_Release(SessionInfo: *mut EOS_SessionDetails_Info);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_SessionDetails_CopyInfoOptions {
    #[doc = " API Version: Set this to EOS_SESSIONDETAILS_COPYINFO_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_SessionDetails_CopyInfoOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_SessionDetails_CopyInfoOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_SessionDetails_CopyInfoOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_SessionDetails_CopyInfoOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_SessionDetails_CopyInfoOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_SessionDetails_CopyInfoOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionDetails_CopyInfoOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_SessionDetails_CopyInfoOptions = _tagEOS_SessionDetails_CopyInfoOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_SessionDetails_GetSessionAttributeCountOptions {
    #[doc = " API Version: Set this to EOS_SESSIONDETAILS_GETSESSIONATTRIBUTECOUNT_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_SessionDetails_GetSessionAttributeCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_SessionDetails_GetSessionAttributeCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_SessionDetails_GetSessionAttributeCountOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_SessionDetails_GetSessionAttributeCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_SessionDetails_GetSessionAttributeCountOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_SessionDetails_GetSessionAttributeCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionDetails_GetSessionAttributeCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_SessionDetails_GetSessionAttributeCountOptions =
    _tagEOS_SessionDetails_GetSessionAttributeCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_SessionDetails_CopySessionAttributeByIndexOptions {
    #[doc = " API Version: Set this to EOS_SESSIONDETAILS_COPYSESSIONATTRIBUTEBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The index of the attribute to retrieve\n @see EOS_SessionDetails_GetSessionAttributeCount"]
    pub AttrIndex: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_SessionDetails_CopySessionAttributeByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_SessionDetails_CopySessionAttributeByIndexOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_SessionDetails_CopySessionAttributeByIndexOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_SessionDetails_CopySessionAttributeByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_SessionDetails_CopySessionAttributeByIndexOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_SessionDetails_CopySessionAttributeByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionDetails_CopySessionAttributeByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AttrIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionDetails_CopySessionAttributeByIndexOptions),
            "::",
            stringify!(AttrIndex)
        )
    );
}
pub type EOS_SessionDetails_CopySessionAttributeByIndexOptions =
    _tagEOS_SessionDetails_CopySessionAttributeByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_SessionDetails_CopySessionAttributeByKeyOptions {
    #[doc = " API Version: Set this to EOS_SESSIONDETAILS_COPYSESSIONATTRIBUTEBYKEY_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The name of the key to get the session attribution for\n @see EOS_SessionModification_AddAttribute"]
    pub AttrKey: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_SessionDetails_CopySessionAttributeByKeyOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_SessionDetails_CopySessionAttributeByKeyOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_SessionDetails_CopySessionAttributeByKeyOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_SessionDetails_CopySessionAttributeByKeyOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_SessionDetails_CopySessionAttributeByKeyOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_SessionDetails_CopySessionAttributeByKeyOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionDetails_CopySessionAttributeByKeyOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AttrKey) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_SessionDetails_CopySessionAttributeByKeyOptions),
            "::",
            stringify!(AttrKey)
        )
    );
}
pub type EOS_SessionDetails_CopySessionAttributeByKeyOptions =
    _tagEOS_SessionDetails_CopySessionAttributeByKeyOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_ActiveSession_Info {
    #[doc = " API Version: Set this to EOS_ACTIVESESSION_INFO_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Name of the session"]
    pub SessionName: *const ::std::os::raw::c_char,
    #[doc = " The Product User ID of the local user who created or joined the session"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Current state of the session"]
    pub State: EOS_EOnlineSessionState,
    #[doc = " Session details"]
    pub SessionDetails: *const EOS_SessionDetails_Info,
}
#[test]
fn bindgen_test_layout__tagEOS_ActiveSession_Info() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_ActiveSession_Info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_ActiveSession_Info>(),
        40usize,
        concat!("Size of: ", stringify!(_tagEOS_ActiveSession_Info))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_ActiveSession_Info>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_ActiveSession_Info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_ActiveSession_Info),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_ActiveSession_Info),
            "::",
            stringify!(SessionName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_ActiveSession_Info),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_ActiveSession_Info),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionDetails) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_ActiveSession_Info),
            "::",
            stringify!(SessionDetails)
        )
    );
}
pub type EOS_ActiveSession_Info = _tagEOS_ActiveSession_Info;
extern "C" {
    #[doc = " Release the memory associated with an EOS_ActiveSession_Info structure. This must be called on data retrieved from EOS_ActiveSession_CopyInfo.\n\n @param ActiveSessionInfo - The active session structure to be released\n\n @see EOS_ActiveSession_Info\n @see EOS_ActiveSession_CopyInfo"]
    pub fn EOS_ActiveSession_Info_Release(ActiveSessionInfo: *mut EOS_ActiveSession_Info);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_CopyActiveSessionHandleOptions {
    #[doc = " API Version: Set this to EOS_SESSIONS_COPYACTIVESESSIONHANDLE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Name of the session for which to retrieve a session handle"]
    pub SessionName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_CopyActiveSessionHandleOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_CopyActiveSessionHandleOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_CopyActiveSessionHandleOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_CopyActiveSessionHandleOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_CopyActiveSessionHandleOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_CopyActiveSessionHandleOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_CopyActiveSessionHandleOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_CopyActiveSessionHandleOptions),
            "::",
            stringify!(SessionName)
        )
    );
}
pub type EOS_Sessions_CopyActiveSessionHandleOptions =
    _tagEOS_Sessions_CopyActiveSessionHandleOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_AddNotifySessionInviteReceivedOptions {
    #[doc = " API Version: Set this to EOS_SESSIONS_ADDNOTIFYSESSIONINVITERECEIVED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_AddNotifySessionInviteReceivedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_AddNotifySessionInviteReceivedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_AddNotifySessionInviteReceivedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_AddNotifySessionInviteReceivedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_AddNotifySessionInviteReceivedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_AddNotifySessionInviteReceivedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_AddNotifySessionInviteReceivedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Sessions_AddNotifySessionInviteReceivedOptions =
    _tagEOS_Sessions_AddNotifySessionInviteReceivedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_SessionInviteReceivedCallbackInfo {
    #[doc = " Context that was passed into EOS_Sessions_AddNotifySessionInviteReceived"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the user who received the invite"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The Product User ID of the user who sent the invitation"]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " Invite ID used to retrieve the actual session details"]
    pub InviteId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_SessionInviteReceivedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_SessionInviteReceivedCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_SessionInviteReceivedCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_SessionInviteReceivedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_SessionInviteReceivedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_SessionInviteReceivedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_SessionInviteReceivedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_SessionInviteReceivedCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_SessionInviteReceivedCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InviteId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_SessionInviteReceivedCallbackInfo),
            "::",
            stringify!(InviteId)
        )
    );
}
pub type EOS_Sessions_SessionInviteReceivedCallbackInfo =
    _tagEOS_Sessions_SessionInviteReceivedCallbackInfo;
pub type EOS_Sessions_OnSessionInviteReceivedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Sessions_SessionInviteReceivedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_AddNotifySessionInviteAcceptedOptions {
    #[doc = " API Version: Set this to EOS_SESSIONS_ADDNOTIFYSESSIONINVITEACCEPTED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_AddNotifySessionInviteAcceptedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_AddNotifySessionInviteAcceptedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_AddNotifySessionInviteAcceptedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_AddNotifySessionInviteAcceptedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_AddNotifySessionInviteAcceptedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_AddNotifySessionInviteAcceptedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_AddNotifySessionInviteAcceptedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Sessions_AddNotifySessionInviteAcceptedOptions =
    _tagEOS_Sessions_AddNotifySessionInviteAcceptedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_SessionInviteAcceptedCallbackInfo {
    #[doc = " Context that was passed into EOS_Sessions_AddNotifySessionInviteAccepted"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Session ID that should be used for joining"]
    pub SessionId: *const ::std::os::raw::c_char,
    #[doc = " The Product User ID of the user who accepted the invitation"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The Product User ID of the user who sent the invitation"]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " Invite ID that was accepted"]
    pub InviteId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_SessionInviteAcceptedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_SessionInviteAcceptedCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_SessionInviteAcceptedCallbackInfo>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_SessionInviteAcceptedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_SessionInviteAcceptedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_SessionInviteAcceptedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_SessionInviteAcceptedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_SessionInviteAcceptedCallbackInfo),
            "::",
            stringify!(SessionId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_SessionInviteAcceptedCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_SessionInviteAcceptedCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InviteId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_SessionInviteAcceptedCallbackInfo),
            "::",
            stringify!(InviteId)
        )
    );
}
pub type EOS_Sessions_SessionInviteAcceptedCallbackInfo =
    _tagEOS_Sessions_SessionInviteAcceptedCallbackInfo;
pub type EOS_Sessions_OnSessionInviteAcceptedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Sessions_SessionInviteAcceptedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_AddNotifySessionInviteRejectedOptions {
    #[doc = " API Version: Set this to EOS_SESSIONS_ADDNOTIFYSESSIONINVITEREJECTED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_AddNotifySessionInviteRejectedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_AddNotifySessionInviteRejectedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_AddNotifySessionInviteRejectedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_AddNotifySessionInviteRejectedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_AddNotifySessionInviteRejectedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_AddNotifySessionInviteRejectedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_AddNotifySessionInviteRejectedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Sessions_AddNotifySessionInviteRejectedOptions =
    _tagEOS_Sessions_AddNotifySessionInviteRejectedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_SessionInviteRejectedCallbackInfo {
    #[doc = " Context that was passed into EOS_Lobby_AddNotifySessionInviteRejected"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The invite ID"]
    pub InviteId: *const ::std::os::raw::c_char,
    #[doc = " The Product User ID of the local user who rejected the invitation"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The Product User ID of the user who sent the invitation"]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " Optional session ID"]
    pub SessionId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_SessionInviteRejectedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_SessionInviteRejectedCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_SessionInviteRejectedCallbackInfo>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_SessionInviteRejectedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_SessionInviteRejectedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_SessionInviteRejectedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_SessionInviteRejectedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InviteId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_SessionInviteRejectedCallbackInfo),
            "::",
            stringify!(InviteId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_SessionInviteRejectedCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_SessionInviteRejectedCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_SessionInviteRejectedCallbackInfo),
            "::",
            stringify!(SessionId)
        )
    );
}
pub type EOS_Sessions_SessionInviteRejectedCallbackInfo =
    _tagEOS_Sessions_SessionInviteRejectedCallbackInfo;
pub type EOS_Sessions_OnSessionInviteRejectedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Sessions_SessionInviteRejectedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_AddNotifyJoinSessionAcceptedOptions {
    #[doc = " API Version: Set this to EOS_SESSIONS_ADDNOTIFYJOINSESSIONACCEPTED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_AddNotifyJoinSessionAcceptedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_AddNotifyJoinSessionAcceptedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_AddNotifyJoinSessionAcceptedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_AddNotifyJoinSessionAcceptedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_AddNotifyJoinSessionAcceptedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_AddNotifyJoinSessionAcceptedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_AddNotifyJoinSessionAcceptedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Sessions_AddNotifyJoinSessionAcceptedOptions =
    _tagEOS_Sessions_AddNotifyJoinSessionAcceptedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_JoinSessionAcceptedCallbackInfo {
    #[doc = " Context that was passed into EOS_Sessions_AddNotifyJoinSessionAccepted"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID for the user who initialized the game"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The UI Event associated with this Join Game event.\n This should be used with EOS_Sessions_CopySessionHandleByUiEventId to get a handle to be used\n when calling EOS_Sessions_JoinSession."]
    pub UiEventId: EOS_UI_EventId,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_JoinSessionAcceptedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_JoinSessionAcceptedCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_JoinSessionAcceptedCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_JoinSessionAcceptedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_JoinSessionAcceptedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_JoinSessionAcceptedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_JoinSessionAcceptedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_JoinSessionAcceptedCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UiEventId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_JoinSessionAcceptedCallbackInfo),
            "::",
            stringify!(UiEventId)
        )
    );
}
pub type EOS_Sessions_JoinSessionAcceptedCallbackInfo =
    _tagEOS_Sessions_JoinSessionAcceptedCallbackInfo;
pub type EOS_Sessions_OnJoinSessionAcceptedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Sessions_JoinSessionAcceptedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_CopySessionHandleByInviteIdOptions {
    #[doc = " API Version: Set this to EOS_SESSIONS_COPYSESSIONHANDLEBYINVITEID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Invite ID for which to retrieve a session handle"]
    pub InviteId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_CopySessionHandleByInviteIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_CopySessionHandleByInviteIdOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_CopySessionHandleByInviteIdOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_CopySessionHandleByInviteIdOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_CopySessionHandleByInviteIdOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_CopySessionHandleByInviteIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_CopySessionHandleByInviteIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InviteId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_CopySessionHandleByInviteIdOptions),
            "::",
            stringify!(InviteId)
        )
    );
}
pub type EOS_Sessions_CopySessionHandleByInviteIdOptions =
    _tagEOS_Sessions_CopySessionHandleByInviteIdOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_CopySessionHandleByUiEventIdOptions {
    #[doc = " API Version: Set this to EOS_SESSIONS_COPYSESSIONHANDLEBYUIEVENTID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " UI Event associated with the session"]
    pub UiEventId: EOS_UI_EventId,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_CopySessionHandleByUiEventIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_CopySessionHandleByUiEventIdOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_CopySessionHandleByUiEventIdOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_CopySessionHandleByUiEventIdOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_CopySessionHandleByUiEventIdOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_CopySessionHandleByUiEventIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_CopySessionHandleByUiEventIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UiEventId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_CopySessionHandleByUiEventIdOptions),
            "::",
            stringify!(UiEventId)
        )
    );
}
pub type EOS_Sessions_CopySessionHandleByUiEventIdOptions =
    _tagEOS_Sessions_CopySessionHandleByUiEventIdOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_CopySessionHandleForPresenceOptions {
    #[doc = " API Version: Set this to EOS_SESSIONS_COPYSESSIONHANDLEFORPRESENCE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user associated with the session"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_CopySessionHandleForPresenceOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_CopySessionHandleForPresenceOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_CopySessionHandleForPresenceOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_CopySessionHandleForPresenceOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_CopySessionHandleForPresenceOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_CopySessionHandleForPresenceOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_CopySessionHandleForPresenceOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_CopySessionHandleForPresenceOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Sessions_CopySessionHandleForPresenceOptions =
    _tagEOS_Sessions_CopySessionHandleForPresenceOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_IsUserInSessionOptions {
    #[doc = " API Version: Set this to EOS_SESSIONS_ISUSERINSESSION_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Active session name to search within"]
    pub SessionName: *const ::std::os::raw::c_char,
    #[doc = " Product User ID to search for in the session"]
    pub TargetUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_IsUserInSessionOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_IsUserInSessionOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_IsUserInSessionOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_IsUserInSessionOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_IsUserInSessionOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_IsUserInSessionOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_IsUserInSessionOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_IsUserInSessionOptions),
            "::",
            stringify!(SessionName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_IsUserInSessionOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Sessions_IsUserInSessionOptions = _tagEOS_Sessions_IsUserInSessionOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_DumpSessionStateOptions {
    #[doc = " API Version: Set this to EOS_SESSIONS_DUMPSESSIONSTATE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Name of the session"]
    pub SessionName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_DumpSessionStateOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_DumpSessionStateOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_DumpSessionStateOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_DumpSessionStateOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_DumpSessionStateOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_DumpSessionStateOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_DumpSessionStateOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_DumpSessionStateOptions),
            "::",
            stringify!(SessionName)
        )
    );
}
pub type EOS_Sessions_DumpSessionStateOptions = _tagEOS_Sessions_DumpSessionStateOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_AddNotifyLeaveSessionRequestedOptions {
    #[doc = " API Version: Set this to EOS_SESSIONS_ADDNOTIFYLEAVESESSIONREQUESTED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_AddNotifyLeaveSessionRequestedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_AddNotifyLeaveSessionRequestedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_AddNotifyLeaveSessionRequestedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_AddNotifyLeaveSessionRequestedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_AddNotifyLeaveSessionRequestedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_AddNotifyLeaveSessionRequestedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_AddNotifyLeaveSessionRequestedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Sessions_AddNotifyLeaveSessionRequestedOptions =
    _tagEOS_Sessions_AddNotifyLeaveSessionRequestedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_LeaveSessionRequestedCallbackInfo {
    #[doc = " Context that was passed into EOS_Sessions_OnLeaveSessionRequestedCallback"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the local user who received the leave session notification."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Name of the session associated with the leave session request."]
    pub SessionName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_LeaveSessionRequestedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sessions_LeaveSessionRequestedCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_LeaveSessionRequestedCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_LeaveSessionRequestedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_LeaveSessionRequestedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_LeaveSessionRequestedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_LeaveSessionRequestedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_LeaveSessionRequestedCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_LeaveSessionRequestedCallbackInfo),
            "::",
            stringify!(SessionName)
        )
    );
}
pub type EOS_Sessions_LeaveSessionRequestedCallbackInfo =
    _tagEOS_Sessions_LeaveSessionRequestedCallbackInfo;
pub type EOS_Sessions_OnLeaveSessionRequestedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Sessions_LeaveSessionRequestedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_AddNotifySendSessionNativeInviteRequestedOptions {
    #[doc = " API Version: Set this to EOS_SESSIONS_ADDNOTIFYSENDSESSIONNATIVEINVITEREQUESTED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_AddNotifySendSessionNativeInviteRequestedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Sessions_AddNotifySendSessionNativeInviteRequestedOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_AddNotifySendSessionNativeInviteRequestedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_AddNotifySendSessionNativeInviteRequestedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_AddNotifySendSessionNativeInviteRequestedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_AddNotifySendSessionNativeInviteRequestedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_AddNotifySendSessionNativeInviteRequestedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Sessions_AddNotifySendSessionNativeInviteRequestedOptions =
    _tagEOS_Sessions_AddNotifySendSessionNativeInviteRequestedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sessions_SendSessionNativeInviteRequestedCallbackInfo {
    #[doc = " Context that was passed into EOS_Sessions_AddNotifySendSessionNativeInviteRequested"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Identifies this event which will need to be acknowledged with EOS_UI_AcknowledgeEventId().\n @see EOS_UI_AcknowledgeEventId"]
    pub UiEventId: EOS_UI_EventId,
    #[doc = " The Product User ID of the local user who is inviting."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The Native Platform Account Type. If only a single integrated platform is configured then\n this will always reference that platform."]
    pub TargetNativeAccountType: EOS_IntegratedPlatformType,
    #[doc = " The Native Platform Account ID of the target user being invited."]
    pub TargetUserNativeAccountId: *const ::std::os::raw::c_char,
    #[doc = " Session ID that the user is being invited to"]
    pub SessionId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Sessions_SendSessionNativeInviteRequestedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Sessions_SendSessionNativeInviteRequestedCallbackInfo,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sessions_SendSessionNativeInviteRequestedCallbackInfo>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sessions_SendSessionNativeInviteRequestedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sessions_SendSessionNativeInviteRequestedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sessions_SendSessionNativeInviteRequestedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_SendSessionNativeInviteRequestedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UiEventId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_SendSessionNativeInviteRequestedCallbackInfo),
            "::",
            stringify!(UiEventId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_SendSessionNativeInviteRequestedCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetNativeAccountType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_SendSessionNativeInviteRequestedCallbackInfo),
            "::",
            stringify!(TargetNativeAccountType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserNativeAccountId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_SendSessionNativeInviteRequestedCallbackInfo),
            "::",
            stringify!(TargetUserNativeAccountId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionId) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sessions_SendSessionNativeInviteRequestedCallbackInfo),
            "::",
            stringify!(SessionId)
        )
    );
}
pub type EOS_Sessions_SendSessionNativeInviteRequestedCallbackInfo =
    _tagEOS_Sessions_SendSessionNativeInviteRequestedCallbackInfo;
pub type EOS_Sessions_OnSendSessionNativeInviteRequestedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Sessions_SendSessionNativeInviteRequestedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_LobbyHandle {
    _unused: [u8; 0],
}
#[doc = " Handle to the lobby interface"]
pub type EOS_HLobby = *mut EOS_LobbyHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_LobbyModificationHandle {
    _unused: [u8; 0],
}
#[doc = " Handle to a lobby modification object"]
pub type EOS_HLobbyModification = *mut EOS_LobbyModificationHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_LobbyDetailsHandle {
    _unused: [u8; 0],
}
#[doc = " Handle to a single lobby"]
pub type EOS_HLobbyDetails = *mut EOS_LobbyDetailsHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_LobbySearchHandle {
    _unused: [u8; 0],
}
#[doc = " Handle to the calls responsible for creating a search object"]
pub type EOS_HLobbySearch = *mut EOS_LobbySearchHandle;
extern "C" {
    pub fn EOS_LobbyModification_Release(LobbyModificationHandle: EOS_HLobbyModification);
}
extern "C" {
    #[doc = " Release the memory associated with a single lobby. This must be called on data retrieved from EOS_LobbySearch_CopySearchResultByIndex.\n\n @param LobbyHandle - The lobby handle to release\n\n @see EOS_LobbySearch_CopySearchResultByIndex"]
    pub fn EOS_LobbyDetails_Release(LobbyHandle: EOS_HLobbyDetails);
}
extern "C" {
    #[doc = " Release the memory associated with a lobby search. This must be called on data retrieved from EOS_Lobby_CreateLobbySearch.\n\n @param LobbySearchHandle - The lobby search handle to release\n\n @see EOS_Lobby_CreateLobbySearch"]
    pub fn EOS_LobbySearch_Release(LobbySearchHandle: EOS_HLobbySearch);
}
#[doc = " All lobbies are referenced by a unique lobby ID"]
pub type EOS_LobbyId = *const ::std::os::raw::c_char;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_ELobbyPermissionLevel {
    #[doc = " Anyone can find this lobby as long as it isn't full"]
    EOS_LPL_PUBLICADVERTISED = 0,
    #[doc = " Players who have access to presence can see this lobby"]
    EOS_LPL_JOINVIAPRESENCE = 1,
    #[doc = " Only players with invites registered can see this lobby"]
    EOS_LPL_INVITEONLY = 2,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_ELobbyAttributeVisibility {
    #[doc = " Data is visible to lobby members, searchable and visible in search results."]
    EOS_LAT_PUBLIC = 0,
    #[doc = " Data is only visible to the user setting the data. Data is not visible to lobby members, not searchable, and not visible in search results."]
    EOS_LAT_PRIVATE = 1,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_ELobbyMemberStatus {
    #[doc = " The user has joined the lobby"]
    EOS_LMS_JOINED = 0,
    #[doc = " The user has explicitly left the lobby"]
    EOS_LMS_LEFT = 1,
    #[doc = " The user has unexpectedly left the lobby"]
    EOS_LMS_DISCONNECTED = 2,
    #[doc = " The user has been kicked from the lobby"]
    EOS_LMS_KICKED = 3,
    #[doc = " The user has been promoted to lobby owner"]
    EOS_LMS_PROMOTED = 4,
    #[doc = " The lobby has been closed and user has been removed"]
    EOS_LMS_CLOSED = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbyDetails_Info {
    #[doc = " API Version: Set this to EOS_LOBBYDETAILS_INFO_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Lobby ID"]
    pub LobbyId: EOS_LobbyId,
    #[doc = " The Product User ID of the current owner of the lobby"]
    pub LobbyOwnerUserId: EOS_ProductUserId,
    #[doc = " Permission level of the lobby"]
    pub PermissionLevel: EOS_ELobbyPermissionLevel,
    #[doc = " Current available space"]
    pub AvailableSlots: u32,
    #[doc = " Max allowed members in the lobby"]
    pub MaxMembers: u32,
    #[doc = " If true, users can invite others to this lobby"]
    pub bAllowInvites: EOS_Bool,
    #[doc = " The main indexed parameter for this lobby, can be any string (i.e. \"Region:GameMode\")"]
    pub BucketId: *const ::std::os::raw::c_char,
    #[doc = " Is host migration allowed"]
    pub bAllowHostMigration: EOS_Bool,
    #[doc = " Was a Real-Time Communication (RTC) room enabled at lobby creation?"]
    pub bRTCRoomEnabled: EOS_Bool,
    #[doc = " Is EOS_Lobby_JoinLobbyById allowed"]
    pub bAllowJoinById: EOS_Bool,
    #[doc = " Does rejoining after being kicked require an invite"]
    pub bRejoinAfterKickRequiresInvite: EOS_Bool,
    #[doc = " If true, this lobby will be associated with the local user's presence information."]
    pub bPresenceEnabled: EOS_Bool,
    #[doc = " Array of platform IDs indicating the player platforms allowed to register with the session. Platform IDs are\n found in the EOS header file, e.g. EOS_OPT_Epic. For some platforms, the value will be in the EOS Platform specific\n header file. If null, the lobby will be unrestricted."]
    pub AllowedPlatformIds: *const u32,
    #[doc = " Number of platform IDs in the array"]
    pub AllowedPlatformIdsCount: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbyDetails_Info() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbyDetails_Info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbyDetails_Info>(),
        88usize,
        concat!("Size of: ", stringify!(_tagEOS_LobbyDetails_Info))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbyDetails_Info>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_LobbyDetails_Info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_Info),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_Info),
            "::",
            stringify!(LobbyId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyOwnerUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_Info),
            "::",
            stringify!(LobbyOwnerUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PermissionLevel) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_Info),
            "::",
            stringify!(PermissionLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AvailableSlots) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_Info),
            "::",
            stringify!(AvailableSlots)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxMembers) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_Info),
            "::",
            stringify!(MaxMembers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bAllowInvites) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_Info),
            "::",
            stringify!(bAllowInvites)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BucketId) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_Info),
            "::",
            stringify!(BucketId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bAllowHostMigration) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_Info),
            "::",
            stringify!(bAllowHostMigration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bRTCRoomEnabled) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_Info),
            "::",
            stringify!(bRTCRoomEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bAllowJoinById) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_Info),
            "::",
            stringify!(bAllowJoinById)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).bRejoinAfterKickRequiresInvite) as usize - ptr as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_Info),
            "::",
            stringify!(bRejoinAfterKickRequiresInvite)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bPresenceEnabled) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_Info),
            "::",
            stringify!(bPresenceEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllowedPlatformIds) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_Info),
            "::",
            stringify!(AllowedPlatformIds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllowedPlatformIdsCount) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_Info),
            "::",
            stringify!(AllowedPlatformIdsCount)
        )
    );
}
pub type EOS_LobbyDetails_Info = _tagEOS_LobbyDetails_Info;
extern "C" {
    pub fn EOS_LobbyDetails_Info_Release(LobbyDetailsInfo: *mut EOS_LobbyDetails_Info);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_LocalRTCOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_LOCALRTCOPTIONS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Flags for the local user in this room. The default is 0 if this struct is not specified. @see EOS_RTC_JoinRoomOptions::Flags"]
    pub Flags: u32,
    #[doc = " Set to EOS_TRUE to enable Manual Audio Input. If manual audio input is enabled, audio recording is not started and the audio buffers\n must be passed manually using EOS_RTCAudio_SendAudio. The default is EOS_FALSE if this struct is not specified."]
    pub bUseManualAudioInput: EOS_Bool,
    #[doc = " Set to EOS_TRUE to enable Manual Audio Output. If manual audio output is enabled, audio rendering is not started and the audio buffers\n must be received with EOS_RTCAudio_AddNotifyAudioBeforeRender and rendered manually. The default is EOS_FALSE if this struct is not\n specified."]
    pub bUseManualAudioOutput: EOS_Bool,
    #[doc = " Set to EOS_TRUE to start the audio input device's stream as muted when first connecting to the RTC room.\n\n It must be manually unmuted with a call to EOS_RTCAudio_UpdateSending. If manual audio output is enabled, this value is ignored.\n The default value is EOS_FALSE if this struct is not specified."]
    pub bLocalAudioDeviceInputStartsMuted: EOS_Bool,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_LocalRTCOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_LocalRTCOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_LocalRTCOptions>(),
        20usize,
        concat!("Size of: ", stringify!(_tagEOS_Lobby_LocalRTCOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_LocalRTCOptions>(),
        4usize,
        concat!("Alignment of ", stringify!(_tagEOS_Lobby_LocalRTCOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LocalRTCOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LocalRTCOptions),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bUseManualAudioInput) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LocalRTCOptions),
            "::",
            stringify!(bUseManualAudioInput)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bUseManualAudioOutput) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LocalRTCOptions),
            "::",
            stringify!(bUseManualAudioOutput)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).bLocalAudioDeviceInputStartsMuted) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LocalRTCOptions),
            "::",
            stringify!(bLocalAudioDeviceInputStartsMuted)
        )
    );
}
pub type EOS_Lobby_LocalRTCOptions = _tagEOS_Lobby_LocalRTCOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_CreateLobbyOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_CREATELOBBY_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user creating the lobby; this user will automatically join the lobby as its owner"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The maximum number of users who can be in the lobby at a time"]
    pub MaxLobbyMembers: u32,
    #[doc = " The initial permission level of the lobby"]
    pub PermissionLevel: EOS_ELobbyPermissionLevel,
    #[doc = " If true, this lobby will be associated with the local user's presence information. A user's presence can only be associated with one lobby at a time.\n This affects the ability of the Social Overlay to show game related actions to take in the user's social graph.\n\n @note The Social Overlay can handle only one of the following three options at a time:\n * using the bPresenceEnabled flags within the Sessions interface\n * using the bPresenceEnabled flags within the Lobby interface\n * using EOS_PresenceModification_SetJoinInfo\n\n @see EOS_PresenceModification_SetJoinInfoOptions\n @see EOS_Lobby_JoinLobbyOptions\n @see EOS_Lobby_JoinLobbyByIdOptions\n @see EOS_Sessions_CreateSessionModificationOptions\n @see EOS_Sessions_JoinSessionOptions"]
    pub bPresenceEnabled: EOS_Bool,
    #[doc = " Are members of the lobby allowed to invite others"]
    pub bAllowInvites: EOS_Bool,
    #[doc = " Bucket ID associated with the lobby"]
    pub BucketId: *const ::std::os::raw::c_char,
    #[doc = " Is host migration allowed (will the lobby stay open if the original host leaves?)\n NOTE: EOS_Lobby_PromoteMember is still allowed regardless of this setting"]
    pub bDisableHostMigration: EOS_Bool,
    #[doc = " Creates a real-time communication (RTC) room for all members of this lobby. All members of the lobby will automatically join the RTC\n room when they connect to the lobby and they will automatically leave the RTC room when they leave or are removed from the lobby.\n While the joining and leaving of the RTC room is automatic, applications will still need to use the EOS RTC interfaces to handle all\n other functionality for the room.\n\n @see EOS_Lobby_GetRTCRoomName\n @see EOS_Lobby_AddNotifyRTCRoomConnectionChanged"]
    pub bEnableRTCRoom: EOS_Bool,
    #[doc = " (Optional) Allows the local application to set local audio options for the RTC Room if it is enabled. Set this to NULL if the RTC\n RTC room is disabled or you would like to use the defaults."]
    pub LocalRTCOptions: *const EOS_Lobby_LocalRTCOptions,
    #[doc = " (Optional) Set to a globally unique value to override the backend assignment\n If not specified the backend service will assign one to the lobby.  Do not mix and match override and non override settings.\n This value can be of size [EOS_LOBBY_MIN_LOBBYIDOVERRIDE_LENGTH, EOS_LOBBY_MAX_LOBBYIDOVERRIDE_LENGTH]"]
    pub LobbyId: EOS_LobbyId,
    #[doc = " Is EOS_Lobby_JoinLobbyById allowed.\n This is provided to support cases where an integrated platform's invite system is used.\n In these cases the game should provide the lobby ID securely to the invited player.  Such as by attaching the\n lobby ID to the integrated platform's session data or sending the lobby ID within the invite data."]
    pub bEnableJoinById: EOS_Bool,
    #[doc = " Does rejoining after being kicked require an invite?\n When this is set, a kicked player cannot return to the session even if the session was set with\n EOS_LPL_PUBLICADVERTISED.  When this is set, a player with invite privileges must use EOS_Lobby_SendInvite to\n allow the kicked player to return to the session."]
    pub bRejoinAfterKickRequiresInvite: EOS_Bool,
    #[doc = " Array of platform IDs indicating the player platforms allowed to register with the session. Platform IDs are\n found in the EOS header file, e.g. EOS_OPT_Epic. For some platforms, the value will be in the EOS Platform specific\n header file. If null, the lobby will be unrestricted."]
    pub AllowedPlatformIds: *const u32,
    #[doc = " Number of platform IDs in the array"]
    pub AllowedPlatformIdsCount: u32,
    #[doc = " This value indicates whether or not the lobby owner allows crossplay interactions. If false, the lobby owner\n will be treated as allowing crossplay. If it is set to true, AllowedPlatformIds must have a single entry that matches\n the platform of the lobby owner."]
    pub bCrossplayOptOut: EOS_Bool,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_CreateLobbyOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_CreateLobbyOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_CreateLobbyOptions>(),
        88usize,
        concat!("Size of: ", stringify!(_tagEOS_Lobby_CreateLobbyOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_CreateLobbyOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_CreateLobbyOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CreateLobbyOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CreateLobbyOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxLobbyMembers) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CreateLobbyOptions),
            "::",
            stringify!(MaxLobbyMembers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PermissionLevel) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CreateLobbyOptions),
            "::",
            stringify!(PermissionLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bPresenceEnabled) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CreateLobbyOptions),
            "::",
            stringify!(bPresenceEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bAllowInvites) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CreateLobbyOptions),
            "::",
            stringify!(bAllowInvites)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BucketId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CreateLobbyOptions),
            "::",
            stringify!(BucketId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bDisableHostMigration) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CreateLobbyOptions),
            "::",
            stringify!(bDisableHostMigration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bEnableRTCRoom) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CreateLobbyOptions),
            "::",
            stringify!(bEnableRTCRoom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalRTCOptions) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CreateLobbyOptions),
            "::",
            stringify!(LocalRTCOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CreateLobbyOptions),
            "::",
            stringify!(LobbyId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bEnableJoinById) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CreateLobbyOptions),
            "::",
            stringify!(bEnableJoinById)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).bRejoinAfterKickRequiresInvite) as usize - ptr as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CreateLobbyOptions),
            "::",
            stringify!(bRejoinAfterKickRequiresInvite)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllowedPlatformIds) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CreateLobbyOptions),
            "::",
            stringify!(AllowedPlatformIds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllowedPlatformIdsCount) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CreateLobbyOptions),
            "::",
            stringify!(AllowedPlatformIdsCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bCrossplayOptOut) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CreateLobbyOptions),
            "::",
            stringify!(bCrossplayOptOut)
        )
    );
}
pub type EOS_Lobby_CreateLobbyOptions = _tagEOS_Lobby_CreateLobbyOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_CreateLobbyCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Lobby_CreateLobby"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The new lobby's ID"]
    pub LobbyId: EOS_LobbyId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_CreateLobbyCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_CreateLobbyCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_CreateLobbyCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_CreateLobbyCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_CreateLobbyCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_CreateLobbyCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CreateLobbyCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CreateLobbyCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CreateLobbyCallbackInfo),
            "::",
            stringify!(LobbyId)
        )
    );
}
pub type EOS_Lobby_CreateLobbyCallbackInfo = _tagEOS_Lobby_CreateLobbyCallbackInfo;
pub type EOS_Lobby_OnCreateLobbyCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Lobby_CreateLobbyCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_DestroyLobbyOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_DESTROYLOBBY_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user requesting destruction of the lobby; this user must currently own the lobby"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The ID of the lobby to destroy"]
    pub LobbyId: EOS_LobbyId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_DestroyLobbyOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_DestroyLobbyOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_DestroyLobbyOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Lobby_DestroyLobbyOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_DestroyLobbyOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_DestroyLobbyOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_DestroyLobbyOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_DestroyLobbyOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_DestroyLobbyOptions),
            "::",
            stringify!(LobbyId)
        )
    );
}
pub type EOS_Lobby_DestroyLobbyOptions = _tagEOS_Lobby_DestroyLobbyOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_DestroyLobbyCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Lobby_DestroyLobby"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The destroyed lobby's ID"]
    pub LobbyId: EOS_LobbyId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_DestroyLobbyCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_DestroyLobbyCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_DestroyLobbyCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_DestroyLobbyCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_DestroyLobbyCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_DestroyLobbyCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_DestroyLobbyCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_DestroyLobbyCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_DestroyLobbyCallbackInfo),
            "::",
            stringify!(LobbyId)
        )
    );
}
pub type EOS_Lobby_DestroyLobbyCallbackInfo = _tagEOS_Lobby_DestroyLobbyCallbackInfo;
pub type EOS_Lobby_OnDestroyLobbyCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Lobby_DestroyLobbyCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_JoinLobbyOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_JOINLOBBY_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The handle of the lobby to join"]
    pub LobbyDetailsHandle: EOS_HLobbyDetails,
    #[doc = " The Product User ID of the local user joining the lobby"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " If true, this lobby will be associated with the local user's presence information. A user can only associate one lobby at a time with their presence information.\n This affects the ability of the Social Overlay to show game related actions to take in the user's social graph.\n\n @note The Social Overlay can handle only one of the following three options at a time:\n * using the bPresenceEnabled flags within the Sessions interface\n * using the bPresenceEnabled flags within the Lobby interface\n * using EOS_PresenceModification_SetJoinInfo\n\n @see EOS_PresenceModification_SetJoinInfoOptions\n @see EOS_Lobby_CreateLobbyOptions\n @see EOS_Lobby_JoinLobbyOptions\n @see EOS_Sessions_CreateSessionModificationOptions\n @see EOS_Sessions_JoinSessionOptions"]
    pub bPresenceEnabled: EOS_Bool,
    #[doc = " (Optional) Set this value to override the default local options for the RTC Room, if it is enabled for this lobby. Set this to NULL if\n your application does not use the Lobby RTC Rooms feature, or if you would like to use the default settings. This option is ignored if\n the specified lobby does not have an RTC Room enabled and will not cause errors."]
    pub LocalRTCOptions: *const EOS_Lobby_LocalRTCOptions,
    #[doc = " This value indicates whether or not the local user allows crossplay interactions. If it is false, the local user\n will be treated as allowing crossplay."]
    pub bCrossplayOptOut: EOS_Bool,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_JoinLobbyOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_JoinLobbyOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_JoinLobbyOptions>(),
        48usize,
        concat!("Size of: ", stringify!(_tagEOS_Lobby_JoinLobbyOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_JoinLobbyOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Lobby_JoinLobbyOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_JoinLobbyOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyDetailsHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_JoinLobbyOptions),
            "::",
            stringify!(LobbyDetailsHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_JoinLobbyOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bPresenceEnabled) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_JoinLobbyOptions),
            "::",
            stringify!(bPresenceEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalRTCOptions) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_JoinLobbyOptions),
            "::",
            stringify!(LocalRTCOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bCrossplayOptOut) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_JoinLobbyOptions),
            "::",
            stringify!(bCrossplayOptOut)
        )
    );
}
pub type EOS_Lobby_JoinLobbyOptions = _tagEOS_Lobby_JoinLobbyOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_JoinLobbyCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Lobby_JoinLobby"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The ID of the lobby"]
    pub LobbyId: EOS_LobbyId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_JoinLobbyCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_JoinLobbyCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_JoinLobbyCallbackInfo>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Lobby_JoinLobbyCallbackInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_JoinLobbyCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_JoinLobbyCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_JoinLobbyCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_JoinLobbyCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_JoinLobbyCallbackInfo),
            "::",
            stringify!(LobbyId)
        )
    );
}
pub type EOS_Lobby_JoinLobbyCallbackInfo = _tagEOS_Lobby_JoinLobbyCallbackInfo;
pub type EOS_Lobby_OnJoinLobbyCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Lobby_JoinLobbyCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_JoinLobbyByIdOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_JOINLOBBYBYID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The ID of the lobby"]
    pub LobbyId: EOS_LobbyId,
    #[doc = " The Product User ID of the local user joining the lobby"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " If true, this lobby will be associated with the user's presence information. A user can only associate one lobby at a time with their presence information.\n This affects the ability of the Social Overlay to show game related actions to take in the user's social graph.\n\n @note The Social Overlay can handle only one of the following three options at a time:\n * using the bPresenceEnabled flags within the Sessions interface\n * using the bPresenceEnabled flags within the Lobby interface\n * using EOS_PresenceModification_SetJoinInfo\n\n @see EOS_PresenceModification_SetJoinInfoOptions\n @see EOS_Lobby_CreateLobbyOptions\n @see EOS_Lobby_JoinLobbyOptions\n @see EOS_Lobby_JoinLobbyByIdOptions\n @see EOS_Sessions_CreateSessionModificationOptions\n @see EOS_Sessions_JoinSessionOptions"]
    pub bPresenceEnabled: EOS_Bool,
    #[doc = " (Optional) Set this value to override the default local options for the RTC Room, if it is enabled for this lobby. Set this to NULL if\n your application does not use the Lobby RTC Rooms feature, or if you would like to use the default settings. This option is ignored if\n the specified lobby does not have an RTC Room enabled and will not cause errors."]
    pub LocalRTCOptions: *const EOS_Lobby_LocalRTCOptions,
    #[doc = " This value indicates whether or not the local user allows crossplay interactions. If it is false, the local user\n will be treated as allowing crossplay."]
    pub bCrossplayOptOut: EOS_Bool,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_JoinLobbyByIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_JoinLobbyByIdOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_JoinLobbyByIdOptions>(),
        48usize,
        concat!("Size of: ", stringify!(_tagEOS_Lobby_JoinLobbyByIdOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_JoinLobbyByIdOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_JoinLobbyByIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_JoinLobbyByIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_JoinLobbyByIdOptions),
            "::",
            stringify!(LobbyId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_JoinLobbyByIdOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bPresenceEnabled) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_JoinLobbyByIdOptions),
            "::",
            stringify!(bPresenceEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalRTCOptions) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_JoinLobbyByIdOptions),
            "::",
            stringify!(LocalRTCOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bCrossplayOptOut) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_JoinLobbyByIdOptions),
            "::",
            stringify!(bCrossplayOptOut)
        )
    );
}
pub type EOS_Lobby_JoinLobbyByIdOptions = _tagEOS_Lobby_JoinLobbyByIdOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_JoinLobbyByIdCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Lobby_JoinLobbyById"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The ID of the lobby"]
    pub LobbyId: EOS_LobbyId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_JoinLobbyByIdCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_JoinLobbyByIdCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_JoinLobbyByIdCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_JoinLobbyByIdCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_JoinLobbyByIdCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_JoinLobbyByIdCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_JoinLobbyByIdCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_JoinLobbyByIdCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_JoinLobbyByIdCallbackInfo),
            "::",
            stringify!(LobbyId)
        )
    );
}
pub type EOS_Lobby_JoinLobbyByIdCallbackInfo = _tagEOS_Lobby_JoinLobbyByIdCallbackInfo;
pub type EOS_Lobby_OnJoinLobbyByIdCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Lobby_JoinLobbyByIdCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_LeaveLobbyOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_LEAVELOBBY_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user leaving the lobby"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The ID of the lobby"]
    pub LobbyId: EOS_LobbyId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_LeaveLobbyOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_LeaveLobbyOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_LeaveLobbyOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Lobby_LeaveLobbyOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_LeaveLobbyOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Lobby_LeaveLobbyOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LeaveLobbyOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LeaveLobbyOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LeaveLobbyOptions),
            "::",
            stringify!(LobbyId)
        )
    );
}
pub type EOS_Lobby_LeaveLobbyOptions = _tagEOS_Lobby_LeaveLobbyOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_LeaveLobbyCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Lobby_LeaveLobby"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The ID of the lobby"]
    pub LobbyId: EOS_LobbyId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_LeaveLobbyCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_LeaveLobbyCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_LeaveLobbyCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_LeaveLobbyCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_LeaveLobbyCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_LeaveLobbyCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LeaveLobbyCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LeaveLobbyCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LeaveLobbyCallbackInfo),
            "::",
            stringify!(LobbyId)
        )
    );
}
pub type EOS_Lobby_LeaveLobbyCallbackInfo = _tagEOS_Lobby_LeaveLobbyCallbackInfo;
pub type EOS_Lobby_OnLeaveLobbyCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Lobby_LeaveLobbyCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_UpdateLobbyModificationOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_UPDATELOBBYMODIFICATION_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The ID of the local user making modifications. Must be the owner to modify lobby data, but any lobby member can modify their own attributes."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The ID of the lobby"]
    pub LobbyId: EOS_LobbyId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_UpdateLobbyModificationOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_UpdateLobbyModificationOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_UpdateLobbyModificationOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_UpdateLobbyModificationOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_UpdateLobbyModificationOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_UpdateLobbyModificationOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_UpdateLobbyModificationOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_UpdateLobbyModificationOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_UpdateLobbyModificationOptions),
            "::",
            stringify!(LobbyId)
        )
    );
}
pub type EOS_Lobby_UpdateLobbyModificationOptions = _tagEOS_Lobby_UpdateLobbyModificationOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_UpdateLobbyOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_UPDATELOBBY_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Builder handle"]
    pub LobbyModificationHandle: EOS_HLobbyModification,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_UpdateLobbyOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_UpdateLobbyOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_UpdateLobbyOptions>(),
        16usize,
        concat!("Size of: ", stringify!(_tagEOS_Lobby_UpdateLobbyOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_UpdateLobbyOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_UpdateLobbyOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_UpdateLobbyOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyModificationHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_UpdateLobbyOptions),
            "::",
            stringify!(LobbyModificationHandle)
        )
    );
}
pub type EOS_Lobby_UpdateLobbyOptions = _tagEOS_Lobby_UpdateLobbyOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_UpdateLobbyCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Lobby_UpdateLobby"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The ID of the lobby"]
    pub LobbyId: EOS_LobbyId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_UpdateLobbyCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_UpdateLobbyCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_UpdateLobbyCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_UpdateLobbyCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_UpdateLobbyCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_UpdateLobbyCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_UpdateLobbyCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_UpdateLobbyCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_UpdateLobbyCallbackInfo),
            "::",
            stringify!(LobbyId)
        )
    );
}
pub type EOS_Lobby_UpdateLobbyCallbackInfo = _tagEOS_Lobby_UpdateLobbyCallbackInfo;
pub type EOS_Lobby_OnUpdateLobbyCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Lobby_UpdateLobbyCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_PromoteMemberOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_PROMOTEMEMBER_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The ID of the lobby"]
    pub LobbyId: EOS_LobbyId,
    #[doc = " The Product User ID of the local user making the request"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The Product User ID of the member to promote to owner of the lobby"]
    pub TargetUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_PromoteMemberOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_PromoteMemberOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_PromoteMemberOptions>(),
        32usize,
        concat!("Size of: ", stringify!(_tagEOS_Lobby_PromoteMemberOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_PromoteMemberOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_PromoteMemberOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_PromoteMemberOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_PromoteMemberOptions),
            "::",
            stringify!(LobbyId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_PromoteMemberOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_PromoteMemberOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Lobby_PromoteMemberOptions = _tagEOS_Lobby_PromoteMemberOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_PromoteMemberCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Lobby_PromoteMember"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The ID of the lobby where the user was promoted"]
    pub LobbyId: EOS_LobbyId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_PromoteMemberCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_PromoteMemberCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_PromoteMemberCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_PromoteMemberCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_PromoteMemberCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_PromoteMemberCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_PromoteMemberCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_PromoteMemberCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_PromoteMemberCallbackInfo),
            "::",
            stringify!(LobbyId)
        )
    );
}
pub type EOS_Lobby_PromoteMemberCallbackInfo = _tagEOS_Lobby_PromoteMemberCallbackInfo;
pub type EOS_Lobby_OnPromoteMemberCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Lobby_PromoteMemberCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_KickMemberOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_KICKMEMBER_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The ID of the lobby"]
    pub LobbyId: EOS_LobbyId,
    #[doc = " The Product User ID of the local user requesting the removal; this user must be the lobby owner"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The Product User ID of the lobby member to remove"]
    pub TargetUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_KickMemberOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_KickMemberOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_KickMemberOptions>(),
        32usize,
        concat!("Size of: ", stringify!(_tagEOS_Lobby_KickMemberOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_KickMemberOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Lobby_KickMemberOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_KickMemberOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_KickMemberOptions),
            "::",
            stringify!(LobbyId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_KickMemberOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_KickMemberOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Lobby_KickMemberOptions = _tagEOS_Lobby_KickMemberOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_KickMemberCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Lobby_KickMember"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The ID of the lobby"]
    pub LobbyId: EOS_LobbyId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_KickMemberCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_KickMemberCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_KickMemberCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_KickMemberCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_KickMemberCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_KickMemberCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_KickMemberCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_KickMemberCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_KickMemberCallbackInfo),
            "::",
            stringify!(LobbyId)
        )
    );
}
pub type EOS_Lobby_KickMemberCallbackInfo = _tagEOS_Lobby_KickMemberCallbackInfo;
pub type EOS_Lobby_OnKickMemberCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Lobby_KickMemberCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_HardMuteMemberOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_HARDMUTEMEMBER_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The ID of the lobby"]
    pub LobbyId: EOS_LobbyId,
    #[doc = " The Product User ID of the local user requesting the hard mute; this user must be the lobby owner"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The Product User ID of the lobby member to hard mute"]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " TargetUserId hard mute status (mute on or off)"]
    pub bHardMute: EOS_Bool,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_HardMuteMemberOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_HardMuteMemberOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_HardMuteMemberOptions>(),
        40usize,
        concat!("Size of: ", stringify!(_tagEOS_Lobby_HardMuteMemberOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_HardMuteMemberOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_HardMuteMemberOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_HardMuteMemberOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_HardMuteMemberOptions),
            "::",
            stringify!(LobbyId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_HardMuteMemberOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_HardMuteMemberOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bHardMute) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_HardMuteMemberOptions),
            "::",
            stringify!(bHardMute)
        )
    );
}
pub type EOS_Lobby_HardMuteMemberOptions = _tagEOS_Lobby_HardMuteMemberOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_HardMuteMemberCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Lobby_HardMuteMember"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The ID of the lobby"]
    pub LobbyId: EOS_LobbyId,
    #[doc = " The Product User ID of the lobby member whose mute status has been updated"]
    pub TargetUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_HardMuteMemberCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_HardMuteMemberCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_HardMuteMemberCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_HardMuteMemberCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_HardMuteMemberCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_HardMuteMemberCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_HardMuteMemberCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_HardMuteMemberCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_HardMuteMemberCallbackInfo),
            "::",
            stringify!(LobbyId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_HardMuteMemberCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Lobby_HardMuteMemberCallbackInfo = _tagEOS_Lobby_HardMuteMemberCallbackInfo;
pub type EOS_Lobby_OnHardMuteMemberCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Lobby_HardMuteMemberCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_AddNotifyLobbyUpdateReceivedOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_ADDNOTIFYLOBBYUPDATERECEIVED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_AddNotifyLobbyUpdateReceivedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_AddNotifyLobbyUpdateReceivedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_AddNotifyLobbyUpdateReceivedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_AddNotifyLobbyUpdateReceivedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_AddNotifyLobbyUpdateReceivedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_AddNotifyLobbyUpdateReceivedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_AddNotifyLobbyUpdateReceivedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Lobby_AddNotifyLobbyUpdateReceivedOptions =
    _tagEOS_Lobby_AddNotifyLobbyUpdateReceivedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_LobbyUpdateReceivedCallbackInfo {
    #[doc = " Context that was passed into EOS_Lobby_AddNotifyLobbyUpdateReceived"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The ID of the lobby"]
    pub LobbyId: EOS_LobbyId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_LobbyUpdateReceivedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_LobbyUpdateReceivedCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_LobbyUpdateReceivedCallbackInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_LobbyUpdateReceivedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_LobbyUpdateReceivedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_LobbyUpdateReceivedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LobbyUpdateReceivedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LobbyUpdateReceivedCallbackInfo),
            "::",
            stringify!(LobbyId)
        )
    );
}
pub type EOS_Lobby_LobbyUpdateReceivedCallbackInfo = _tagEOS_Lobby_LobbyUpdateReceivedCallbackInfo;
pub type EOS_Lobby_OnLobbyUpdateReceivedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Lobby_LobbyUpdateReceivedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_AddNotifyLobbyMemberUpdateReceivedOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_ADDNOTIFYLOBBYMEMBERUPDATERECEIVED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_AddNotifyLobbyMemberUpdateReceivedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_AddNotifyLobbyMemberUpdateReceivedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_AddNotifyLobbyMemberUpdateReceivedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_AddNotifyLobbyMemberUpdateReceivedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_AddNotifyLobbyMemberUpdateReceivedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_AddNotifyLobbyMemberUpdateReceivedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_AddNotifyLobbyMemberUpdateReceivedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Lobby_AddNotifyLobbyMemberUpdateReceivedOptions =
    _tagEOS_Lobby_AddNotifyLobbyMemberUpdateReceivedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_LobbyMemberUpdateReceivedCallbackInfo {
    #[doc = " Context that was passed into EOS_Lobby_AddNotifyLobbyMemberUpdateReceived"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The ID of the lobby"]
    pub LobbyId: EOS_LobbyId,
    #[doc = " The Product User ID of the lobby member"]
    pub TargetUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_LobbyMemberUpdateReceivedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_LobbyMemberUpdateReceivedCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_LobbyMemberUpdateReceivedCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_LobbyMemberUpdateReceivedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_LobbyMemberUpdateReceivedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_LobbyMemberUpdateReceivedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LobbyMemberUpdateReceivedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LobbyMemberUpdateReceivedCallbackInfo),
            "::",
            stringify!(LobbyId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LobbyMemberUpdateReceivedCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Lobby_LobbyMemberUpdateReceivedCallbackInfo =
    _tagEOS_Lobby_LobbyMemberUpdateReceivedCallbackInfo;
pub type EOS_Lobby_OnLobbyMemberUpdateReceivedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Lobby_LobbyMemberUpdateReceivedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_AddNotifyLobbyMemberStatusReceivedOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_ADDNOTIFYLOBBYMEMBERSTATUSRECEIVED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_AddNotifyLobbyMemberStatusReceivedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_AddNotifyLobbyMemberStatusReceivedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_AddNotifyLobbyMemberStatusReceivedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_AddNotifyLobbyMemberStatusReceivedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_AddNotifyLobbyMemberStatusReceivedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_AddNotifyLobbyMemberStatusReceivedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_AddNotifyLobbyMemberStatusReceivedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Lobby_AddNotifyLobbyMemberStatusReceivedOptions =
    _tagEOS_Lobby_AddNotifyLobbyMemberStatusReceivedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_LobbyMemberStatusReceivedCallbackInfo {
    #[doc = " Context that was passed into EOS_Lobby_AddNotifyLobbyMemberStatusReceived"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The ID of the lobby"]
    pub LobbyId: EOS_LobbyId,
    #[doc = " The Product User ID of the lobby member"]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " Latest status of the user"]
    pub CurrentStatus: EOS_ELobbyMemberStatus,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_LobbyMemberStatusReceivedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_LobbyMemberStatusReceivedCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_LobbyMemberStatusReceivedCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_LobbyMemberStatusReceivedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_LobbyMemberStatusReceivedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_LobbyMemberStatusReceivedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LobbyMemberStatusReceivedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LobbyMemberStatusReceivedCallbackInfo),
            "::",
            stringify!(LobbyId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LobbyMemberStatusReceivedCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurrentStatus) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LobbyMemberStatusReceivedCallbackInfo),
            "::",
            stringify!(CurrentStatus)
        )
    );
}
pub type EOS_Lobby_LobbyMemberStatusReceivedCallbackInfo =
    _tagEOS_Lobby_LobbyMemberStatusReceivedCallbackInfo;
pub type EOS_Lobby_OnLobbyMemberStatusReceivedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Lobby_LobbyMemberStatusReceivedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_AddNotifyLobbyInviteReceivedOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_ADDNOTIFYLOBBYINVITERECEIVED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_AddNotifyLobbyInviteReceivedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_AddNotifyLobbyInviteReceivedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_AddNotifyLobbyInviteReceivedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_AddNotifyLobbyInviteReceivedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_AddNotifyLobbyInviteReceivedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_AddNotifyLobbyInviteReceivedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_AddNotifyLobbyInviteReceivedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Lobby_AddNotifyLobbyInviteReceivedOptions =
    _tagEOS_Lobby_AddNotifyLobbyInviteReceivedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_LobbyInviteReceivedCallbackInfo {
    #[doc = " Context that was passed into EOS_Lobby_AddNotifyLobbyInviteReceived"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The ID of the invitation"]
    pub InviteId: *const ::std::os::raw::c_char,
    #[doc = " The Product User ID of the local user who received the invitation"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The Product User ID of the user who sent the invitation"]
    pub TargetUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_LobbyInviteReceivedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_LobbyInviteReceivedCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_LobbyInviteReceivedCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_LobbyInviteReceivedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_LobbyInviteReceivedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_LobbyInviteReceivedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LobbyInviteReceivedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InviteId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LobbyInviteReceivedCallbackInfo),
            "::",
            stringify!(InviteId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LobbyInviteReceivedCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LobbyInviteReceivedCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Lobby_LobbyInviteReceivedCallbackInfo = _tagEOS_Lobby_LobbyInviteReceivedCallbackInfo;
pub type EOS_Lobby_OnLobbyInviteReceivedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Lobby_LobbyInviteReceivedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_AddNotifyLobbyInviteAcceptedOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_ADDNOTIFYLOBBYINVITEACCEPTED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_AddNotifyLobbyInviteAcceptedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_AddNotifyLobbyInviteAcceptedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_AddNotifyLobbyInviteAcceptedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_AddNotifyLobbyInviteAcceptedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_AddNotifyLobbyInviteAcceptedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_AddNotifyLobbyInviteAcceptedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_AddNotifyLobbyInviteAcceptedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Lobby_AddNotifyLobbyInviteAcceptedOptions =
    _tagEOS_Lobby_AddNotifyLobbyInviteAcceptedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_LobbyInviteAcceptedCallbackInfo {
    #[doc = " Context that was passed into EOS_Lobby_AddNotifyLobbyInviteAccepted"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The invite ID"]
    pub InviteId: *const ::std::os::raw::c_char,
    #[doc = " The Product User ID of the local user who received the invitation"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The Product User ID of the user who sent the invitation"]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " Lobby ID that the user has been invited to"]
    pub LobbyId: EOS_LobbyId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_LobbyInviteAcceptedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_LobbyInviteAcceptedCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_LobbyInviteAcceptedCallbackInfo>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_LobbyInviteAcceptedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_LobbyInviteAcceptedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_LobbyInviteAcceptedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LobbyInviteAcceptedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InviteId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LobbyInviteAcceptedCallbackInfo),
            "::",
            stringify!(InviteId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LobbyInviteAcceptedCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LobbyInviteAcceptedCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LobbyInviteAcceptedCallbackInfo),
            "::",
            stringify!(LobbyId)
        )
    );
}
pub type EOS_Lobby_LobbyInviteAcceptedCallbackInfo = _tagEOS_Lobby_LobbyInviteAcceptedCallbackInfo;
pub type EOS_Lobby_OnLobbyInviteAcceptedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Lobby_LobbyInviteAcceptedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_AddNotifyJoinLobbyAcceptedOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_ADDNOTIFYJOINLOBBYACCEPTED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_AddNotifyJoinLobbyAcceptedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_AddNotifyJoinLobbyAcceptedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_AddNotifyJoinLobbyAcceptedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_AddNotifyJoinLobbyAcceptedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_AddNotifyJoinLobbyAcceptedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_AddNotifyJoinLobbyAcceptedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_AddNotifyJoinLobbyAcceptedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Lobby_AddNotifyJoinLobbyAcceptedOptions =
    _tagEOS_Lobby_AddNotifyJoinLobbyAcceptedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_AddNotifyLobbyInviteRejectedOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_ADDNOTIFYLOBBYINVITEREJECTED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_AddNotifyLobbyInviteRejectedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_AddNotifyLobbyInviteRejectedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_AddNotifyLobbyInviteRejectedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_AddNotifyLobbyInviteRejectedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_AddNotifyLobbyInviteRejectedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_AddNotifyLobbyInviteRejectedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_AddNotifyLobbyInviteRejectedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Lobby_AddNotifyLobbyInviteRejectedOptions =
    _tagEOS_Lobby_AddNotifyLobbyInviteRejectedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_LobbyInviteRejectedCallbackInfo {
    #[doc = " Context that was passed into EOS_Lobby_AddNotifyLobbyInviteRejected"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The invite ID"]
    pub InviteId: *const ::std::os::raw::c_char,
    #[doc = " The Product User ID of the local user who received the invitation"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The Product User ID of the user who sent the invitation"]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " Lobby ID that the user has been invited to"]
    pub LobbyId: EOS_LobbyId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_LobbyInviteRejectedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_LobbyInviteRejectedCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_LobbyInviteRejectedCallbackInfo>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_LobbyInviteRejectedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_LobbyInviteRejectedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_LobbyInviteRejectedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LobbyInviteRejectedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InviteId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LobbyInviteRejectedCallbackInfo),
            "::",
            stringify!(InviteId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LobbyInviteRejectedCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LobbyInviteRejectedCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LobbyInviteRejectedCallbackInfo),
            "::",
            stringify!(LobbyId)
        )
    );
}
pub type EOS_Lobby_LobbyInviteRejectedCallbackInfo = _tagEOS_Lobby_LobbyInviteRejectedCallbackInfo;
pub type EOS_Lobby_OnLobbyInviteRejectedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Lobby_LobbyInviteRejectedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_JoinLobbyAcceptedCallbackInfo {
    #[doc = " Context that was passed into EOS_Lobby_AddNotifyJoinLobbyAccepted"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the local user who is joining"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The UI Event associated with this Join Game event.\n This should be used with EOS_Lobby_CopyLobbyDetailsHandleByUiEventId to get a handle to be used\n when calling EOS_Lobby_JoinLobby."]
    pub UiEventId: EOS_UI_EventId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_JoinLobbyAcceptedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_JoinLobbyAcceptedCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_JoinLobbyAcceptedCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_JoinLobbyAcceptedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_JoinLobbyAcceptedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_JoinLobbyAcceptedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_JoinLobbyAcceptedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_JoinLobbyAcceptedCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UiEventId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_JoinLobbyAcceptedCallbackInfo),
            "::",
            stringify!(UiEventId)
        )
    );
}
pub type EOS_Lobby_JoinLobbyAcceptedCallbackInfo = _tagEOS_Lobby_JoinLobbyAcceptedCallbackInfo;
pub type EOS_Lobby_OnJoinLobbyAcceptedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Lobby_JoinLobbyAcceptedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_AddNotifySendLobbyNativeInviteRequestedOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_ADDNOTIFYSENDLOBBYNATIVEINVITEREQUESTED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_AddNotifySendLobbyNativeInviteRequestedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Lobby_AddNotifySendLobbyNativeInviteRequestedOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_AddNotifySendLobbyNativeInviteRequestedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_AddNotifySendLobbyNativeInviteRequestedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_AddNotifySendLobbyNativeInviteRequestedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_AddNotifySendLobbyNativeInviteRequestedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_AddNotifySendLobbyNativeInviteRequestedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Lobby_AddNotifySendLobbyNativeInviteRequestedOptions =
    _tagEOS_Lobby_AddNotifySendLobbyNativeInviteRequestedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_SendLobbyNativeInviteRequestedCallbackInfo {
    #[doc = " Context that was passed into EOS_Lobby_AddNotifySendLobbyNativeInviteRequested"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Identifies this event which will need to be acknowledged with EOS_UI_AcknowledgeEventId().\n @see EOS_UI_AcknowledgeEventId"]
    pub UiEventId: EOS_UI_EventId,
    #[doc = " The Product User ID of the local user who is inviting."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The Native Platform Account Type. If only a single integrated platform is configured then\n this will always reference that platform."]
    pub TargetNativeAccountType: EOS_IntegratedPlatformType,
    #[doc = " The Native Platform Account ID of the target user being invited."]
    pub TargetUserNativeAccountId: *const ::std::os::raw::c_char,
    #[doc = " Lobby ID that the user is being invited to"]
    pub LobbyId: EOS_LobbyId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_SendLobbyNativeInviteRequestedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Lobby_SendLobbyNativeInviteRequestedCallbackInfo,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_SendLobbyNativeInviteRequestedCallbackInfo>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_SendLobbyNativeInviteRequestedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_SendLobbyNativeInviteRequestedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_SendLobbyNativeInviteRequestedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_SendLobbyNativeInviteRequestedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UiEventId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_SendLobbyNativeInviteRequestedCallbackInfo),
            "::",
            stringify!(UiEventId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_SendLobbyNativeInviteRequestedCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetNativeAccountType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_SendLobbyNativeInviteRequestedCallbackInfo),
            "::",
            stringify!(TargetNativeAccountType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserNativeAccountId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_SendLobbyNativeInviteRequestedCallbackInfo),
            "::",
            stringify!(TargetUserNativeAccountId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_SendLobbyNativeInviteRequestedCallbackInfo),
            "::",
            stringify!(LobbyId)
        )
    );
}
pub type EOS_Lobby_SendLobbyNativeInviteRequestedCallbackInfo =
    _tagEOS_Lobby_SendLobbyNativeInviteRequestedCallbackInfo;
pub type EOS_Lobby_OnSendLobbyNativeInviteRequestedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Lobby_SendLobbyNativeInviteRequestedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_CopyLobbyDetailsHandleByInviteIdOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_COPYLOBBYDETAILSHANDLEBYINVITEID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The ID of an invitation to join the lobby"]
    pub InviteId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_CopyLobbyDetailsHandleByInviteIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_CopyLobbyDetailsHandleByInviteIdOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_CopyLobbyDetailsHandleByInviteIdOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_CopyLobbyDetailsHandleByInviteIdOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_CopyLobbyDetailsHandleByInviteIdOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_CopyLobbyDetailsHandleByInviteIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CopyLobbyDetailsHandleByInviteIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InviteId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CopyLobbyDetailsHandleByInviteIdOptions),
            "::",
            stringify!(InviteId)
        )
    );
}
pub type EOS_Lobby_CopyLobbyDetailsHandleByInviteIdOptions =
    _tagEOS_Lobby_CopyLobbyDetailsHandleByInviteIdOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_CopyLobbyDetailsHandleByUiEventIdOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_COPYLOBBYDETAILSHANDLEBYUIEVENTID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " UI Event associated with the lobby"]
    pub UiEventId: EOS_UI_EventId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_CopyLobbyDetailsHandleByUiEventIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_CopyLobbyDetailsHandleByUiEventIdOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_CopyLobbyDetailsHandleByUiEventIdOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_CopyLobbyDetailsHandleByUiEventIdOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_CopyLobbyDetailsHandleByUiEventIdOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_CopyLobbyDetailsHandleByUiEventIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CopyLobbyDetailsHandleByUiEventIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UiEventId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CopyLobbyDetailsHandleByUiEventIdOptions),
            "::",
            stringify!(UiEventId)
        )
    );
}
pub type EOS_Lobby_CopyLobbyDetailsHandleByUiEventIdOptions =
    _tagEOS_Lobby_CopyLobbyDetailsHandleByUiEventIdOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_CreateLobbySearchOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_CREATELOBBYSEARCH_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Maximum number of results allowed from the search"]
    pub MaxResults: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_CreateLobbySearchOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_CreateLobbySearchOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_CreateLobbySearchOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_CreateLobbySearchOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_CreateLobbySearchOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_CreateLobbySearchOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CreateLobbySearchOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxResults) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CreateLobbySearchOptions),
            "::",
            stringify!(MaxResults)
        )
    );
}
pub type EOS_Lobby_CreateLobbySearchOptions = _tagEOS_Lobby_CreateLobbySearchOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_SendInviteOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_SENDINVITE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The ID of the lobby associated with the invitation"]
    pub LobbyId: EOS_LobbyId,
    #[doc = " The Product User ID of the local user sending the invitation"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The Product User ID of the user receiving the invitation"]
    pub TargetUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_SendInviteOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_SendInviteOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_SendInviteOptions>(),
        32usize,
        concat!("Size of: ", stringify!(_tagEOS_Lobby_SendInviteOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_SendInviteOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Lobby_SendInviteOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_SendInviteOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_SendInviteOptions),
            "::",
            stringify!(LobbyId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_SendInviteOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_SendInviteOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Lobby_SendInviteOptions = _tagEOS_Lobby_SendInviteOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_SendInviteCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Lobby_SendInvite"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The ID of the lobby"]
    pub LobbyId: EOS_LobbyId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_SendInviteCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_SendInviteCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_SendInviteCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_SendInviteCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_SendInviteCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_SendInviteCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_SendInviteCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_SendInviteCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_SendInviteCallbackInfo),
            "::",
            stringify!(LobbyId)
        )
    );
}
pub type EOS_Lobby_SendInviteCallbackInfo = _tagEOS_Lobby_SendInviteCallbackInfo;
pub type EOS_Lobby_OnSendInviteCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Lobby_SendInviteCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_RejectInviteOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_REJECTINVITE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The ID of the lobby associated with the invitation"]
    pub InviteId: *const ::std::os::raw::c_char,
    #[doc = " The Product User ID of the local user who is rejecting the invitation"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_RejectInviteOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_RejectInviteOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_RejectInviteOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Lobby_RejectInviteOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_RejectInviteOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_RejectInviteOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_RejectInviteOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InviteId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_RejectInviteOptions),
            "::",
            stringify!(InviteId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_RejectInviteOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Lobby_RejectInviteOptions = _tagEOS_Lobby_RejectInviteOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_RejectInviteCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Lobby_RejectInvite"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The ID of the invitation being rejected"]
    pub InviteId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_RejectInviteCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_RejectInviteCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_RejectInviteCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_RejectInviteCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_RejectInviteCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_RejectInviteCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_RejectInviteCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_RejectInviteCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InviteId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_RejectInviteCallbackInfo),
            "::",
            stringify!(InviteId)
        )
    );
}
pub type EOS_Lobby_RejectInviteCallbackInfo = _tagEOS_Lobby_RejectInviteCallbackInfo;
pub type EOS_Lobby_OnRejectInviteCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Lobby_RejectInviteCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_QueryInvitesOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_QUERYINVITES_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user whose invitations you want to retrieve"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_QueryInvitesOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_QueryInvitesOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_QueryInvitesOptions>(),
        16usize,
        concat!("Size of: ", stringify!(_tagEOS_Lobby_QueryInvitesOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_QueryInvitesOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_QueryInvitesOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_QueryInvitesOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_QueryInvitesOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Lobby_QueryInvitesOptions = _tagEOS_Lobby_QueryInvitesOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_QueryInvitesCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Lobby_QueryInvites"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the local user that made the request"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_QueryInvitesCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_QueryInvitesCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_QueryInvitesCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_QueryInvitesCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_QueryInvitesCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_QueryInvitesCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_QueryInvitesCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_QueryInvitesCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_QueryInvitesCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Lobby_QueryInvitesCallbackInfo = _tagEOS_Lobby_QueryInvitesCallbackInfo;
pub type EOS_Lobby_OnQueryInvitesCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Lobby_QueryInvitesCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_GetInviteCountOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_GETINVITECOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user whose cached lobby invitations you want to count"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_GetInviteCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_GetInviteCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_GetInviteCountOptions>(),
        16usize,
        concat!("Size of: ", stringify!(_tagEOS_Lobby_GetInviteCountOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_GetInviteCountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_GetInviteCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_GetInviteCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_GetInviteCountOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Lobby_GetInviteCountOptions = _tagEOS_Lobby_GetInviteCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_GetInviteIdByIndexOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_GETINVITEIDBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user who received the cached invitation"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The index of the invitation ID to retrieve"]
    pub Index: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_GetInviteIdByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_GetInviteIdByIndexOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_GetInviteIdByIndexOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_GetInviteIdByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_GetInviteIdByIndexOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_GetInviteIdByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_GetInviteIdByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_GetInviteIdByIndexOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Index) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_GetInviteIdByIndexOptions),
            "::",
            stringify!(Index)
        )
    );
}
pub type EOS_Lobby_GetInviteIdByIndexOptions = _tagEOS_Lobby_GetInviteIdByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_CopyLobbyDetailsHandleOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_COPYLOBBYDETAILSHANDLE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The ID of the lobby"]
    pub LobbyId: EOS_LobbyId,
    #[doc = " The Product User ID of the local user making the request"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_CopyLobbyDetailsHandleOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_CopyLobbyDetailsHandleOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_CopyLobbyDetailsHandleOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_CopyLobbyDetailsHandleOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_CopyLobbyDetailsHandleOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_CopyLobbyDetailsHandleOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CopyLobbyDetailsHandleOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CopyLobbyDetailsHandleOptions),
            "::",
            stringify!(LobbyId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_CopyLobbyDetailsHandleOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Lobby_CopyLobbyDetailsHandleOptions = _tagEOS_Lobby_CopyLobbyDetailsHandleOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_GetRTCRoomNameOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_GETRTCROOMNAME_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The ID of the lobby to get the RTC Room name for"]
    pub LobbyId: EOS_LobbyId,
    #[doc = " The Product User ID of the local user in the lobby"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_GetRTCRoomNameOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_GetRTCRoomNameOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_GetRTCRoomNameOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Lobby_GetRTCRoomNameOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_GetRTCRoomNameOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_GetRTCRoomNameOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_GetRTCRoomNameOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_GetRTCRoomNameOptions),
            "::",
            stringify!(LobbyId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_GetRTCRoomNameOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Lobby_GetRTCRoomNameOptions = _tagEOS_Lobby_GetRTCRoomNameOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_IsRTCRoomConnectedOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_ISRTCROOMCONNECTED_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The ID of the lobby to get the RTC Room name for"]
    pub LobbyId: EOS_LobbyId,
    #[doc = " The Product User ID of the local user in the lobby"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_IsRTCRoomConnectedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_IsRTCRoomConnectedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_IsRTCRoomConnectedOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_IsRTCRoomConnectedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_IsRTCRoomConnectedOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_IsRTCRoomConnectedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_IsRTCRoomConnectedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_IsRTCRoomConnectedOptions),
            "::",
            stringify!(LobbyId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_IsRTCRoomConnectedOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Lobby_IsRTCRoomConnectedOptions = _tagEOS_Lobby_IsRTCRoomConnectedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_AddNotifyRTCRoomConnectionChangedOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_ADDNOTIFYRTCROOMCONNECTIONCHANGED_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The ID of the lobby to receive RTC Room connection change notifications for\n This is deprecated and no longer needed. The notification is raised for any LobbyId or LocalUserId. If any filtering is required, the callback struct (EOS_Lobby_RTCRoomConnectionChangedCallbackInfo) has both a LobbyId and LocalUserId field."]
    pub LobbyId_DEPRECATED: EOS_LobbyId,
    #[doc = " The Product User ID of the local user in the lobby\n This is deprecated and no longer needed. The notification is raised for any LobbyId or LocalUserId. If any filtering is required, the callback struct (EOS_Lobby_RTCRoomConnectionChangedCallbackInfo) has both a LobbyId and LocalUserId field."]
    pub LocalUserId_DEPRECATED: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_AddNotifyRTCRoomConnectionChangedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_AddNotifyRTCRoomConnectionChangedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_AddNotifyRTCRoomConnectionChangedOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_AddNotifyRTCRoomConnectionChangedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_AddNotifyRTCRoomConnectionChangedOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_AddNotifyRTCRoomConnectionChangedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_AddNotifyRTCRoomConnectionChangedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId_DEPRECATED) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_AddNotifyRTCRoomConnectionChangedOptions),
            "::",
            stringify!(LobbyId_DEPRECATED)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId_DEPRECATED) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_AddNotifyRTCRoomConnectionChangedOptions),
            "::",
            stringify!(LocalUserId_DEPRECATED)
        )
    );
}
pub type EOS_Lobby_AddNotifyRTCRoomConnectionChangedOptions =
    _tagEOS_Lobby_AddNotifyRTCRoomConnectionChangedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_RTCRoomConnectionChangedCallbackInfo {
    #[doc = " Context that was passed into EOS_Lobby_AddNotifyRTCRoomConnectionChanged"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The ID of the lobby which had a RTC Room connection state change"]
    pub LobbyId: EOS_LobbyId,
    #[doc = " The Product User ID of the local user who is in the lobby and registered for notifications"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The new connection state of the room"]
    pub bIsConnected: EOS_Bool,
    #[doc = "If bIsConnected is EOS_FALSE, this result will be the reason we were disconnected.\n EOS_Success: The room was left locally. This may be because: the associated lobby was Left or Destroyed, the connection to the lobby was interrupted, or because the SDK is being shutdown. If the lobby connection returns (lobby did not permanently go away), we will reconnect.\n EOS_NoConnection: There was a network issue connecting to the server. We will attempt to reconnect soon.\n EOS_RTC_UserKicked: The user has been kicked by the server. We will not reconnect.\n EOS_RTC_UserBanned: The user has been banned by the server. We will not reconnect.\n EOS_ServiceFailure: A known error occurred during interaction with the server. We will attempt to reconnect soon.\n EOS_UnexpectedError: Unexpected error. We will attempt to reconnect soon."]
    pub DisconnectReason: EOS_EResult,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_RTCRoomConnectionChangedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_RTCRoomConnectionChangedCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_RTCRoomConnectionChangedCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_RTCRoomConnectionChangedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_RTCRoomConnectionChangedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_RTCRoomConnectionChangedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_RTCRoomConnectionChangedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_RTCRoomConnectionChangedCallbackInfo),
            "::",
            stringify!(LobbyId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_RTCRoomConnectionChangedCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsConnected) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_RTCRoomConnectionChangedCallbackInfo),
            "::",
            stringify!(bIsConnected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisconnectReason) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_RTCRoomConnectionChangedCallbackInfo),
            "::",
            stringify!(DisconnectReason)
        )
    );
}
pub type EOS_Lobby_RTCRoomConnectionChangedCallbackInfo =
    _tagEOS_Lobby_RTCRoomConnectionChangedCallbackInfo;
pub type EOS_Lobby_OnRTCRoomConnectionChangedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Lobby_RTCRoomConnectionChangedCallbackInfo),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _tagEOS_Lobby_AttributeData {
    #[doc = " API Version: Set this to EOS_LOBBY_ATTRIBUTEDATA_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Name of the lobby attribute"]
    pub Key: *const ::std::os::raw::c_char,
    pub Value: _tagEOS_Lobby_AttributeData__bindgen_ty_1,
    #[doc = " Type of value stored in the union"]
    pub ValueType: EOS_ELobbyAttributeType,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _tagEOS_Lobby_AttributeData__bindgen_ty_1 {
    #[doc = " Stored as an 8 byte integer"]
    pub AsInt64: i64,
    #[doc = " Stored as a double precision floating point"]
    pub AsDouble: f64,
    #[doc = " Stored as a boolean"]
    pub AsBool: EOS_Bool,
    #[doc = " Stored as a null terminated UTF8 string. Should not be nullptr"]
    pub AsUtf8: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_AttributeData__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_AttributeData__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_AttributeData__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_AttributeData__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_AttributeData__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_AttributeData__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AsInt64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_AttributeData__bindgen_ty_1),
            "::",
            stringify!(AsInt64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AsDouble) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_AttributeData__bindgen_ty_1),
            "::",
            stringify!(AsDouble)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AsBool) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_AttributeData__bindgen_ty_1),
            "::",
            stringify!(AsBool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AsUtf8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_AttributeData__bindgen_ty_1),
            "::",
            stringify!(AsUtf8)
        )
    );
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_AttributeData() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_AttributeData> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_AttributeData>(),
        32usize,
        concat!("Size of: ", stringify!(_tagEOS_Lobby_AttributeData))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_AttributeData>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Lobby_AttributeData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_AttributeData),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_AttributeData),
            "::",
            stringify!(Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_AttributeData),
            "::",
            stringify!(Value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ValueType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_AttributeData),
            "::",
            stringify!(ValueType)
        )
    );
}
pub type EOS_Lobby_AttributeData = _tagEOS_Lobby_AttributeData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_Attribute {
    #[doc = " API Version: Set this to EOS_LOBBY_ATTRIBUTE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Key/Value pair describing the attribute"]
    pub Data: *mut EOS_Lobby_AttributeData,
    #[doc = " Is this attribute public or private to the lobby and its members"]
    pub Visibility: EOS_ELobbyAttributeVisibility,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_Attribute() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_Attribute> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_Attribute>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Lobby_Attribute))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_Attribute>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Lobby_Attribute))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_Attribute),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_Attribute),
            "::",
            stringify!(Data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Visibility) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_Attribute),
            "::",
            stringify!(Visibility)
        )
    );
}
pub type EOS_Lobby_Attribute = _tagEOS_Lobby_Attribute;
extern "C" {
    pub fn EOS_Lobby_Attribute_Release(LobbyAttribute: *mut EOS_Lobby_Attribute);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_GetConnectStringOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_GETCONNECTSTRING_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user requesting the connection string generated from the lobby; this user must currently own the lobby"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The ID of the lobby to generate a connection string for"]
    pub LobbyId: EOS_LobbyId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_GetConnectStringOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_GetConnectStringOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_GetConnectStringOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_GetConnectStringOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_GetConnectStringOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_GetConnectStringOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_GetConnectStringOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_GetConnectStringOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_GetConnectStringOptions),
            "::",
            stringify!(LobbyId)
        )
    );
}
pub type EOS_Lobby_GetConnectStringOptions = _tagEOS_Lobby_GetConnectStringOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_ParseConnectStringOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_PARSECONNECTSTRING_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The connection string to parse"]
    pub ConnectString: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_ParseConnectStringOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_ParseConnectStringOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_ParseConnectStringOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_ParseConnectStringOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_ParseConnectStringOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_ParseConnectStringOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_ParseConnectStringOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectString) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_ParseConnectStringOptions),
            "::",
            stringify!(ConnectString)
        )
    );
}
pub type EOS_Lobby_ParseConnectStringOptions = _tagEOS_Lobby_ParseConnectStringOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbyModification_SetBucketIdOptions {
    #[doc = " API Version: Set this to EOS_LOBBYMODIFICATION_SETBUCKETID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The new bucket id associated with the lobby"]
    pub BucketId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbyModification_SetBucketIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbyModification_SetBucketIdOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbyModification_SetBucketIdOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbyModification_SetBucketIdOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbyModification_SetBucketIdOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbyModification_SetBucketIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyModification_SetBucketIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BucketId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyModification_SetBucketIdOptions),
            "::",
            stringify!(BucketId)
        )
    );
}
pub type EOS_LobbyModification_SetBucketIdOptions = _tagEOS_LobbyModification_SetBucketIdOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbyModification_SetPermissionLevelOptions {
    #[doc = " API Version: Set this to EOS_LOBBYMODIFICATION_SETPERMISSIONLEVEL_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Permission level of the lobby"]
    pub PermissionLevel: EOS_ELobbyPermissionLevel,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbyModification_SetPermissionLevelOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbyModification_SetPermissionLevelOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbyModification_SetPermissionLevelOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbyModification_SetPermissionLevelOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbyModification_SetPermissionLevelOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbyModification_SetPermissionLevelOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyModification_SetPermissionLevelOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PermissionLevel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyModification_SetPermissionLevelOptions),
            "::",
            stringify!(PermissionLevel)
        )
    );
}
pub type EOS_LobbyModification_SetPermissionLevelOptions =
    _tagEOS_LobbyModification_SetPermissionLevelOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbyModification_SetMaxMembersOptions {
    #[doc = " API Version: Set this to EOS_LOBBYMODIFICATION_SETMAXMEMBERS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " New maximum number of lobby members"]
    pub MaxMembers: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbyModification_SetMaxMembersOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbyModification_SetMaxMembersOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbyModification_SetMaxMembersOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbyModification_SetMaxMembersOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbyModification_SetMaxMembersOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbyModification_SetMaxMembersOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyModification_SetMaxMembersOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxMembers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyModification_SetMaxMembersOptions),
            "::",
            stringify!(MaxMembers)
        )
    );
}
pub type EOS_LobbyModification_SetMaxMembersOptions =
    _tagEOS_LobbyModification_SetMaxMembersOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbyModification_SetInvitesAllowedOptions {
    #[doc = " API Version: Set this to EOS_LOBBYMODIFICATION_SETINVITESALLOWED_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " If true then invites can currently be sent for the associated lobby"]
    pub bInvitesAllowed: EOS_Bool,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbyModification_SetInvitesAllowedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbyModification_SetInvitesAllowedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbyModification_SetInvitesAllowedOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbyModification_SetInvitesAllowedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbyModification_SetInvitesAllowedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbyModification_SetInvitesAllowedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyModification_SetInvitesAllowedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bInvitesAllowed) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyModification_SetInvitesAllowedOptions),
            "::",
            stringify!(bInvitesAllowed)
        )
    );
}
pub type EOS_LobbyModification_SetInvitesAllowedOptions =
    _tagEOS_LobbyModification_SetInvitesAllowedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbyModification_AddAttributeOptions {
    #[doc = " API Version: Set this to EOS_LOBBYMODIFICATION_ADDATTRIBUTE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Key/Value pair describing the attribute to add to the lobby"]
    pub Attribute: *const EOS_Lobby_AttributeData,
    #[doc = " Is this attribute public or private to the lobby and its members"]
    pub Visibility: EOS_ELobbyAttributeVisibility,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbyModification_AddAttributeOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbyModification_AddAttributeOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbyModification_AddAttributeOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbyModification_AddAttributeOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbyModification_AddAttributeOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbyModification_AddAttributeOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyModification_AddAttributeOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Attribute) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyModification_AddAttributeOptions),
            "::",
            stringify!(Attribute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Visibility) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyModification_AddAttributeOptions),
            "::",
            stringify!(Visibility)
        )
    );
}
pub type EOS_LobbyModification_AddAttributeOptions = _tagEOS_LobbyModification_AddAttributeOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbyModification_RemoveAttributeOptions {
    #[doc = " API Version: Set this to EOS_LOBBYMODIFICATION_REMOVEATTRIBUTE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Name of the key"]
    pub Key: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbyModification_RemoveAttributeOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbyModification_RemoveAttributeOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbyModification_RemoveAttributeOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbyModification_RemoveAttributeOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbyModification_RemoveAttributeOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbyModification_RemoveAttributeOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyModification_RemoveAttributeOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyModification_RemoveAttributeOptions),
            "::",
            stringify!(Key)
        )
    );
}
pub type EOS_LobbyModification_RemoveAttributeOptions =
    _tagEOS_LobbyModification_RemoveAttributeOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbyModification_AddMemberAttributeOptions {
    #[doc = " API Version: Set this to EOS_LOBBYMODIFICATION_ADDMEMBERATTRIBUTE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Key/Value pair describing the attribute to add to the lobby member"]
    pub Attribute: *const EOS_Lobby_AttributeData,
    #[doc = " Is this attribute public or private to the rest of the lobby members"]
    pub Visibility: EOS_ELobbyAttributeVisibility,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbyModification_AddMemberAttributeOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbyModification_AddMemberAttributeOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbyModification_AddMemberAttributeOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbyModification_AddMemberAttributeOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbyModification_AddMemberAttributeOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbyModification_AddMemberAttributeOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyModification_AddMemberAttributeOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Attribute) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyModification_AddMemberAttributeOptions),
            "::",
            stringify!(Attribute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Visibility) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyModification_AddMemberAttributeOptions),
            "::",
            stringify!(Visibility)
        )
    );
}
pub type EOS_LobbyModification_AddMemberAttributeOptions =
    _tagEOS_LobbyModification_AddMemberAttributeOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbyModification_RemoveMemberAttributeOptions {
    #[doc = " API Version: Set this to EOS_LOBBYMODIFICATION_REMOVEMEMBERATTRIBUTE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Name of the key"]
    pub Key: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbyModification_RemoveMemberAttributeOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbyModification_RemoveMemberAttributeOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbyModification_RemoveMemberAttributeOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbyModification_RemoveMemberAttributeOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbyModification_RemoveMemberAttributeOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbyModification_RemoveMemberAttributeOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyModification_RemoveMemberAttributeOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyModification_RemoveMemberAttributeOptions),
            "::",
            stringify!(Key)
        )
    );
}
pub type EOS_LobbyModification_RemoveMemberAttributeOptions =
    _tagEOS_LobbyModification_RemoveMemberAttributeOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbyModification_SetAllowedPlatformIdsOptions {
    #[doc = " API Version: Set this to EOS_LOBBYMODIFICATION_SETALLOWEDPLATFORMIDS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Array of platform IDs indicating the player platforms allowed to register with the session. Platform IDs are\n found in the EOS header file, e.g. EOS_OPT_Epic. For some platforms, the value will be in the EOS Platform specific\n header file. If null, the lobby will be unrestricted."]
    pub AllowedPlatformIds: *const u32,
    #[doc = " Number of platform IDs in the array"]
    pub AllowedPlatformIdsCount: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbyModification_SetAllowedPlatformIdsOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbyModification_SetAllowedPlatformIdsOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbyModification_SetAllowedPlatformIdsOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbyModification_SetAllowedPlatformIdsOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbyModification_SetAllowedPlatformIdsOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbyModification_SetAllowedPlatformIdsOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyModification_SetAllowedPlatformIdsOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllowedPlatformIds) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyModification_SetAllowedPlatformIdsOptions),
            "::",
            stringify!(AllowedPlatformIds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllowedPlatformIdsCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyModification_SetAllowedPlatformIdsOptions),
            "::",
            stringify!(AllowedPlatformIdsCount)
        )
    );
}
pub type EOS_LobbyModification_SetAllowedPlatformIdsOptions =
    _tagEOS_LobbyModification_SetAllowedPlatformIdsOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbyDetails_GetLobbyOwnerOptions {
    #[doc = " API Version: Set this to EOS_LOBBYDETAILS_GETLOBBYOWNER_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbyDetails_GetLobbyOwnerOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbyDetails_GetLobbyOwnerOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbyDetails_GetLobbyOwnerOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbyDetails_GetLobbyOwnerOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbyDetails_GetLobbyOwnerOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbyDetails_GetLobbyOwnerOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_GetLobbyOwnerOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_LobbyDetails_GetLobbyOwnerOptions = _tagEOS_LobbyDetails_GetLobbyOwnerOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbyDetails_CopyInfoOptions {
    #[doc = " API Version: Set this to EOS_LOBBYDETAILS_COPYINFO_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbyDetails_CopyInfoOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbyDetails_CopyInfoOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbyDetails_CopyInfoOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbyDetails_CopyInfoOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbyDetails_CopyInfoOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbyDetails_CopyInfoOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_CopyInfoOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_LobbyDetails_CopyInfoOptions = _tagEOS_LobbyDetails_CopyInfoOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbyDetails_GetAttributeCountOptions {
    #[doc = " API Version: Set this to EOS_LOBBYDETAILS_GETATTRIBUTECOUNT_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbyDetails_GetAttributeCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbyDetails_GetAttributeCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbyDetails_GetAttributeCountOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbyDetails_GetAttributeCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbyDetails_GetAttributeCountOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbyDetails_GetAttributeCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_GetAttributeCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_LobbyDetails_GetAttributeCountOptions = _tagEOS_LobbyDetails_GetAttributeCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbyDetails_CopyAttributeByIndexOptions {
    #[doc = " API Version: Set this to EOS_LOBBYDETAILS_COPYATTRIBUTEBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The index of the attribute to retrieve\n @see EOS_LobbyDetails_GetAttributeCount"]
    pub AttrIndex: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbyDetails_CopyAttributeByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbyDetails_CopyAttributeByIndexOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbyDetails_CopyAttributeByIndexOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbyDetails_CopyAttributeByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbyDetails_CopyAttributeByIndexOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbyDetails_CopyAttributeByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_CopyAttributeByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AttrIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_CopyAttributeByIndexOptions),
            "::",
            stringify!(AttrIndex)
        )
    );
}
pub type EOS_LobbyDetails_CopyAttributeByIndexOptions =
    _tagEOS_LobbyDetails_CopyAttributeByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbyDetails_CopyAttributeByKeyOptions {
    #[doc = " API Version: Set this to EOS_LOBBYDETAILS_COPYATTRIBUTEBYKEY_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Name of the attribute"]
    pub AttrKey: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbyDetails_CopyAttributeByKeyOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbyDetails_CopyAttributeByKeyOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbyDetails_CopyAttributeByKeyOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbyDetails_CopyAttributeByKeyOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbyDetails_CopyAttributeByKeyOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbyDetails_CopyAttributeByKeyOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_CopyAttributeByKeyOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AttrKey) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_CopyAttributeByKeyOptions),
            "::",
            stringify!(AttrKey)
        )
    );
}
pub type EOS_LobbyDetails_CopyAttributeByKeyOptions =
    _tagEOS_LobbyDetails_CopyAttributeByKeyOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbyDetails_GetMemberAttributeCountOptions {
    #[doc = " API Version: Set this to EOS_LOBBYDETAILS_GETMEMBERATTRIBUTECOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the lobby member"]
    pub TargetUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbyDetails_GetMemberAttributeCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbyDetails_GetMemberAttributeCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbyDetails_GetMemberAttributeCountOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbyDetails_GetMemberAttributeCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbyDetails_GetMemberAttributeCountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbyDetails_GetMemberAttributeCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_GetMemberAttributeCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_GetMemberAttributeCountOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_LobbyDetails_GetMemberAttributeCountOptions =
    _tagEOS_LobbyDetails_GetMemberAttributeCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbyDetails_CopyMemberAttributeByIndexOptions {
    #[doc = " API Version: Set this to EOS_LOBBYDETAILS_COPYMEMBERATTRIBUTEBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the lobby member"]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " The index of the attribute to copy"]
    pub AttrIndex: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbyDetails_CopyMemberAttributeByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbyDetails_CopyMemberAttributeByIndexOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbyDetails_CopyMemberAttributeByIndexOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbyDetails_CopyMemberAttributeByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbyDetails_CopyMemberAttributeByIndexOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbyDetails_CopyMemberAttributeByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_CopyMemberAttributeByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_CopyMemberAttributeByIndexOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AttrIndex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_CopyMemberAttributeByIndexOptions),
            "::",
            stringify!(AttrIndex)
        )
    );
}
pub type EOS_LobbyDetails_CopyMemberAttributeByIndexOptions =
    _tagEOS_LobbyDetails_CopyMemberAttributeByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbyDetails_CopyMemberAttributeByKeyOptions {
    #[doc = " API Version: Set this to EOS_LOBBYDETAILS_COPYMEMBERATTRIBUTEBYKEY_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the lobby member"]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " Name of the attribute to copy"]
    pub AttrKey: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbyDetails_CopyMemberAttributeByKeyOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbyDetails_CopyMemberAttributeByKeyOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbyDetails_CopyMemberAttributeByKeyOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbyDetails_CopyMemberAttributeByKeyOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbyDetails_CopyMemberAttributeByKeyOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbyDetails_CopyMemberAttributeByKeyOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_CopyMemberAttributeByKeyOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_CopyMemberAttributeByKeyOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AttrKey) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_CopyMemberAttributeByKeyOptions),
            "::",
            stringify!(AttrKey)
        )
    );
}
pub type EOS_LobbyDetails_CopyMemberAttributeByKeyOptions =
    _tagEOS_LobbyDetails_CopyMemberAttributeByKeyOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbyDetails_GetMemberCountOptions {
    #[doc = " API Version: Set this to EOS_LOBBYDETAILS_GETMEMBERCOUNT_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbyDetails_GetMemberCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbyDetails_GetMemberCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbyDetails_GetMemberCountOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbyDetails_GetMemberCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbyDetails_GetMemberCountOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbyDetails_GetMemberCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_GetMemberCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_LobbyDetails_GetMemberCountOptions = _tagEOS_LobbyDetails_GetMemberCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbyDetails_GetMemberByIndexOptions {
    #[doc = " API Version: Set this to EOS_LOBBYDETAILS_GETMEMBERBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Index of the member to retrieve"]
    pub MemberIndex: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbyDetails_GetMemberByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbyDetails_GetMemberByIndexOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbyDetails_GetMemberByIndexOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbyDetails_GetMemberByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbyDetails_GetMemberByIndexOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbyDetails_GetMemberByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_GetMemberByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MemberIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_GetMemberByIndexOptions),
            "::",
            stringify!(MemberIndex)
        )
    );
}
pub type EOS_LobbyDetails_GetMemberByIndexOptions = _tagEOS_LobbyDetails_GetMemberByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbySearch_FindOptions {
    #[doc = " API Version: Set this to EOS_LOBBYSEARCH_FIND_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the user making the search request"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbySearch_FindOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbySearch_FindOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbySearch_FindOptions>(),
        16usize,
        concat!("Size of: ", stringify!(_tagEOS_LobbySearch_FindOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbySearch_FindOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_LobbySearch_FindOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbySearch_FindOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbySearch_FindOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_LobbySearch_FindOptions = _tagEOS_LobbySearch_FindOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbySearch_FindCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_LobbySearch_Find"]
    pub ClientData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbySearch_FindCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbySearch_FindCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbySearch_FindCallbackInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbySearch_FindCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbySearch_FindCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbySearch_FindCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbySearch_FindCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbySearch_FindCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
}
pub type EOS_LobbySearch_FindCallbackInfo = _tagEOS_LobbySearch_FindCallbackInfo;
pub type EOS_LobbySearch_OnFindCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_LobbySearch_FindCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbySearch_SetLobbyIdOptions {
    #[doc = " API Version: Set this to EOS_LOBBYSEARCH_SETLOBBYID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The ID of the lobby to find"]
    pub LobbyId: EOS_LobbyId,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbySearch_SetLobbyIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbySearch_SetLobbyIdOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbySearch_SetLobbyIdOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbySearch_SetLobbyIdOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbySearch_SetLobbyIdOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbySearch_SetLobbyIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbySearch_SetLobbyIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbySearch_SetLobbyIdOptions),
            "::",
            stringify!(LobbyId)
        )
    );
}
pub type EOS_LobbySearch_SetLobbyIdOptions = _tagEOS_LobbySearch_SetLobbyIdOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbySearch_SetTargetUserIdOptions {
    #[doc = " API Version: Set this to EOS_LOBBYSEARCH_SETTARGETUSERID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Search lobbies for given user by Product User ID, returning any lobbies where this user is currently registered"]
    pub TargetUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbySearch_SetTargetUserIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbySearch_SetTargetUserIdOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbySearch_SetTargetUserIdOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbySearch_SetTargetUserIdOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbySearch_SetTargetUserIdOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbySearch_SetTargetUserIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbySearch_SetTargetUserIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbySearch_SetTargetUserIdOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_LobbySearch_SetTargetUserIdOptions = _tagEOS_LobbySearch_SetTargetUserIdOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbySearch_SetParameterOptions {
    #[doc = " API Version: Set this to EOS_LOBBYSEARCH_SETPARAMETER_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Search parameter describing a key and a value to compare"]
    pub Parameter: *const EOS_Lobby_AttributeData,
    #[doc = " The type of comparison to make against the search parameter"]
    pub ComparisonOp: EOS_EComparisonOp,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbySearch_SetParameterOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbySearch_SetParameterOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbySearch_SetParameterOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbySearch_SetParameterOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbySearch_SetParameterOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbySearch_SetParameterOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbySearch_SetParameterOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Parameter) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbySearch_SetParameterOptions),
            "::",
            stringify!(Parameter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ComparisonOp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbySearch_SetParameterOptions),
            "::",
            stringify!(ComparisonOp)
        )
    );
}
pub type EOS_LobbySearch_SetParameterOptions = _tagEOS_LobbySearch_SetParameterOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbySearch_RemoveParameterOptions {
    #[doc = " API Version: Set this to EOS_LOBBYSEARCH_REMOVEPARAMETER_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Search parameter key to remove from the search"]
    pub Key: *const ::std::os::raw::c_char,
    #[doc = " Search comparison operation associated with the key to remove"]
    pub ComparisonOp: EOS_EComparisonOp,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbySearch_RemoveParameterOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbySearch_RemoveParameterOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbySearch_RemoveParameterOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbySearch_RemoveParameterOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbySearch_RemoveParameterOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbySearch_RemoveParameterOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbySearch_RemoveParameterOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbySearch_RemoveParameterOptions),
            "::",
            stringify!(Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ComparisonOp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbySearch_RemoveParameterOptions),
            "::",
            stringify!(ComparisonOp)
        )
    );
}
pub type EOS_LobbySearch_RemoveParameterOptions = _tagEOS_LobbySearch_RemoveParameterOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbySearch_SetMaxResultsOptions {
    #[doc = " API Version: Set this to EOS_LOBBYSEARCH_SETMAXRESULTS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Maximum number of search results to return from the query"]
    pub MaxResults: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbySearch_SetMaxResultsOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbySearch_SetMaxResultsOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbySearch_SetMaxResultsOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbySearch_SetMaxResultsOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbySearch_SetMaxResultsOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbySearch_SetMaxResultsOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbySearch_SetMaxResultsOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxResults) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbySearch_SetMaxResultsOptions),
            "::",
            stringify!(MaxResults)
        )
    );
}
pub type EOS_LobbySearch_SetMaxResultsOptions = _tagEOS_LobbySearch_SetMaxResultsOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbySearch_GetSearchResultCountOptions {
    #[doc = " API Version: Set this to EOS_LOBBYSEARCH_GETSEARCHRESULTCOUNT_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbySearch_GetSearchResultCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbySearch_GetSearchResultCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbySearch_GetSearchResultCountOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbySearch_GetSearchResultCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbySearch_GetSearchResultCountOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbySearch_GetSearchResultCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbySearch_GetSearchResultCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_LobbySearch_GetSearchResultCountOptions =
    _tagEOS_LobbySearch_GetSearchResultCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbySearch_CopySearchResultByIndexOptions {
    #[doc = " API Version: Set this to EOS_LOBBYSEARCH_COPYSEARCHRESULTBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The index of the lobby to retrieve within the completed search query\n @see EOS_LobbySearch_GetSearchResultCount"]
    pub LobbyIndex: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbySearch_CopySearchResultByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbySearch_CopySearchResultByIndexOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbySearch_CopySearchResultByIndexOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbySearch_CopySearchResultByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbySearch_CopySearchResultByIndexOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbySearch_CopySearchResultByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbySearch_CopySearchResultByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbySearch_CopySearchResultByIndexOptions),
            "::",
            stringify!(LobbyIndex)
        )
    );
}
pub type EOS_LobbySearch_CopySearchResultByIndexOptions =
    _tagEOS_LobbySearch_CopySearchResultByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbyDetails_CopyMemberInfoOptions {
    #[doc = " API Version: Set this to EOS_LOBBYDETAILS_COPYMEMBERINFO_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the lobby member to copy."]
    pub TargetUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbyDetails_CopyMemberInfoOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbyDetails_CopyMemberInfoOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbyDetails_CopyMemberInfoOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_LobbyDetails_CopyMemberInfoOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbyDetails_CopyMemberInfoOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_LobbyDetails_CopyMemberInfoOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_CopyMemberInfoOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_CopyMemberInfoOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_LobbyDetails_CopyMemberInfoOptions = _tagEOS_LobbyDetails_CopyMemberInfoOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_LobbyDetails_MemberInfo {
    #[doc = " API Version: Set this to EOS_LOBBYDETAILS_MEMBERINFO_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the lobby member."]
    pub UserId: EOS_ProductUserId,
    #[doc = " The platform of the lobby member."]
    pub Platform: EOS_OnlinePlatformType,
    #[doc = " Does this member allow crossplay"]
    pub bAllowsCrossplay: EOS_Bool,
}
#[test]
fn bindgen_test_layout__tagEOS_LobbyDetails_MemberInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_LobbyDetails_MemberInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_LobbyDetails_MemberInfo>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_LobbyDetails_MemberInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_LobbyDetails_MemberInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_LobbyDetails_MemberInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_MemberInfo),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_MemberInfo),
            "::",
            stringify!(UserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Platform) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_MemberInfo),
            "::",
            stringify!(Platform)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bAllowsCrossplay) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_LobbyDetails_MemberInfo),
            "::",
            stringify!(bAllowsCrossplay)
        )
    );
}
pub type EOS_LobbyDetails_MemberInfo = _tagEOS_LobbyDetails_MemberInfo;
extern "C" {
    pub fn EOS_LobbyDetails_MemberInfo_Release(
        LobbyDetailsMemberInfo: *mut EOS_LobbyDetails_MemberInfo,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_AddNotifyLeaveLobbyRequestedOptions {
    #[doc = " API Version: Set this to EOS_LOBBY_ADDNOTIFYLEAVELOBBYREQUESTED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_AddNotifyLeaveLobbyRequestedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_AddNotifyLeaveLobbyRequestedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_AddNotifyLeaveLobbyRequestedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_AddNotifyLeaveLobbyRequestedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_AddNotifyLeaveLobbyRequestedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_AddNotifyLeaveLobbyRequestedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_AddNotifyLeaveLobbyRequestedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Lobby_AddNotifyLeaveLobbyRequestedOptions =
    _tagEOS_Lobby_AddNotifyLeaveLobbyRequestedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Lobby_LeaveLobbyRequestedCallbackInfo {
    #[doc = " Context that was passed into EOS_Lobby_OnLeaveLobbyRequestedCallback"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the local user who received the leave lobby notification."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Lobby ID associated with the leave lobby request."]
    pub LobbyId: EOS_LobbyId,
}
#[test]
fn bindgen_test_layout__tagEOS_Lobby_LeaveLobbyRequestedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Lobby_LeaveLobbyRequestedCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Lobby_LeaveLobbyRequestedCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Lobby_LeaveLobbyRequestedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Lobby_LeaveLobbyRequestedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Lobby_LeaveLobbyRequestedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LeaveLobbyRequestedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LeaveLobbyRequestedCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LobbyId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Lobby_LeaveLobbyRequestedCallbackInfo),
            "::",
            stringify!(LobbyId)
        )
    );
}
pub type EOS_Lobby_LeaveLobbyRequestedCallbackInfo = _tagEOS_Lobby_LeaveLobbyRequestedCallbackInfo;
pub type EOS_Lobby_OnLeaveLobbyRequestedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Lobby_LeaveLobbyRequestedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_UserInfoHandle {
    _unused: [u8; 0],
}
pub type EOS_HUserInfo = *mut EOS_UserInfoHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UserInfo_QueryUserInfoOptions {
    #[doc = " API Version: Set this to EOS_USERINFO_QUERYUSERINFO_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local player requesting the information"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Account ID of the player whose information is being retrieved"]
    pub TargetUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_UserInfo_QueryUserInfoOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UserInfo_QueryUserInfoOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UserInfo_QueryUserInfoOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UserInfo_QueryUserInfoOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_UserInfo_QueryUserInfoOptions = _tagEOS_UserInfo_QueryUserInfoOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UserInfo_QueryUserInfoCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_UserInfo_QueryUserInfo"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Account ID of the local player requesting the information"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Account ID of the player whose information is being retrieved"]
    pub TargetUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_UserInfo_QueryUserInfoCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UserInfo_QueryUserInfoCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UserInfo_QueryUserInfoCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UserInfo_QueryUserInfoCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_UserInfo_QueryUserInfoCallbackInfo = _tagEOS_UserInfo_QueryUserInfoCallbackInfo;
pub type EOS_UserInfo_OnQueryUserInfoCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_UserInfo_QueryUserInfoCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UserInfo_QueryUserInfoByDisplayNameOptions {
    #[doc = " API Version: Set this to EOS_USERINFO_QUERYUSERINFOBYDISPLAYNAME_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local player requesting the information"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " Raw display name (un-sanitized) of the player being queried"]
    pub DisplayName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_UserInfo_QueryUserInfoByDisplayNameOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UserInfo_QueryUserInfoByDisplayNameOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UserInfo_QueryUserInfoByDisplayNameOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoByDisplayNameOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UserInfo_QueryUserInfoByDisplayNameOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoByDisplayNameOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoByDisplayNameOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoByDisplayNameOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisplayName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoByDisplayNameOptions),
            "::",
            stringify!(DisplayName)
        )
    );
}
pub type EOS_UserInfo_QueryUserInfoByDisplayNameOptions =
    _tagEOS_UserInfo_QueryUserInfoByDisplayNameOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UserInfo_QueryUserInfoByDisplayNameCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_UserInfo_QueryUserInfoByDisplayName"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Account ID of the local player requesting the information"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Account ID of the player whose information is being retrieved"]
    pub TargetUserId: EOS_EpicAccountId,
    #[doc = " Display name (un-sanitized) of the player being queried. This memory is only valid during the scope of the callback."]
    pub DisplayName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_UserInfo_QueryUserInfoByDisplayNameCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UserInfo_QueryUserInfoByDisplayNameCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UserInfo_QueryUserInfoByDisplayNameCallbackInfo>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoByDisplayNameCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UserInfo_QueryUserInfoByDisplayNameCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoByDisplayNameCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoByDisplayNameCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoByDisplayNameCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoByDisplayNameCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoByDisplayNameCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisplayName) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoByDisplayNameCallbackInfo),
            "::",
            stringify!(DisplayName)
        )
    );
}
pub type EOS_UserInfo_QueryUserInfoByDisplayNameCallbackInfo =
    _tagEOS_UserInfo_QueryUserInfoByDisplayNameCallbackInfo;
pub type EOS_UserInfo_OnQueryUserInfoByDisplayNameCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_UserInfo_QueryUserInfoByDisplayNameCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UserInfo_QueryUserInfoByExternalAccountOptions {
    #[doc = " API Version: Set this to EOS_USERINFO_QUERYUSERINFOBYEXTERNALACCOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local player requesting the information"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " External account ID of the user whose information is being retrieved"]
    pub ExternalAccountId: *const ::std::os::raw::c_char,
    #[doc = " Account type of the external user info to query"]
    pub AccountType: EOS_EExternalAccountType,
}
#[test]
fn bindgen_test_layout__tagEOS_UserInfo_QueryUserInfoByExternalAccountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UserInfo_QueryUserInfoByExternalAccountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UserInfo_QueryUserInfoByExternalAccountOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoByExternalAccountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UserInfo_QueryUserInfoByExternalAccountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoByExternalAccountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoByExternalAccountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoByExternalAccountOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExternalAccountId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoByExternalAccountOptions),
            "::",
            stringify!(ExternalAccountId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccountType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoByExternalAccountOptions),
            "::",
            stringify!(AccountType)
        )
    );
}
pub type EOS_UserInfo_QueryUserInfoByExternalAccountOptions =
    _tagEOS_UserInfo_QueryUserInfoByExternalAccountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UserInfo_QueryUserInfoByExternalAccountCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_UserInfo_QueryUserInfoByExternalAccount"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Epic Account ID of the local player who requested the information"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " External account id of the user whose information has been retrieved"]
    pub ExternalAccountId: *const ::std::os::raw::c_char,
    #[doc = " Account type of the external account id"]
    pub AccountType: EOS_EExternalAccountType,
    #[doc = " Account ID of the player whose information has been retrieved"]
    pub TargetUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_UserInfo_QueryUserInfoByExternalAccountCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_UserInfo_QueryUserInfoByExternalAccountCallbackInfo,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UserInfo_QueryUserInfoByExternalAccountCallbackInfo>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoByExternalAccountCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UserInfo_QueryUserInfoByExternalAccountCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoByExternalAccountCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoByExternalAccountCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoByExternalAccountCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoByExternalAccountCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExternalAccountId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoByExternalAccountCallbackInfo),
            "::",
            stringify!(ExternalAccountId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccountType) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoByExternalAccountCallbackInfo),
            "::",
            stringify!(AccountType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_QueryUserInfoByExternalAccountCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_UserInfo_QueryUserInfoByExternalAccountCallbackInfo =
    _tagEOS_UserInfo_QueryUserInfoByExternalAccountCallbackInfo;
pub type EOS_UserInfo_OnQueryUserInfoByExternalAccountCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_UserInfo_QueryUserInfoByExternalAccountCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UserInfo {
    #[doc = " API Version: Set this to EOS_USERINFO_COPYUSERINFO_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the user"]
    pub UserId: EOS_EpicAccountId,
    #[doc = " The name of the owner's country. This may be null"]
    pub Country: *const ::std::os::raw::c_char,
    #[doc = " The display name (un-sanitized). This may be null"]
    pub DisplayName: *const ::std::os::raw::c_char,
    #[doc = " The ISO 639 language code for the user's preferred language. This may be null"]
    pub PreferredLanguage: *const ::std::os::raw::c_char,
    #[doc = " A nickname/alias for the target user assigned by the local user. This may be null"]
    pub Nickname: *const ::std::os::raw::c_char,
    #[doc = " The raw display name (sanitized). This may be null"]
    pub DisplayNameSanitized: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_UserInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UserInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UserInfo>(),
        56usize,
        concat!("Size of: ", stringify!(_tagEOS_UserInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UserInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_UserInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo),
            "::",
            stringify!(UserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Country) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo),
            "::",
            stringify!(Country)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisplayName) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo),
            "::",
            stringify!(DisplayName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PreferredLanguage) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo),
            "::",
            stringify!(PreferredLanguage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Nickname) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo),
            "::",
            stringify!(Nickname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisplayNameSanitized) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo),
            "::",
            stringify!(DisplayNameSanitized)
        )
    );
}
pub type EOS_UserInfo = _tagEOS_UserInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UserInfo_CopyUserInfoOptions {
    #[doc = " API Version: Set this to EOS_USERINFO_COPYUSERINFO_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local player requesting the information"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Account ID of the player whose information is being retrieved"]
    pub TargetUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_UserInfo_CopyUserInfoOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UserInfo_CopyUserInfoOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UserInfo_CopyUserInfoOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UserInfo_CopyUserInfoOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UserInfo_CopyUserInfoOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UserInfo_CopyUserInfoOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_CopyUserInfoOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_CopyUserInfoOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_CopyUserInfoOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_UserInfo_CopyUserInfoOptions = _tagEOS_UserInfo_CopyUserInfoOptions;
extern "C" {
    #[doc = " @param UserInfo - The user info structure to release\n\n @see EOS_UserInfo\n @see EOS_UserInfo_CopyUserInfo"]
    pub fn EOS_UserInfo_Release(UserInfo: *mut EOS_UserInfo);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UserInfo_ExternalUserInfo {
    #[doc = " API Version: Set this to EOS_USERINFO_EXTERNALUSERINFO_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The type of the external account"]
    pub AccountType: EOS_EExternalAccountType,
    #[doc = " The ID of the external account. Can be null"]
    pub AccountId: *const ::std::os::raw::c_char,
    #[doc = " The display name of the external account (un-sanitized). Can be null"]
    pub DisplayName: *const ::std::os::raw::c_char,
    #[doc = " The display name of the external account (sanitized). Can be null"]
    pub DisplayNameSanitized: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_UserInfo_ExternalUserInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UserInfo_ExternalUserInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UserInfo_ExternalUserInfo>(),
        32usize,
        concat!("Size of: ", stringify!(_tagEOS_UserInfo_ExternalUserInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UserInfo_ExternalUserInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UserInfo_ExternalUserInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_ExternalUserInfo),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccountType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_ExternalUserInfo),
            "::",
            stringify!(AccountType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccountId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_ExternalUserInfo),
            "::",
            stringify!(AccountId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisplayName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_ExternalUserInfo),
            "::",
            stringify!(DisplayName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisplayNameSanitized) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_ExternalUserInfo),
            "::",
            stringify!(DisplayNameSanitized)
        )
    );
}
pub type EOS_UserInfo_ExternalUserInfo = _tagEOS_UserInfo_ExternalUserInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UserInfo_GetExternalUserInfoCountOptions {
    #[doc = " API Version: Set this to EOS_USERINFO_GETEXTERNALUSERINFOCOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local player requesting the information"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Account ID of the player whose information is being retrieved"]
    pub TargetUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_UserInfo_GetExternalUserInfoCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UserInfo_GetExternalUserInfoCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UserInfo_GetExternalUserInfoCountOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UserInfo_GetExternalUserInfoCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UserInfo_GetExternalUserInfoCountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UserInfo_GetExternalUserInfoCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_GetExternalUserInfoCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_GetExternalUserInfoCountOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_GetExternalUserInfoCountOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_UserInfo_GetExternalUserInfoCountOptions =
    _tagEOS_UserInfo_GetExternalUserInfoCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UserInfo_CopyExternalUserInfoByIndexOptions {
    #[doc = " API Version: Set this to EOS_USERINFO_COPYEXTERNALUSERINFOBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local player requesting the information"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Account ID of the player whose information is being retrieved"]
    pub TargetUserId: EOS_EpicAccountId,
    #[doc = " Index of the external user info to retrieve from the cache"]
    pub Index: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_UserInfo_CopyExternalUserInfoByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UserInfo_CopyExternalUserInfoByIndexOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UserInfo_CopyExternalUserInfoByIndexOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UserInfo_CopyExternalUserInfoByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UserInfo_CopyExternalUserInfoByIndexOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UserInfo_CopyExternalUserInfoByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_CopyExternalUserInfoByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_CopyExternalUserInfoByIndexOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_CopyExternalUserInfoByIndexOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Index) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_CopyExternalUserInfoByIndexOptions),
            "::",
            stringify!(Index)
        )
    );
}
pub type EOS_UserInfo_CopyExternalUserInfoByIndexOptions =
    _tagEOS_UserInfo_CopyExternalUserInfoByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UserInfo_CopyExternalUserInfoByAccountTypeOptions {
    #[doc = " API Version: Set this to EOS_USERINFO_COPYEXTERNALUSERINFOBYACCOUNTTYPE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local player requesting the information"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Account ID of the player whose information is being retrieved"]
    pub TargetUserId: EOS_EpicAccountId,
    #[doc = " Account type of the external user info to retrieve from the cache"]
    pub AccountType: EOS_EExternalAccountType,
}
#[test]
fn bindgen_test_layout__tagEOS_UserInfo_CopyExternalUserInfoByAccountTypeOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_UserInfo_CopyExternalUserInfoByAccountTypeOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UserInfo_CopyExternalUserInfoByAccountTypeOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UserInfo_CopyExternalUserInfoByAccountTypeOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UserInfo_CopyExternalUserInfoByAccountTypeOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UserInfo_CopyExternalUserInfoByAccountTypeOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_CopyExternalUserInfoByAccountTypeOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_CopyExternalUserInfoByAccountTypeOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_CopyExternalUserInfoByAccountTypeOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccountType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_CopyExternalUserInfoByAccountTypeOptions),
            "::",
            stringify!(AccountType)
        )
    );
}
pub type EOS_UserInfo_CopyExternalUserInfoByAccountTypeOptions =
    _tagEOS_UserInfo_CopyExternalUserInfoByAccountTypeOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UserInfo_CopyExternalUserInfoByAccountIdOptions {
    #[doc = " API Version: Set this to EOS_USERINFO_COPYEXTERNALUSERINFOBYACCOUNTID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local player requesting the information"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Account ID of the player whose information is being retrieved"]
    pub TargetUserId: EOS_EpicAccountId,
    #[doc = " The external account ID associated with the (external) user info to retrieve from the cache; cannot be null"]
    pub AccountId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_UserInfo_CopyExternalUserInfoByAccountIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UserInfo_CopyExternalUserInfoByAccountIdOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UserInfo_CopyExternalUserInfoByAccountIdOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UserInfo_CopyExternalUserInfoByAccountIdOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UserInfo_CopyExternalUserInfoByAccountIdOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UserInfo_CopyExternalUserInfoByAccountIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_CopyExternalUserInfoByAccountIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_CopyExternalUserInfoByAccountIdOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_CopyExternalUserInfoByAccountIdOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccountId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_CopyExternalUserInfoByAccountIdOptions),
            "::",
            stringify!(AccountId)
        )
    );
}
pub type EOS_UserInfo_CopyExternalUserInfoByAccountIdOptions =
    _tagEOS_UserInfo_CopyExternalUserInfoByAccountIdOptions;
extern "C" {
    #[doc = " Release the memory associated with external user info. This must be called on data retrieved from\n EOS_UserInfo_CopyExternalUserInfoByIndexOptions.\n\n @param ExternalUserInfo The external user info to release.\n\n @see EOS_UserInfo_ExternalUserInfo\n @see EOS_UserInfo_CopyExternalUserInfoByIndex"]
    pub fn EOS_UserInfo_ExternalUserInfo_Release(
        ExternalUserInfo: *mut EOS_UserInfo_ExternalUserInfo,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UserInfo_BestDisplayName {
    #[doc = " API Version: Set this to EOS_USERINFO_BESTDISPLAYNAME_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the user"]
    pub UserId: EOS_EpicAccountId,
    #[doc = " The display name (un-sanitized). This may be null"]
    pub DisplayName: *const ::std::os::raw::c_char,
    #[doc = " The raw display name (sanitized). This may be null"]
    pub DisplayNameSanitized: *const ::std::os::raw::c_char,
    #[doc = " A nickname/alias for the target user assigned by the local user. This may be null"]
    pub Nickname: *const ::std::os::raw::c_char,
    #[doc = " The platform type for the user which corresponds to the display name"]
    pub PlatformType: EOS_OnlinePlatformType,
}
#[test]
fn bindgen_test_layout__tagEOS_UserInfo_BestDisplayName() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UserInfo_BestDisplayName> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UserInfo_BestDisplayName>(),
        48usize,
        concat!("Size of: ", stringify!(_tagEOS_UserInfo_BestDisplayName))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UserInfo_BestDisplayName>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UserInfo_BestDisplayName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_BestDisplayName),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_BestDisplayName),
            "::",
            stringify!(UserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisplayName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_BestDisplayName),
            "::",
            stringify!(DisplayName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisplayNameSanitized) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_BestDisplayName),
            "::",
            stringify!(DisplayNameSanitized)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Nickname) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_BestDisplayName),
            "::",
            stringify!(Nickname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PlatformType) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_BestDisplayName),
            "::",
            stringify!(PlatformType)
        )
    );
}
pub type EOS_UserInfo_BestDisplayName = _tagEOS_UserInfo_BestDisplayName;
extern "C" {
    #[doc = " Release the memory associated with EOS_UserInfo_BestDisplayName. This must be called on data retrieved from\n EOS_UserInfo_CopyBestDisplayNameWithPlatform.\n\n @param BestDisplayName - The EOS_UserInfo_BestDisplayName structure to release\n\n @see EOS_UserInfo_BestDisplayName\n @see EOS_UserInfo_CopyBestDisplayName\n @see EOS_UserInfo_CopyBestDisplayNameWithPlatform"]
    pub fn EOS_UserInfo_BestDisplayName_Release(BestDisplayName: *mut EOS_UserInfo_BestDisplayName);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UserInfo_CopyBestDisplayNameOptions {
    #[doc = " API Version: Set this to EOS_USERINFO_COPYBESTDISPLAYNAME_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local player requesting the information"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Account ID of the player whose information is being retrieved"]
    pub TargetUserId: EOS_EpicAccountId,
}
#[test]
fn bindgen_test_layout__tagEOS_UserInfo_CopyBestDisplayNameOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UserInfo_CopyBestDisplayNameOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UserInfo_CopyBestDisplayNameOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UserInfo_CopyBestDisplayNameOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UserInfo_CopyBestDisplayNameOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UserInfo_CopyBestDisplayNameOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_CopyBestDisplayNameOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_CopyBestDisplayNameOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_CopyBestDisplayNameOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_UserInfo_CopyBestDisplayNameOptions = _tagEOS_UserInfo_CopyBestDisplayNameOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UserInfo_CopyBestDisplayNameWithPlatformOptions {
    #[doc = " API Version: Set this to EOS_USERINFO_COPYBESTDISPLAYNAMEWITHPLATFORM_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the local player requesting the information"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The Epic Account ID of the player whose information is being retrieved"]
    pub TargetUserId: EOS_EpicAccountId,
    #[doc = " The platform type of the player whose information is being retrieved"]
    pub TargetPlatformType: EOS_OnlinePlatformType,
}
#[test]
fn bindgen_test_layout__tagEOS_UserInfo_CopyBestDisplayNameWithPlatformOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UserInfo_CopyBestDisplayNameWithPlatformOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UserInfo_CopyBestDisplayNameWithPlatformOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UserInfo_CopyBestDisplayNameWithPlatformOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UserInfo_CopyBestDisplayNameWithPlatformOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UserInfo_CopyBestDisplayNameWithPlatformOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_CopyBestDisplayNameWithPlatformOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_CopyBestDisplayNameWithPlatformOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_CopyBestDisplayNameWithPlatformOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetPlatformType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_CopyBestDisplayNameWithPlatformOptions),
            "::",
            stringify!(TargetPlatformType)
        )
    );
}
pub type EOS_UserInfo_CopyBestDisplayNameWithPlatformOptions =
    _tagEOS_UserInfo_CopyBestDisplayNameWithPlatformOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_UserInfo_GetLocalPlatformTypeOptions {
    #[doc = " API Version: Set this to EOS_USERINFO_GETLOCALPLATFORMTYPE_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_UserInfo_GetLocalPlatformTypeOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_UserInfo_GetLocalPlatformTypeOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_UserInfo_GetLocalPlatformTypeOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_UserInfo_GetLocalPlatformTypeOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_UserInfo_GetLocalPlatformTypeOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_UserInfo_GetLocalPlatformTypeOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_UserInfo_GetLocalPlatformTypeOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_UserInfo_GetLocalPlatformTypeOptions = _tagEOS_UserInfo_GetLocalPlatformTypeOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_PlayerDataStorageHandle {
    _unused: [u8; 0],
}
pub type EOS_HPlayerDataStorage = *mut EOS_PlayerDataStorageHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PlayerDataStorage_FileMetadata {
    #[doc = " API Version: Set this to EOS_PLAYERDATASTORAGE_FILEMETADATA_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The total size of the file in bytes (Includes file header in addition to file contents)"]
    pub FileSizeBytes: u32,
    #[doc = " The MD5 Hash of the entire file (including additional file header), in hex digits"]
    pub MD5Hash: *const ::std::os::raw::c_char,
    #[doc = " The file's name"]
    pub Filename: *const ::std::os::raw::c_char,
    #[doc = " The POSIX timestamp when the file was saved last time or EOS_PLAYERDATASTORAGE_TIME_UNDEFINED if the time is undefined.\n It will be undefined after a file is written and uploaded at first before a query operation is completed."]
    pub LastModifiedTime: i64,
    #[doc = " The size of data (payload) in file in unencrypted (original) form."]
    pub UnencryptedDataSizeBytes: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_PlayerDataStorage_FileMetadata() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_PlayerDataStorage_FileMetadata> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PlayerDataStorage_FileMetadata>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_PlayerDataStorage_FileMetadata)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PlayerDataStorage_FileMetadata>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_PlayerDataStorage_FileMetadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_FileMetadata),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileSizeBytes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_FileMetadata),
            "::",
            stringify!(FileSizeBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MD5Hash) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_FileMetadata),
            "::",
            stringify!(MD5Hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Filename) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_FileMetadata),
            "::",
            stringify!(Filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastModifiedTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_FileMetadata),
            "::",
            stringify!(LastModifiedTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UnencryptedDataSizeBytes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_FileMetadata),
            "::",
            stringify!(UnencryptedDataSizeBytes)
        )
    );
}
pub type EOS_PlayerDataStorage_FileMetadata = _tagEOS_PlayerDataStorage_FileMetadata;
extern "C" {
    #[doc = " Free the memory used by the file metadata"]
    pub fn EOS_PlayerDataStorage_FileMetadata_Release(
        FileMetadata: *mut EOS_PlayerDataStorage_FileMetadata,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PlayerDataStorage_QueryFileOptions {
    #[doc = " API Version: Set this to EOS_PLAYERDATASTORAGE_QUERYFILE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user requesting file metadata"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The name of the file being queried"]
    pub Filename: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_PlayerDataStorage_QueryFileOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_PlayerDataStorage_QueryFileOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PlayerDataStorage_QueryFileOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_PlayerDataStorage_QueryFileOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PlayerDataStorage_QueryFileOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_PlayerDataStorage_QueryFileOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_QueryFileOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_QueryFileOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Filename) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_QueryFileOptions),
            "::",
            stringify!(Filename)
        )
    );
}
pub type EOS_PlayerDataStorage_QueryFileOptions = _tagEOS_PlayerDataStorage_QueryFileOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PlayerDataStorage_QueryFileCallbackInfo {
    #[doc = " Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error"]
    pub ResultCode: EOS_EResult,
    #[doc = " Client-specified data passed into the file query request"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the local user who initiated this request"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_PlayerDataStorage_QueryFileCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_PlayerDataStorage_QueryFileCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PlayerDataStorage_QueryFileCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_PlayerDataStorage_QueryFileCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PlayerDataStorage_QueryFileCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_PlayerDataStorage_QueryFileCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_QueryFileCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_QueryFileCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_QueryFileCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_PlayerDataStorage_QueryFileCallbackInfo =
    _tagEOS_PlayerDataStorage_QueryFileCallbackInfo;
pub type EOS_PlayerDataStorage_OnQueryFileCompleteCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_PlayerDataStorage_QueryFileCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PlayerDataStorage_QueryFileListOptions {
    #[doc = " API Version: Set this to EOS_PLAYERDATASTORAGE_QUERYFILELIST_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user who requested file metadata"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_PlayerDataStorage_QueryFileListOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_PlayerDataStorage_QueryFileListOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PlayerDataStorage_QueryFileListOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_PlayerDataStorage_QueryFileListOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PlayerDataStorage_QueryFileListOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_PlayerDataStorage_QueryFileListOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_QueryFileListOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_QueryFileListOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_PlayerDataStorage_QueryFileListOptions =
    _tagEOS_PlayerDataStorage_QueryFileListOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PlayerDataStorage_QueryFileListCallbackInfo {
    #[doc = " Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error"]
    pub ResultCode: EOS_EResult,
    #[doc = " Client-specified data passed into the file query request"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the local user who initiated this request"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " A count of files that were found, if successful"]
    pub FileCount: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_PlayerDataStorage_QueryFileListCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_PlayerDataStorage_QueryFileListCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PlayerDataStorage_QueryFileListCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_PlayerDataStorage_QueryFileListCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PlayerDataStorage_QueryFileListCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_PlayerDataStorage_QueryFileListCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_QueryFileListCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_QueryFileListCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_QueryFileListCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_QueryFileListCallbackInfo),
            "::",
            stringify!(FileCount)
        )
    );
}
pub type EOS_PlayerDataStorage_QueryFileListCallbackInfo =
    _tagEOS_PlayerDataStorage_QueryFileListCallbackInfo;
pub type EOS_PlayerDataStorage_OnQueryFileListCompleteCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_PlayerDataStorage_QueryFileListCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PlayerDataStorage_GetFileMetadataCountOptions {
    #[doc = " API Version: Set this to EOS_PLAYERDATASTORAGE_GETFILEMETADATACOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user who is requesting file metadata"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_PlayerDataStorage_GetFileMetadataCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_PlayerDataStorage_GetFileMetadataCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PlayerDataStorage_GetFileMetadataCountOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_PlayerDataStorage_GetFileMetadataCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PlayerDataStorage_GetFileMetadataCountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_PlayerDataStorage_GetFileMetadataCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_GetFileMetadataCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_GetFileMetadataCountOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_PlayerDataStorage_GetFileMetadataCountOptions =
    _tagEOS_PlayerDataStorage_GetFileMetadataCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PlayerDataStorage_CopyFileMetadataAtIndexOptions {
    #[doc = " API Version: Set this to EOS_PLAYERDATASTORAGE_COPYFILEMETADATAATINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user who is requesting file metadata"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The index to get data for"]
    pub Index: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_PlayerDataStorage_CopyFileMetadataAtIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_PlayerDataStorage_CopyFileMetadataAtIndexOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PlayerDataStorage_CopyFileMetadataAtIndexOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_PlayerDataStorage_CopyFileMetadataAtIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PlayerDataStorage_CopyFileMetadataAtIndexOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_PlayerDataStorage_CopyFileMetadataAtIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_CopyFileMetadataAtIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_CopyFileMetadataAtIndexOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Index) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_CopyFileMetadataAtIndexOptions),
            "::",
            stringify!(Index)
        )
    );
}
pub type EOS_PlayerDataStorage_CopyFileMetadataAtIndexOptions =
    _tagEOS_PlayerDataStorage_CopyFileMetadataAtIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PlayerDataStorage_CopyFileMetadataByFilenameOptions {
    #[doc = " API Version: Set this to EOS_PLAYERDATASTORAGE_COPYFILEMETADATABYFILENAME_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user who is requesting file metadata"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The file's name to get data for"]
    pub Filename: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_PlayerDataStorage_CopyFileMetadataByFilenameOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_PlayerDataStorage_CopyFileMetadataByFilenameOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PlayerDataStorage_CopyFileMetadataByFilenameOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_PlayerDataStorage_CopyFileMetadataByFilenameOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PlayerDataStorage_CopyFileMetadataByFilenameOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_PlayerDataStorage_CopyFileMetadataByFilenameOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_CopyFileMetadataByFilenameOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_CopyFileMetadataByFilenameOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Filename) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_CopyFileMetadataByFilenameOptions),
            "::",
            stringify!(Filename)
        )
    );
}
pub type EOS_PlayerDataStorage_CopyFileMetadataByFilenameOptions =
    _tagEOS_PlayerDataStorage_CopyFileMetadataByFilenameOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PlayerDataStorage_DuplicateFileOptions {
    #[doc = " API Version: Set this to EOS_PLAYERDATASTORAGE_DUPLICATEFILE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user who authorized the duplication of the requested file; must be the original file's owner"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The name of the existing file to duplicate"]
    pub SourceFilename: *const ::std::os::raw::c_char,
    #[doc = " The name of the new file"]
    pub DestinationFilename: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_PlayerDataStorage_DuplicateFileOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_PlayerDataStorage_DuplicateFileOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PlayerDataStorage_DuplicateFileOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_PlayerDataStorage_DuplicateFileOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PlayerDataStorage_DuplicateFileOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_PlayerDataStorage_DuplicateFileOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_DuplicateFileOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_DuplicateFileOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SourceFilename) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_DuplicateFileOptions),
            "::",
            stringify!(SourceFilename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DestinationFilename) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_DuplicateFileOptions),
            "::",
            stringify!(DestinationFilename)
        )
    );
}
pub type EOS_PlayerDataStorage_DuplicateFileOptions =
    _tagEOS_PlayerDataStorage_DuplicateFileOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PlayerDataStorage_DuplicateFileCallbackInfo {
    #[doc = " Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error"]
    pub ResultCode: EOS_EResult,
    #[doc = " Client-specified data passed into the file duplicate request"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the local user who initiated this request"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_PlayerDataStorage_DuplicateFileCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_PlayerDataStorage_DuplicateFileCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PlayerDataStorage_DuplicateFileCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_PlayerDataStorage_DuplicateFileCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PlayerDataStorage_DuplicateFileCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_PlayerDataStorage_DuplicateFileCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_DuplicateFileCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_DuplicateFileCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_DuplicateFileCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_PlayerDataStorage_DuplicateFileCallbackInfo =
    _tagEOS_PlayerDataStorage_DuplicateFileCallbackInfo;
pub type EOS_PlayerDataStorage_OnDuplicateFileCompleteCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_PlayerDataStorage_DuplicateFileCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PlayerDataStorage_DeleteFileOptions {
    #[doc = " API Version: Set this to EOS_PLAYERDATASTORAGE_DELETEFILE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user who authorizes deletion of the file; must be the file's owner"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The name of the file to delete"]
    pub Filename: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_PlayerDataStorage_DeleteFileOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_PlayerDataStorage_DeleteFileOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PlayerDataStorage_DeleteFileOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_PlayerDataStorage_DeleteFileOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PlayerDataStorage_DeleteFileOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_PlayerDataStorage_DeleteFileOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_DeleteFileOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_DeleteFileOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Filename) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_DeleteFileOptions),
            "::",
            stringify!(Filename)
        )
    );
}
pub type EOS_PlayerDataStorage_DeleteFileOptions = _tagEOS_PlayerDataStorage_DeleteFileOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PlayerDataStorage_DeleteFileCallbackInfo {
    #[doc = " Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error"]
    pub ResultCode: EOS_EResult,
    #[doc = " Client-specified data passed into the file deletion request"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the local user who initiated this request"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_PlayerDataStorage_DeleteFileCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_PlayerDataStorage_DeleteFileCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PlayerDataStorage_DeleteFileCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_PlayerDataStorage_DeleteFileCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PlayerDataStorage_DeleteFileCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_PlayerDataStorage_DeleteFileCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_DeleteFileCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_DeleteFileCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_DeleteFileCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_PlayerDataStorage_DeleteFileCallbackInfo =
    _tagEOS_PlayerDataStorage_DeleteFileCallbackInfo;
pub type EOS_PlayerDataStorage_OnDeleteFileCompleteCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_PlayerDataStorage_DeleteFileCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_PlayerDataStorageFileTransferRequestHandle {
    _unused: [u8; 0],
}
#[doc = " Handle type to a File Request"]
pub type EOS_HPlayerDataStorageFileTransferRequest =
    *mut EOS_PlayerDataStorageFileTransferRequestHandle;
extern "C" {
    #[doc = " Free the memory used by a cloud-storage file request handle. This will not cancel a request in progress."]
    pub fn EOS_PlayerDataStorageFileTransferRequest_Release(
        PlayerDataStorageFileTransferHandle: EOS_HPlayerDataStorageFileTransferRequest,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PlayerDataStorage_FileTransferProgressCallbackInfo {
    #[doc = " Client-specified data passed into the file request"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the local user who initiated this request"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The file name of the file being transferred"]
    pub Filename: *const ::std::os::raw::c_char,
    #[doc = " Amount of bytes transferred so far in this request, out of TotalFileSizeBytes"]
    pub BytesTransferred: u32,
    #[doc = " The total size of the file being transferred (Includes file header in addition to file contents, can be slightly more than expected)"]
    pub TotalFileSizeBytes: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_PlayerDataStorage_FileTransferProgressCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_PlayerDataStorage_FileTransferProgressCallbackInfo,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PlayerDataStorage_FileTransferProgressCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_PlayerDataStorage_FileTransferProgressCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PlayerDataStorage_FileTransferProgressCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_PlayerDataStorage_FileTransferProgressCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_FileTransferProgressCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_FileTransferProgressCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Filename) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_FileTransferProgressCallbackInfo),
            "::",
            stringify!(Filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BytesTransferred) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_FileTransferProgressCallbackInfo),
            "::",
            stringify!(BytesTransferred)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalFileSizeBytes) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_FileTransferProgressCallbackInfo),
            "::",
            stringify!(TotalFileSizeBytes)
        )
    );
}
pub type EOS_PlayerDataStorage_FileTransferProgressCallbackInfo =
    _tagEOS_PlayerDataStorage_FileTransferProgressCallbackInfo;
pub type EOS_PlayerDataStorage_OnFileTransferProgressCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_PlayerDataStorage_FileTransferProgressCallbackInfo),
>;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_PlayerDataStorage_EReadResult {
    #[doc = " Signifies the data was read successfully, and we should continue to the next chunk if possible"]
    EOS_RR_ContinueReading = 1,
    #[doc = " Signifies there was a failure reading the data, and the request should end"]
    EOS_RR_FailRequest = 2,
    #[doc = " Signifies the request should be canceled, but not due to an error"]
    EOS_RR_CancelRequest = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PlayerDataStorage_ReadFileDataCallbackInfo {
    #[doc = " Client-specified data passed into the file request"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the local user who initiated this request"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The file name being read"]
    pub Filename: *const ::std::os::raw::c_char,
    #[doc = " The total file size of the file being read"]
    pub TotalFileSizeBytes: u32,
    #[doc = " Is this chunk the last chunk of data?"]
    pub bIsLastChunk: EOS_Bool,
    #[doc = " The length of DataChunk in bytes that can be safely read"]
    pub DataChunkLengthBytes: u32,
    #[doc = " Pointer to the start of data to be read"]
    pub DataChunk: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_PlayerDataStorage_ReadFileDataCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_PlayerDataStorage_ReadFileDataCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PlayerDataStorage_ReadFileDataCallbackInfo>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_PlayerDataStorage_ReadFileDataCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PlayerDataStorage_ReadFileDataCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_PlayerDataStorage_ReadFileDataCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_ReadFileDataCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_ReadFileDataCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Filename) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_ReadFileDataCallbackInfo),
            "::",
            stringify!(Filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalFileSizeBytes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_ReadFileDataCallbackInfo),
            "::",
            stringify!(TotalFileSizeBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsLastChunk) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_ReadFileDataCallbackInfo),
            "::",
            stringify!(bIsLastChunk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataChunkLengthBytes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_ReadFileDataCallbackInfo),
            "::",
            stringify!(DataChunkLengthBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataChunk) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_ReadFileDataCallbackInfo),
            "::",
            stringify!(DataChunk)
        )
    );
}
pub type EOS_PlayerDataStorage_ReadFileDataCallbackInfo =
    _tagEOS_PlayerDataStorage_ReadFileDataCallbackInfo;
pub type EOS_PlayerDataStorage_OnReadFileDataCallback = ::std::option::Option<
    unsafe extern "C" fn(
        Data: *const EOS_PlayerDataStorage_ReadFileDataCallbackInfo,
    ) -> EOS_PlayerDataStorage_EReadResult,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PlayerDataStorage_ReadFileOptions {
    #[doc = " API Version: Set this to EOS_PLAYERDATASTORAGE_READFILE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user who is reading the requested file"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The file name to read; this file must already exist"]
    pub Filename: *const ::std::os::raw::c_char,
    #[doc = " The maximum amount of data in bytes should be available to read in a single EOS_PlayerDataStorage_OnReadFileDataCallback call"]
    pub ReadChunkLengthBytes: u32,
    #[doc = " Callback function that handles data as it comes in, and can stop the transfer early"]
    pub ReadFileDataCallback: EOS_PlayerDataStorage_OnReadFileDataCallback,
    #[doc = " Optional callback function to be informed of download progress, if the file is not already locally cached; if provided, this will be called at least once before completion if the request is successfully started"]
    pub FileTransferProgressCallback: EOS_PlayerDataStorage_OnFileTransferProgressCallback,
}
#[test]
fn bindgen_test_layout__tagEOS_PlayerDataStorage_ReadFileOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_PlayerDataStorage_ReadFileOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PlayerDataStorage_ReadFileOptions>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_PlayerDataStorage_ReadFileOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PlayerDataStorage_ReadFileOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_PlayerDataStorage_ReadFileOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_ReadFileOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_ReadFileOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Filename) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_ReadFileOptions),
            "::",
            stringify!(Filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadChunkLengthBytes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_ReadFileOptions),
            "::",
            stringify!(ReadChunkLengthBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadFileDataCallback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_ReadFileOptions),
            "::",
            stringify!(ReadFileDataCallback)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).FileTransferProgressCallback) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_ReadFileOptions),
            "::",
            stringify!(FileTransferProgressCallback)
        )
    );
}
pub type EOS_PlayerDataStorage_ReadFileOptions = _tagEOS_PlayerDataStorage_ReadFileOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PlayerDataStorage_ReadFileCallbackInfo {
    #[doc = " The result code for the operation.\n EOS_Success: The request was successful.\n EOS_Canceled: The request was canceled.\n EOS_TooManyRequests: There are too many requests in progress for the local user at this time.\n EOS_AlreadyPending: There is another requests in progress for the specified file by this user.\n EOS_CacheDirectoryMissing: The cache directory was not set when calling EOS_Platform_Create.\n EOS_CacheDirectoryInvalid: The cache directory provided when calling EOS_Platform_Create was invalid.\n EOS_PlayerDataStorage_UserThrottled: There were too many requests to the Data Storage service recently by the local user. The application must wait some time before trying again.\n EOS_PlayerDataStorage_EncryptionKeyNotSet: The encryption key value was not set when calling EOS_Platform_Create.\n EOS_PlayerDataStorage_FileCorrupted: The downloaded or cached file was corrupted or invalid in some way. What exactly is wrong with the file is returned in the logs (potentially retryable).\n EOS_InvalidState: The read operation is not allowed (e.g. when application is suspended).\n EOS_UnexpectedError: An unexpected error occurred either downloading, or reading the downloaded file. This most commonly means there were file IO issues such as: permission issues, disk is full, etc. (potentially retryable)"]
    pub ResultCode: EOS_EResult,
    #[doc = " Client-specified data passed into the file read request"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the local user who initiated this request"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The filename of the file that has been finished reading"]
    pub Filename: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_PlayerDataStorage_ReadFileCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_PlayerDataStorage_ReadFileCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PlayerDataStorage_ReadFileCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_PlayerDataStorage_ReadFileCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PlayerDataStorage_ReadFileCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_PlayerDataStorage_ReadFileCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_ReadFileCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_ReadFileCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_ReadFileCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Filename) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_ReadFileCallbackInfo),
            "::",
            stringify!(Filename)
        )
    );
}
pub type EOS_PlayerDataStorage_ReadFileCallbackInfo =
    _tagEOS_PlayerDataStorage_ReadFileCallbackInfo;
pub type EOS_PlayerDataStorage_OnReadFileCompleteCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_PlayerDataStorage_ReadFileCallbackInfo),
>;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_PlayerDataStorage_EWriteResult {
    #[doc = " Signifies the data was written successfully, and we should write the data the file"]
    EOS_WR_ContinueWriting = 1,
    #[doc = " Signifies all data has now been written successfully, and we should upload the data to the cloud"]
    EOS_WR_CompleteRequest = 2,
    #[doc = " Signifies there was a failure writing the data, and the request should end"]
    EOS_WR_FailRequest = 3,
    #[doc = " Signifies the request should be canceled, but not due to an error"]
    EOS_WR_CancelRequest = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PlayerDataStorage_WriteFileDataCallbackInfo {
    #[doc = " Client-specified data passed into the file write request"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the local user who initiated this request"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The file name that is being written to"]
    pub Filename: *const ::std::os::raw::c_char,
    #[doc = " The maximum amount of data in bytes that can be written safely to DataBuffer"]
    pub DataBufferLengthBytes: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_PlayerDataStorage_WriteFileDataCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_PlayerDataStorage_WriteFileDataCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PlayerDataStorage_WriteFileDataCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_PlayerDataStorage_WriteFileDataCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PlayerDataStorage_WriteFileDataCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_PlayerDataStorage_WriteFileDataCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_WriteFileDataCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_WriteFileDataCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Filename) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_WriteFileDataCallbackInfo),
            "::",
            stringify!(Filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataBufferLengthBytes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_WriteFileDataCallbackInfo),
            "::",
            stringify!(DataBufferLengthBytes)
        )
    );
}
pub type EOS_PlayerDataStorage_WriteFileDataCallbackInfo =
    _tagEOS_PlayerDataStorage_WriteFileDataCallbackInfo;
pub type EOS_PlayerDataStorage_OnWriteFileDataCallback = ::std::option::Option<
    unsafe extern "C" fn(
        Data: *const EOS_PlayerDataStorage_WriteFileDataCallbackInfo,
        OutDataBuffer: *mut ::std::os::raw::c_void,
        OutDataWritten: *mut u32,
    ) -> EOS_PlayerDataStorage_EWriteResult,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PlayerDataStorage_WriteFileOptions {
    #[doc = " API Version: Set this to EOS_PLAYERDATASTORAGE_WRITEFILE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user who is writing the requested file to the cloud"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The name of the file to write; if this file already exists, the contents will be replaced if the write request completes successfully"]
    pub Filename: *const ::std::os::raw::c_char,
    #[doc = " Requested maximum amount of data (in bytes) that can be written to the file per tick"]
    pub ChunkLengthBytes: u32,
    #[doc = " Callback function that provides chunks of data to be written into the requested file"]
    pub WriteFileDataCallback: EOS_PlayerDataStorage_OnWriteFileDataCallback,
    #[doc = " Optional callback function to inform the application of upload progress; will be called at least once if set"]
    pub FileTransferProgressCallback: EOS_PlayerDataStorage_OnFileTransferProgressCallback,
}
#[test]
fn bindgen_test_layout__tagEOS_PlayerDataStorage_WriteFileOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_PlayerDataStorage_WriteFileOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PlayerDataStorage_WriteFileOptions>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_PlayerDataStorage_WriteFileOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PlayerDataStorage_WriteFileOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_PlayerDataStorage_WriteFileOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_WriteFileOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_WriteFileOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Filename) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_WriteFileOptions),
            "::",
            stringify!(Filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ChunkLengthBytes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_WriteFileOptions),
            "::",
            stringify!(ChunkLengthBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WriteFileDataCallback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_WriteFileOptions),
            "::",
            stringify!(WriteFileDataCallback)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).FileTransferProgressCallback) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_WriteFileOptions),
            "::",
            stringify!(FileTransferProgressCallback)
        )
    );
}
pub type EOS_PlayerDataStorage_WriteFileOptions = _tagEOS_PlayerDataStorage_WriteFileOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PlayerDataStorage_WriteFileCallbackInfo {
    #[doc = " The result code for the operation.\n EOS_Success: The request was successful.\n EOS_Canceled: The request was canceled.\n EOS_TooManyRequests: There are too many requests in progress for the local user at this time.\n EOS_AlreadyPending: There is another requests in progress for the specified file by this user.\n EOS_CacheDirectoryMissing: The cache directory was not set when calling EOS_Platform_Create.\n EOS_CacheDirectoryInvalid: The cache directory provided when calling EOS_Platform_Create was invalid.\n EOS_PlayerDataStorage_UserThrottled: There were too many requests to the Data Storage service recently by the local user. The application must wait some time before trying again.\n EOS_PlayerDataStorage_EncryptionKeyNotSet: The encryption key value was not set when calling EOS_Platform_Create.\n EOS_InvalidState: The read operation is not allowed (e.g. when application is suspended).\n EOS_UnexpectedError: An unexpected error occurred either downloading, or reading the downloaded file. This most commonly means there were file IO issues such as: permission issues, disk is full, etc. (potentially retryable)"]
    pub ResultCode: EOS_EResult,
    #[doc = " Client-specified data passed into the file write request"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the local user who initiated this request"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The file name that is being written to"]
    pub Filename: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_PlayerDataStorage_WriteFileCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_PlayerDataStorage_WriteFileCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PlayerDataStorage_WriteFileCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_PlayerDataStorage_WriteFileCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PlayerDataStorage_WriteFileCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_PlayerDataStorage_WriteFileCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_WriteFileCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_WriteFileCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_WriteFileCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Filename) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_WriteFileCallbackInfo),
            "::",
            stringify!(Filename)
        )
    );
}
pub type EOS_PlayerDataStorage_WriteFileCallbackInfo =
    _tagEOS_PlayerDataStorage_WriteFileCallbackInfo;
pub type EOS_PlayerDataStorage_OnWriteFileCompleteCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_PlayerDataStorage_WriteFileCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PlayerDataStorage_DeleteCacheOptions {
    #[doc = " API Version: Set this to EOS_PLAYERDATASTORAGE_DELETECACHE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Product User ID of the local user who is deleting his cache"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_PlayerDataStorage_DeleteCacheOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_PlayerDataStorage_DeleteCacheOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PlayerDataStorage_DeleteCacheOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_PlayerDataStorage_DeleteCacheOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PlayerDataStorage_DeleteCacheOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_PlayerDataStorage_DeleteCacheOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_DeleteCacheOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_DeleteCacheOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_PlayerDataStorage_DeleteCacheOptions = _tagEOS_PlayerDataStorage_DeleteCacheOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_PlayerDataStorage_DeleteCacheCallbackInfo {
    #[doc = " Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error"]
    pub ResultCode: EOS_EResult,
    #[doc = " Client-specified data passed into the delete cache request"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Product User ID of the local user who initiated this request"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_PlayerDataStorage_DeleteCacheCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_PlayerDataStorage_DeleteCacheCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_PlayerDataStorage_DeleteCacheCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_PlayerDataStorage_DeleteCacheCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_PlayerDataStorage_DeleteCacheCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_PlayerDataStorage_DeleteCacheCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_DeleteCacheCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_DeleteCacheCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_PlayerDataStorage_DeleteCacheCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_PlayerDataStorage_DeleteCacheCallbackInfo =
    _tagEOS_PlayerDataStorage_DeleteCacheCallbackInfo;
pub type EOS_PlayerDataStorage_OnDeleteCacheCompleteCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_PlayerDataStorage_DeleteCacheCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_TitleStorageHandle {
    _unused: [u8; 0],
}
pub type EOS_HTitleStorage = *mut EOS_TitleStorageHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_TitleStorage_FileMetadata {
    #[doc = " API Version: Set this to EOS_TITLESTORAGE_FILEMETADATA_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The total size of the file in bytes (Includes file header in addition to file contents)."]
    pub FileSizeBytes: u32,
    #[doc = " The MD5 Hash of the entire file (including additional file header), in hex digits"]
    pub MD5Hash: *const ::std::os::raw::c_char,
    #[doc = " The file's name"]
    pub Filename: *const ::std::os::raw::c_char,
    #[doc = " The size of data (payload) in file in unencrypted (original) form."]
    pub UnencryptedDataSizeBytes: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_TitleStorage_FileMetadata() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_TitleStorage_FileMetadata> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_TitleStorage_FileMetadata>(),
        32usize,
        concat!("Size of: ", stringify!(_tagEOS_TitleStorage_FileMetadata))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_TitleStorage_FileMetadata>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_TitleStorage_FileMetadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_FileMetadata),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileSizeBytes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_FileMetadata),
            "::",
            stringify!(FileSizeBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MD5Hash) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_FileMetadata),
            "::",
            stringify!(MD5Hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Filename) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_FileMetadata),
            "::",
            stringify!(Filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UnencryptedDataSizeBytes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_FileMetadata),
            "::",
            stringify!(UnencryptedDataSizeBytes)
        )
    );
}
pub type EOS_TitleStorage_FileMetadata = _tagEOS_TitleStorage_FileMetadata;
extern "C" {
    #[doc = " Free the memory used by the file metadata"]
    pub fn EOS_TitleStorage_FileMetadata_Release(FileMetadata: *mut EOS_TitleStorage_FileMetadata);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_TitleStorage_QueryFileOptions {
    #[doc = " API Version: Set this to EOS_TITLESTORAGE_QUERYFILE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Product User ID of the local user requesting file metadata (optional)"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The requested file's name"]
    pub Filename: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_TitleStorage_QueryFileOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_TitleStorage_QueryFileOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_TitleStorage_QueryFileOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_TitleStorage_QueryFileOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_TitleStorage_QueryFileOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_TitleStorage_QueryFileOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_QueryFileOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_QueryFileOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Filename) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_QueryFileOptions),
            "::",
            stringify!(Filename)
        )
    );
}
pub type EOS_TitleStorage_QueryFileOptions = _tagEOS_TitleStorage_QueryFileOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_TitleStorage_QueryFileCallbackInfo {
    #[doc = " Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error"]
    pub ResultCode: EOS_EResult,
    #[doc = " Client-specified data passed into the file query request"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Product User ID of the local user who initiated this request (optional, will only be present in case it was provided during operation start)"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_TitleStorage_QueryFileCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_TitleStorage_QueryFileCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_TitleStorage_QueryFileCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_TitleStorage_QueryFileCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_TitleStorage_QueryFileCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_TitleStorage_QueryFileCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_QueryFileCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_QueryFileCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_QueryFileCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_TitleStorage_QueryFileCallbackInfo = _tagEOS_TitleStorage_QueryFileCallbackInfo;
pub type EOS_TitleStorage_OnQueryFileCompleteCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_TitleStorage_QueryFileCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_TitleStorage_QueryFileListOptions {
    #[doc = " API Version: Set this to EOS_TITLESTORAGE_QUERYFILELIST_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Product User ID of the local user who requested file metadata (optional)"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " List of tags to use for lookup."]
    pub ListOfTags: *const *const ::std::os::raw::c_char,
    #[doc = " Number of tags specified in ListOfTags"]
    pub ListOfTagsCount: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_TitleStorage_QueryFileListOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_TitleStorage_QueryFileListOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_TitleStorage_QueryFileListOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_TitleStorage_QueryFileListOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_TitleStorage_QueryFileListOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_TitleStorage_QueryFileListOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_QueryFileListOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_QueryFileListOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ListOfTags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_QueryFileListOptions),
            "::",
            stringify!(ListOfTags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ListOfTagsCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_QueryFileListOptions),
            "::",
            stringify!(ListOfTagsCount)
        )
    );
}
pub type EOS_TitleStorage_QueryFileListOptions = _tagEOS_TitleStorage_QueryFileListOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_TitleStorage_QueryFileListCallbackInfo {
    #[doc = " Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error"]
    pub ResultCode: EOS_EResult,
    #[doc = " Client-specified data passed into the file query request"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Product User ID of the local user who initiated this request (optional, will only be present in case it was provided during operation start)"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " A count of files that were found, if successful"]
    pub FileCount: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_TitleStorage_QueryFileListCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_TitleStorage_QueryFileListCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_TitleStorage_QueryFileListCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_TitleStorage_QueryFileListCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_TitleStorage_QueryFileListCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_TitleStorage_QueryFileListCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_QueryFileListCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_QueryFileListCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_QueryFileListCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_QueryFileListCallbackInfo),
            "::",
            stringify!(FileCount)
        )
    );
}
pub type EOS_TitleStorage_QueryFileListCallbackInfo =
    _tagEOS_TitleStorage_QueryFileListCallbackInfo;
pub type EOS_TitleStorage_OnQueryFileListCompleteCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_TitleStorage_QueryFileListCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_TitleStorage_GetFileMetadataCountOptions {
    #[doc = " API Version: Set this to EOS_TITLESTORAGE_GETFILEMETADATACOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Product User ID of the local user who is requesting file metadata (optional)"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_TitleStorage_GetFileMetadataCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_TitleStorage_GetFileMetadataCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_TitleStorage_GetFileMetadataCountOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_TitleStorage_GetFileMetadataCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_TitleStorage_GetFileMetadataCountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_TitleStorage_GetFileMetadataCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_GetFileMetadataCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_GetFileMetadataCountOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_TitleStorage_GetFileMetadataCountOptions =
    _tagEOS_TitleStorage_GetFileMetadataCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_TitleStorage_CopyFileMetadataAtIndexOptions {
    #[doc = " API Version: Set this to EOS_TITLESTORAGE_COPYFILEMETADATAATINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Product User ID of the local user who is requesting file metadata (optional)"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The index to get data for"]
    pub Index: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_TitleStorage_CopyFileMetadataAtIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_TitleStorage_CopyFileMetadataAtIndexOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_TitleStorage_CopyFileMetadataAtIndexOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_TitleStorage_CopyFileMetadataAtIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_TitleStorage_CopyFileMetadataAtIndexOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_TitleStorage_CopyFileMetadataAtIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_CopyFileMetadataAtIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_CopyFileMetadataAtIndexOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Index) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_CopyFileMetadataAtIndexOptions),
            "::",
            stringify!(Index)
        )
    );
}
pub type EOS_TitleStorage_CopyFileMetadataAtIndexOptions =
    _tagEOS_TitleStorage_CopyFileMetadataAtIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_TitleStorage_CopyFileMetadataByFilenameOptions {
    #[doc = " API Version: Set this to EOS_TITLESTORAGE_COPYFILEMETADATABYFILENAME_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Product User ID of the local user who is requesting file metadata (optional)"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The file's name to get data for"]
    pub Filename: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_TitleStorage_CopyFileMetadataByFilenameOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_TitleStorage_CopyFileMetadataByFilenameOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_TitleStorage_CopyFileMetadataByFilenameOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_TitleStorage_CopyFileMetadataByFilenameOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_TitleStorage_CopyFileMetadataByFilenameOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_TitleStorage_CopyFileMetadataByFilenameOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_CopyFileMetadataByFilenameOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_CopyFileMetadataByFilenameOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Filename) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_CopyFileMetadataByFilenameOptions),
            "::",
            stringify!(Filename)
        )
    );
}
pub type EOS_TitleStorage_CopyFileMetadataByFilenameOptions =
    _tagEOS_TitleStorage_CopyFileMetadataByFilenameOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_TitleStorageFileTransferRequestHandle {
    _unused: [u8; 0],
}
#[doc = " Handle type to a File Request"]
pub type EOS_HTitleStorageFileTransferRequest = *mut EOS_TitleStorageFileTransferRequestHandle;
extern "C" {
    #[doc = " Free the memory used by a cloud-storage file request handle. This will not cancel a request in progress."]
    pub fn EOS_TitleStorageFileTransferRequest_Release(
        TitleStorageFileTransferHandle: EOS_HTitleStorageFileTransferRequest,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_TitleStorage_FileTransferProgressCallbackInfo {
    #[doc = " Client-specified data passed into the file request"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Product User ID of the local user who initiated this request (optional, will only be present in case it was provided during operation start)"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The file name of the file being transferred"]
    pub Filename: *const ::std::os::raw::c_char,
    #[doc = " Amount of bytes transferred so far in this request, out of TotalFileSizeBytes"]
    pub BytesTransferred: u32,
    #[doc = " The total size of the file being transferred (Includes file header in addition to file contents, can be slightly more than expected)"]
    pub TotalFileSizeBytes: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_TitleStorage_FileTransferProgressCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_TitleStorage_FileTransferProgressCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_TitleStorage_FileTransferProgressCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_TitleStorage_FileTransferProgressCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_TitleStorage_FileTransferProgressCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_TitleStorage_FileTransferProgressCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_FileTransferProgressCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_FileTransferProgressCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Filename) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_FileTransferProgressCallbackInfo),
            "::",
            stringify!(Filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BytesTransferred) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_FileTransferProgressCallbackInfo),
            "::",
            stringify!(BytesTransferred)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalFileSizeBytes) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_FileTransferProgressCallbackInfo),
            "::",
            stringify!(TotalFileSizeBytes)
        )
    );
}
pub type EOS_TitleStorage_FileTransferProgressCallbackInfo =
    _tagEOS_TitleStorage_FileTransferProgressCallbackInfo;
pub type EOS_TitleStorage_OnFileTransferProgressCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_TitleStorage_FileTransferProgressCallbackInfo),
>;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_TitleStorage_EReadResult {
    #[doc = " Signifies the data was read successfully, and we should continue to the next chunk if possible"]
    EOS_TS_RR_ContinueReading = 1,
    #[doc = " Signifies there was a failure reading the data, and the request should end"]
    EOS_TS_RR_FailRequest = 2,
    #[doc = " Signifies the request should be canceled, but not due to an error"]
    EOS_TS_RR_CancelRequest = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_TitleStorage_ReadFileDataCallbackInfo {
    #[doc = " Client-specified data passed into the file request"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Product User ID of the local user who initiated this request (optional, will only be present in case it was provided during operation start)"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The file name being read"]
    pub Filename: *const ::std::os::raw::c_char,
    #[doc = " The total file size of the file being read"]
    pub TotalFileSizeBytes: u32,
    #[doc = " Is this chunk the last chunk of data?"]
    pub bIsLastChunk: EOS_Bool,
    #[doc = " The length of DataChunk in bytes that can be safely read"]
    pub DataChunkLengthBytes: u32,
    #[doc = " Pointer to the start of data to be read"]
    pub DataChunk: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_TitleStorage_ReadFileDataCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_TitleStorage_ReadFileDataCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_TitleStorage_ReadFileDataCallbackInfo>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_TitleStorage_ReadFileDataCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_TitleStorage_ReadFileDataCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_TitleStorage_ReadFileDataCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_ReadFileDataCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_ReadFileDataCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Filename) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_ReadFileDataCallbackInfo),
            "::",
            stringify!(Filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalFileSizeBytes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_ReadFileDataCallbackInfo),
            "::",
            stringify!(TotalFileSizeBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsLastChunk) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_ReadFileDataCallbackInfo),
            "::",
            stringify!(bIsLastChunk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataChunkLengthBytes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_ReadFileDataCallbackInfo),
            "::",
            stringify!(DataChunkLengthBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataChunk) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_ReadFileDataCallbackInfo),
            "::",
            stringify!(DataChunk)
        )
    );
}
pub type EOS_TitleStorage_ReadFileDataCallbackInfo = _tagEOS_TitleStorage_ReadFileDataCallbackInfo;
pub type EOS_TitleStorage_OnReadFileDataCallback = ::std::option::Option<
    unsafe extern "C" fn(
        Data: *const EOS_TitleStorage_ReadFileDataCallbackInfo,
    ) -> EOS_TitleStorage_EReadResult,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_TitleStorage_ReadFileOptions {
    #[doc = " API Version: Set this to EOS_TITLESTORAGE_READFILE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Product User ID of the local user who is reading the requested file (optional)"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The file name to read; this file must already exist"]
    pub Filename: *const ::std::os::raw::c_char,
    #[doc = " The maximum amount of data in bytes should be available to read in a single EOS_TitleStorage_OnReadFileDataCallback call"]
    pub ReadChunkLengthBytes: u32,
    #[doc = " Callback function to handle copying read data"]
    pub ReadFileDataCallback: EOS_TitleStorage_OnReadFileDataCallback,
    #[doc = " Optional callback function to be informed of download progress, if the file is not already locally cached. If set, this will be called at least once before completion if the request is successfully started"]
    pub FileTransferProgressCallback: EOS_TitleStorage_OnFileTransferProgressCallback,
}
#[test]
fn bindgen_test_layout__tagEOS_TitleStorage_ReadFileOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_TitleStorage_ReadFileOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_TitleStorage_ReadFileOptions>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_TitleStorage_ReadFileOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_TitleStorage_ReadFileOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_TitleStorage_ReadFileOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_ReadFileOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_ReadFileOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Filename) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_ReadFileOptions),
            "::",
            stringify!(Filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadChunkLengthBytes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_ReadFileOptions),
            "::",
            stringify!(ReadChunkLengthBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadFileDataCallback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_ReadFileOptions),
            "::",
            stringify!(ReadFileDataCallback)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).FileTransferProgressCallback) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_ReadFileOptions),
            "::",
            stringify!(FileTransferProgressCallback)
        )
    );
}
pub type EOS_TitleStorage_ReadFileOptions = _tagEOS_TitleStorage_ReadFileOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_TitleStorage_ReadFileCallbackInfo {
    #[doc = " Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error"]
    pub ResultCode: EOS_EResult,
    #[doc = " Client-specified data passed into the file read request"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Product User ID of the local user who initiated this request (optional, will only be present in case it was provided during operation start)"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The filename of the file that has been finished reading"]
    pub Filename: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_TitleStorage_ReadFileCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_TitleStorage_ReadFileCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_TitleStorage_ReadFileCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_TitleStorage_ReadFileCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_TitleStorage_ReadFileCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_TitleStorage_ReadFileCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_ReadFileCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_ReadFileCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_ReadFileCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Filename) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_ReadFileCallbackInfo),
            "::",
            stringify!(Filename)
        )
    );
}
pub type EOS_TitleStorage_ReadFileCallbackInfo = _tagEOS_TitleStorage_ReadFileCallbackInfo;
pub type EOS_TitleStorage_OnReadFileCompleteCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_TitleStorage_ReadFileCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_TitleStorage_DeleteCacheOptions {
    #[doc = " API Version: Set this to EOS_TITLESTORAGE_DELETECACHE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Product User ID of the local user who is deleting his cache (optional)"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_TitleStorage_DeleteCacheOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_TitleStorage_DeleteCacheOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_TitleStorage_DeleteCacheOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_TitleStorage_DeleteCacheOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_TitleStorage_DeleteCacheOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_TitleStorage_DeleteCacheOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_DeleteCacheOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_DeleteCacheOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_TitleStorage_DeleteCacheOptions = _tagEOS_TitleStorage_DeleteCacheOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_TitleStorage_DeleteCacheCallbackInfo {
    #[doc = " Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error"]
    pub ResultCode: EOS_EResult,
    #[doc = " Client-specified data passed into the delete cache request"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Product User ID of the local user who initiated this request (optional, will only be present in case it was provided during operation start)"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_TitleStorage_DeleteCacheCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_TitleStorage_DeleteCacheCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_TitleStorage_DeleteCacheCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_TitleStorage_DeleteCacheCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_TitleStorage_DeleteCacheCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_TitleStorage_DeleteCacheCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_DeleteCacheCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_DeleteCacheCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_TitleStorage_DeleteCacheCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_TitleStorage_DeleteCacheCallbackInfo = _tagEOS_TitleStorage_DeleteCacheCallbackInfo;
pub type EOS_TitleStorage_OnDeleteCacheCompleteCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_TitleStorage_DeleteCacheCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_ConnectHandle {
    _unused: [u8; 0],
}
pub type EOS_HConnect = *mut EOS_ConnectHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_Credentials {
    #[doc = " API Version: Set this to EOS_CONNECT_CREDENTIALS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " External token associated with the user logging in."]
    pub Token: *const ::std::os::raw::c_char,
    #[doc = " Type of external login; identifies the auth method to use."]
    pub Type: EOS_EExternalCredentialType,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_Credentials() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_Credentials> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_Credentials>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Connect_Credentials))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_Credentials>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Connect_Credentials))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_Credentials),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Token) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_Credentials),
            "::",
            stringify!(Token)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_Credentials),
            "::",
            stringify!(Type)
        )
    );
}
pub type EOS_Connect_Credentials = _tagEOS_Connect_Credentials;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_UserLoginInfo {
    #[doc = " API Version: Set this to EOS_CONNECT_USERLOGININFO_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The user's display name on the identity provider systems as UTF-8 encoded null-terminated string.\n The length of the name can be at maximum up to EOS_CONNECT_USERLOGININFO_DISPLAYNAME_MAX_LENGTH bytes.\n\n As the display name passed here is client-controlled and not part of user authentication tokens,\n it is only treated as non-authoritative informational data to be used by some of the feature services.\n For example displaying player names in Leaderboards rankings."]
    pub DisplayName: *const ::std::os::raw::c_char,
    #[doc = " Nintendo Service Account ID Token (NSA ID).\n\n This field is required to be set and only used when running on the Nintendo Switch device,\n and the user is being authenticated using any other credential type than EOS_ECT_NINTENDO_NSA_ID_TOKEN.\n\n In order to use the Lobbies and Sessions interfaces, a valid NSA ID Token is required to be provided\n for the active local Nintendo Switch user. Otherwise, attempting to use either of the Lobbies or\n Sessions interfaces will return the EOS_Permission_OnlinePlayRestricted error result."]
    pub NsaIdToken: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_UserLoginInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_UserLoginInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_UserLoginInfo>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Connect_UserLoginInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_UserLoginInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Connect_UserLoginInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_UserLoginInfo),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisplayName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_UserLoginInfo),
            "::",
            stringify!(DisplayName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NsaIdToken) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_UserLoginInfo),
            "::",
            stringify!(NsaIdToken)
        )
    );
}
pub type EOS_Connect_UserLoginInfo = _tagEOS_Connect_UserLoginInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_LoginOptions {
    #[doc = " API Version: Set this to EOS_CONNECT_LOGIN_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Credentials specified for a given login method"]
    pub Credentials: *const EOS_Connect_Credentials,
    #[doc = " Additional information about the local user.\n\n This field is required to be set and used when authenticating the user using Amazon, Apple, Google, Nintendo Account, Nintendo Service Account, Oculus or the Device ID feature login.\n It is also required for using the Lobbies and Sessions interfaces when running on the Nintendo Switch device, and using any other credential type than EOS_ECT_NINTENDO_NSA_ID_TOKEN.\n In all other cases, set this field to NULL."]
    pub UserLoginInfo: *const EOS_Connect_UserLoginInfo,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_LoginOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_LoginOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_LoginOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Connect_LoginOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_LoginOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Connect_LoginOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_LoginOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Credentials) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_LoginOptions),
            "::",
            stringify!(Credentials)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserLoginInfo) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_LoginOptions),
            "::",
            stringify!(UserLoginInfo)
        )
    );
}
pub type EOS_Connect_LoginOptions = _tagEOS_Connect_LoginOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_LoginCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Connect_Login."]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " If login was successful, this is the Product User ID of the local player that logged in."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " If the user was not found with credentials passed into EOS_Connect_Login,\n this continuance token can be passed to either EOS_Connect_CreateUser\n or EOS_Connect_LinkAccount to continue the flow."]
    pub ContinuanceToken: EOS_ContinuanceToken,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_LoginCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_LoginCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_LoginCallbackInfo>(),
        32usize,
        concat!("Size of: ", stringify!(_tagEOS_Connect_LoginCallbackInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_LoginCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_LoginCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_LoginCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_LoginCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_LoginCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ContinuanceToken) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_LoginCallbackInfo),
            "::",
            stringify!(ContinuanceToken)
        )
    );
}
pub type EOS_Connect_LoginCallbackInfo = _tagEOS_Connect_LoginCallbackInfo;
pub type EOS_Connect_OnLoginCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Connect_LoginCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_CreateUserOptions {
    #[doc = " API Version: Set this to EOS_CONNECT_CREATEUSER_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Continuance token from previous call to EOS_Connect_Login"]
    pub ContinuanceToken: EOS_ContinuanceToken,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_CreateUserOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_CreateUserOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_CreateUserOptions>(),
        16usize,
        concat!("Size of: ", stringify!(_tagEOS_Connect_CreateUserOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_CreateUserOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_CreateUserOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_CreateUserOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ContinuanceToken) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_CreateUserOptions),
            "::",
            stringify!(ContinuanceToken)
        )
    );
}
pub type EOS_Connect_CreateUserOptions = _tagEOS_Connect_CreateUserOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_CreateUserCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Connect_CreateUser."]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " If the operation succeeded, this is the Product User ID of the local user who was created."]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_CreateUserCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_CreateUserCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_CreateUserCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Connect_CreateUserCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_CreateUserCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_CreateUserCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_CreateUserCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_CreateUserCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_CreateUserCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Connect_CreateUserCallbackInfo = _tagEOS_Connect_CreateUserCallbackInfo;
pub type EOS_Connect_OnCreateUserCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Connect_CreateUserCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_LinkAccountOptions {
    #[doc = " API Version: Set this to EOS_CONNECT_LINKACCOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The existing logged in product user for which to link the external account described by the continuance token."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Continuance token from previous call to EOS_Connect_Login."]
    pub ContinuanceToken: EOS_ContinuanceToken,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_LinkAccountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_LinkAccountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_LinkAccountOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Connect_LinkAccountOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_LinkAccountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_LinkAccountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_LinkAccountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_LinkAccountOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ContinuanceToken) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_LinkAccountOptions),
            "::",
            stringify!(ContinuanceToken)
        )
    );
}
pub type EOS_Connect_LinkAccountOptions = _tagEOS_Connect_LinkAccountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_LinkAccountCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Connect_LinkAccount."]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the existing, logged-in user whose account was linked (on success)."]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_LinkAccountCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_LinkAccountCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_LinkAccountCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Connect_LinkAccountCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_LinkAccountCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_LinkAccountCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_LinkAccountCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_LinkAccountCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_LinkAccountCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Connect_LinkAccountCallbackInfo = _tagEOS_Connect_LinkAccountCallbackInfo;
pub type EOS_Connect_OnLinkAccountCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Connect_LinkAccountCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_UnlinkAccountOptions {
    #[doc = " API Version: Set this to EOS_CONNECT_UNLINKACCOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Existing logged in product user that is subject for the unlinking operation.\n The external account that was used to login to the product user will be unlinked from the owning keychain.\n\n On a successful operation, the product user will be logged out as the external account used to authenticate the user was unlinked from the owning keychain."]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_UnlinkAccountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_UnlinkAccountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_UnlinkAccountOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Connect_UnlinkAccountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_UnlinkAccountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_UnlinkAccountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_UnlinkAccountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_UnlinkAccountOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Connect_UnlinkAccountOptions = _tagEOS_Connect_UnlinkAccountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_UnlinkAccountCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Connect_UnlinkAccount."]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The product user that was subject for the unlinking operation.\n\n On a successful operation, the local authentication session for the product user will have been invalidated.\n As such, the LocalUserId value will no longer be valid in any context unless the user is logged into it again."]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_UnlinkAccountCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_UnlinkAccountCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_UnlinkAccountCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Connect_UnlinkAccountCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_UnlinkAccountCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_UnlinkAccountCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_UnlinkAccountCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_UnlinkAccountCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_UnlinkAccountCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Connect_UnlinkAccountCallbackInfo = _tagEOS_Connect_UnlinkAccountCallbackInfo;
pub type EOS_Connect_OnUnlinkAccountCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Connect_UnlinkAccountCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_CreateDeviceIdOptions {
    #[doc = " API Version: Set this to EOS_CONNECT_CREATEDEVICEID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " A freeform text description identifying the device type and model,\n which can be used in account linking management to allow the player\n and customer support to identify different devices linked to an EOS\n user keychain. For example 'iPhone 6S' or 'PC Windows'.\n\n The input string must be in UTF-8 character format, with a maximum\n length of 64 characters. Longer string will be silently truncated.\n\n This field is required to be present."]
    pub DeviceModel: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_CreateDeviceIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_CreateDeviceIdOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_CreateDeviceIdOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Connect_CreateDeviceIdOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_CreateDeviceIdOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_CreateDeviceIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_CreateDeviceIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DeviceModel) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_CreateDeviceIdOptions),
            "::",
            stringify!(DeviceModel)
        )
    );
}
pub type EOS_Connect_CreateDeviceIdOptions = _tagEOS_Connect_CreateDeviceIdOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_CreateDeviceIdCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Connect_CreateDeviceId."]
    pub ClientData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_CreateDeviceIdCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_CreateDeviceIdCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_CreateDeviceIdCallbackInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Connect_CreateDeviceIdCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_CreateDeviceIdCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_CreateDeviceIdCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_CreateDeviceIdCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_CreateDeviceIdCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
}
pub type EOS_Connect_CreateDeviceIdCallbackInfo = _tagEOS_Connect_CreateDeviceIdCallbackInfo;
pub type EOS_Connect_OnCreateDeviceIdCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Connect_CreateDeviceIdCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_DeleteDeviceIdOptions {
    #[doc = " API Version: Set this to EOS_CONNECT_DELETEDEVICEID_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_DeleteDeviceIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_DeleteDeviceIdOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_DeleteDeviceIdOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Connect_DeleteDeviceIdOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_DeleteDeviceIdOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_DeleteDeviceIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_DeleteDeviceIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Connect_DeleteDeviceIdOptions = _tagEOS_Connect_DeleteDeviceIdOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_DeleteDeviceIdCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Connect_DeleteDeviceId"]
    pub ClientData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_DeleteDeviceIdCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_DeleteDeviceIdCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_DeleteDeviceIdCallbackInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Connect_DeleteDeviceIdCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_DeleteDeviceIdCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_DeleteDeviceIdCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_DeleteDeviceIdCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_DeleteDeviceIdCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
}
pub type EOS_Connect_DeleteDeviceIdCallbackInfo = _tagEOS_Connect_DeleteDeviceIdCallbackInfo;
pub type EOS_Connect_OnDeleteDeviceIdCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Connect_DeleteDeviceIdCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_TransferDeviceIdAccountOptions {
    #[doc = " API Version: Set this to EOS_CONNECT_TRANSFERDEVICEIDACCOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The primary product user id, currently logged in, that is already associated with a real external user account (such as Epic Games, PlayStation(TM)Network, Xbox Live and other).\n\n The account linking keychain that owns this product user will be preserved and receive\n the Device ID login credentials under it."]
    pub PrimaryLocalUserId: EOS_ProductUserId,
    #[doc = " The product user id, currently logged in, that has been originally created using the anonymous local Device ID login type,\n and whose Device ID login will be transferred to the keychain of the PrimaryLocalUserId."]
    pub LocalDeviceUserId: EOS_ProductUserId,
    #[doc = " Specifies which EOS_ProductUserId (i.e. game progression) will be preserved in the operation.\n\n After a successful transfer operation, subsequent logins using the same external account or\n the same local Device ID login will return user session for the ProductUserIdToPreserve.\n\n Set to either PrimaryLocalUserId or LocalDeviceUserId."]
    pub ProductUserIdToPreserve: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_TransferDeviceIdAccountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_TransferDeviceIdAccountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_TransferDeviceIdAccountOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Connect_TransferDeviceIdAccountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_TransferDeviceIdAccountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_TransferDeviceIdAccountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_TransferDeviceIdAccountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PrimaryLocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_TransferDeviceIdAccountOptions),
            "::",
            stringify!(PrimaryLocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalDeviceUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_TransferDeviceIdAccountOptions),
            "::",
            stringify!(LocalDeviceUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProductUserIdToPreserve) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_TransferDeviceIdAccountOptions),
            "::",
            stringify!(ProductUserIdToPreserve)
        )
    );
}
pub type EOS_Connect_TransferDeviceIdAccountOptions =
    _tagEOS_Connect_TransferDeviceIdAccountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_TransferDeviceIdAccountCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Connect_TransferDeviceIdAccount."]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The ProductUserIdToPreserve that was passed to the original EOS_Connect_TransferDeviceIdAccount call.\n\n On successful operation, this EOS_ProductUserId will have a valid authentication session\n and the other EOS_ProductUserId value has been discarded and lost forever.\n\n The application should remove any registered notification callbacks for the discarded EOS_ProductUserId as obsolete."]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_TransferDeviceIdAccountCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_TransferDeviceIdAccountCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_TransferDeviceIdAccountCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Connect_TransferDeviceIdAccountCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_TransferDeviceIdAccountCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_TransferDeviceIdAccountCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_TransferDeviceIdAccountCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_TransferDeviceIdAccountCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_TransferDeviceIdAccountCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Connect_TransferDeviceIdAccountCallbackInfo =
    _tagEOS_Connect_TransferDeviceIdAccountCallbackInfo;
pub type EOS_Connect_OnTransferDeviceIdAccountCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Connect_TransferDeviceIdAccountCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_QueryExternalAccountMappingsOptions {
    #[doc = " API Version: Set this to EOS_CONNECT_QUERYEXTERNALACCOUNTMAPPINGS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the existing, logged-in user who is querying account mappings."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " External auth service supplying the account IDs in string form."]
    pub AccountIdType: EOS_EExternalAccountType,
    #[doc = " An array of external account IDs to map to the product user ID representation."]
    pub ExternalAccountIds: *mut *const ::std::os::raw::c_char,
    #[doc = " Number of account IDs to query."]
    pub ExternalAccountIdCount: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_QueryExternalAccountMappingsOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_QueryExternalAccountMappingsOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_QueryExternalAccountMappingsOptions>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Connect_QueryExternalAccountMappingsOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_QueryExternalAccountMappingsOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_QueryExternalAccountMappingsOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_QueryExternalAccountMappingsOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_QueryExternalAccountMappingsOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccountIdType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_QueryExternalAccountMappingsOptions),
            "::",
            stringify!(AccountIdType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExternalAccountIds) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_QueryExternalAccountMappingsOptions),
            "::",
            stringify!(ExternalAccountIds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExternalAccountIdCount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_QueryExternalAccountMappingsOptions),
            "::",
            stringify!(ExternalAccountIdCount)
        )
    );
}
pub type EOS_Connect_QueryExternalAccountMappingsOptions =
    _tagEOS_Connect_QueryExternalAccountMappingsOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_QueryExternalAccountMappingsCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Connect_QueryExternalAccountMappings."]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the existing, logged-in user who made the request."]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_QueryExternalAccountMappingsCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Connect_QueryExternalAccountMappingsCallbackInfo,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_QueryExternalAccountMappingsCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Connect_QueryExternalAccountMappingsCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_QueryExternalAccountMappingsCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_QueryExternalAccountMappingsCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_QueryExternalAccountMappingsCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_QueryExternalAccountMappingsCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_QueryExternalAccountMappingsCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Connect_QueryExternalAccountMappingsCallbackInfo =
    _tagEOS_Connect_QueryExternalAccountMappingsCallbackInfo;
pub type EOS_Connect_OnQueryExternalAccountMappingsCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Connect_QueryExternalAccountMappingsCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_GetExternalAccountMappingsOptions {
    #[doc = " API Version: Set this to EOS_CONNECT_GETEXTERNALACCOUNTMAPPING_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the existing, logged-in user who is querying account mappings."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " External auth service supplying the account IDs in string form."]
    pub AccountIdType: EOS_EExternalAccountType,
    #[doc = " Target user to retrieve the mapping for, as an external account ID."]
    pub TargetExternalUserId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_GetExternalAccountMappingsOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_GetExternalAccountMappingsOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_GetExternalAccountMappingsOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Connect_GetExternalAccountMappingsOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_GetExternalAccountMappingsOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_GetExternalAccountMappingsOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_GetExternalAccountMappingsOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_GetExternalAccountMappingsOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccountIdType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_GetExternalAccountMappingsOptions),
            "::",
            stringify!(AccountIdType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetExternalUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_GetExternalAccountMappingsOptions),
            "::",
            stringify!(TargetExternalUserId)
        )
    );
}
pub type EOS_Connect_GetExternalAccountMappingsOptions =
    _tagEOS_Connect_GetExternalAccountMappingsOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_QueryProductUserIdMappingsOptions {
    #[doc = " API Version: Set this to EOS_CONNECT_QUERYPRODUCTUSERIDMAPPINGS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Game Clients set this field to the Product User ID of the local authenticated user querying account mappings.\n Game Servers set this field to NULL. Usage is allowed given that the configured client policy for server credentials permit it."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Deprecated - all external mappings are included in this call, it is no longer necessary to specify this value."]
    pub AccountIdType_DEPRECATED: EOS_EExternalAccountType,
    #[doc = " An array of Product User IDs to query for the given external account representation."]
    pub ProductUserIds: *mut EOS_ProductUserId,
    #[doc = " Number of Product User IDs to query."]
    pub ProductUserIdCount: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_QueryProductUserIdMappingsOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_QueryProductUserIdMappingsOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_QueryProductUserIdMappingsOptions>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Connect_QueryProductUserIdMappingsOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_QueryProductUserIdMappingsOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_QueryProductUserIdMappingsOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_QueryProductUserIdMappingsOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_QueryProductUserIdMappingsOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccountIdType_DEPRECATED) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_QueryProductUserIdMappingsOptions),
            "::",
            stringify!(AccountIdType_DEPRECATED)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProductUserIds) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_QueryProductUserIdMappingsOptions),
            "::",
            stringify!(ProductUserIds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProductUserIdCount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_QueryProductUserIdMappingsOptions),
            "::",
            stringify!(ProductUserIdCount)
        )
    );
}
pub type EOS_Connect_QueryProductUserIdMappingsOptions =
    _tagEOS_Connect_QueryProductUserIdMappingsOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_QueryProductUserIdMappingsCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Connect_QueryProductUserIdMappings."]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The local Product User ID that was passed with the input options."]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_QueryProductUserIdMappingsCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_QueryProductUserIdMappingsCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_QueryProductUserIdMappingsCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Connect_QueryProductUserIdMappingsCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_QueryProductUserIdMappingsCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_QueryProductUserIdMappingsCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_QueryProductUserIdMappingsCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_QueryProductUserIdMappingsCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_QueryProductUserIdMappingsCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Connect_QueryProductUserIdMappingsCallbackInfo =
    _tagEOS_Connect_QueryProductUserIdMappingsCallbackInfo;
pub type EOS_Connect_OnQueryProductUserIdMappingsCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Connect_QueryProductUserIdMappingsCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_GetProductUserIdMappingOptions {
    #[doc = " API Version: Set this to EOS_CONNECT_GETPRODUCTUSERIDMAPPING_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the existing, logged-in user that is querying account mappings."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " External auth service mapping to retrieve."]
    pub AccountIdType: EOS_EExternalAccountType,
    #[doc = " The Product User ID of the user whose information is being requested."]
    pub TargetProductUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_GetProductUserIdMappingOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_GetProductUserIdMappingOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_GetProductUserIdMappingOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Connect_GetProductUserIdMappingOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_GetProductUserIdMappingOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_GetProductUserIdMappingOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_GetProductUserIdMappingOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_GetProductUserIdMappingOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccountIdType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_GetProductUserIdMappingOptions),
            "::",
            stringify!(AccountIdType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetProductUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_GetProductUserIdMappingOptions),
            "::",
            stringify!(TargetProductUserId)
        )
    );
}
pub type EOS_Connect_GetProductUserIdMappingOptions =
    _tagEOS_Connect_GetProductUserIdMappingOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_GetProductUserExternalAccountCountOptions {
    #[doc = " API Version: Set this to EOS_CONNECT_GETPRODUCTUSEREXTERNALACCOUNTCOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID to look for when getting external account info count from the cache."]
    pub TargetUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_GetProductUserExternalAccountCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Connect_GetProductUserExternalAccountCountOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_GetProductUserExternalAccountCountOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Connect_GetProductUserExternalAccountCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_GetProductUserExternalAccountCountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_GetProductUserExternalAccountCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_GetProductUserExternalAccountCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_GetProductUserExternalAccountCountOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Connect_GetProductUserExternalAccountCountOptions =
    _tagEOS_Connect_GetProductUserExternalAccountCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_CopyProductUserExternalAccountByIndexOptions {
    #[doc = " API Version: Set this to EOS_CONNECT_COPYPRODUCTUSEREXTERNALACCOUNTBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID to look for when copying external account info from the cache."]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " Index of the external account info to retrieve from the cache."]
    pub ExternalAccountInfoIndex: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_CopyProductUserExternalAccountByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Connect_CopyProductUserExternalAccountByIndexOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_CopyProductUserExternalAccountByIndexOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Connect_CopyProductUserExternalAccountByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_CopyProductUserExternalAccountByIndexOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_CopyProductUserExternalAccountByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_CopyProductUserExternalAccountByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_CopyProductUserExternalAccountByIndexOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExternalAccountInfoIndex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_CopyProductUserExternalAccountByIndexOptions),
            "::",
            stringify!(ExternalAccountInfoIndex)
        )
    );
}
pub type EOS_Connect_CopyProductUserExternalAccountByIndexOptions =
    _tagEOS_Connect_CopyProductUserExternalAccountByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_CopyProductUserExternalAccountByAccountTypeOptions {
    #[doc = " API Version: Set this to EOS_CONNECT_COPYPRODUCTUSEREXTERNALACCOUNTBYACCOUNTTYPE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID to look for when copying external account info from the cache."]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " External auth service account type to look for when copying external account info from the cache."]
    pub AccountIdType: EOS_EExternalAccountType,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_CopyProductUserExternalAccountByAccountTypeOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Connect_CopyProductUserExternalAccountByAccountTypeOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_CopyProductUserExternalAccountByAccountTypeOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Connect_CopyProductUserExternalAccountByAccountTypeOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_CopyProductUserExternalAccountByAccountTypeOptions>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_CopyProductUserExternalAccountByAccountTypeOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_CopyProductUserExternalAccountByAccountTypeOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_CopyProductUserExternalAccountByAccountTypeOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccountIdType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_CopyProductUserExternalAccountByAccountTypeOptions),
            "::",
            stringify!(AccountIdType)
        )
    );
}
pub type EOS_Connect_CopyProductUserExternalAccountByAccountTypeOptions =
    _tagEOS_Connect_CopyProductUserExternalAccountByAccountTypeOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_CopyProductUserExternalAccountByAccountIdOptions {
    #[doc = " API Version: Set this to EOS_CONNECT_COPYPRODUCTUSEREXTERNALACCOUNTBYACCOUNTID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID to look for when copying external account info from the cache."]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " External auth service account ID to look for when copying external account info from the cache."]
    pub AccountId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_CopyProductUserExternalAccountByAccountIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Connect_CopyProductUserExternalAccountByAccountIdOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_CopyProductUserExternalAccountByAccountIdOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Connect_CopyProductUserExternalAccountByAccountIdOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_CopyProductUserExternalAccountByAccountIdOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_CopyProductUserExternalAccountByAccountIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_CopyProductUserExternalAccountByAccountIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_CopyProductUserExternalAccountByAccountIdOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccountId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_CopyProductUserExternalAccountByAccountIdOptions),
            "::",
            stringify!(AccountId)
        )
    );
}
pub type EOS_Connect_CopyProductUserExternalAccountByAccountIdOptions =
    _tagEOS_Connect_CopyProductUserExternalAccountByAccountIdOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_CopyProductUserInfoOptions {
    #[doc = " API Version: Set this to EOS_CONNECT_COPYPRODUCTUSERINFO_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Product user ID to look for when copying external account info from the cache."]
    pub TargetUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_CopyProductUserInfoOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_CopyProductUserInfoOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_CopyProductUserInfoOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Connect_CopyProductUserInfoOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_CopyProductUserInfoOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_CopyProductUserInfoOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_CopyProductUserInfoOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_CopyProductUserInfoOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Connect_CopyProductUserInfoOptions = _tagEOS_Connect_CopyProductUserInfoOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_ExternalAccountInfo {
    #[doc = " API Version: Set this to EOS_CONNECT_EXTERNALACCOUNTINFO_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the target user."]
    pub ProductUserId: EOS_ProductUserId,
    #[doc = " Display name, can be null if not set."]
    pub DisplayName: *const ::std::os::raw::c_char,
    #[doc = " External account ID.\n\n May be set to an empty string if the AccountIdType of another user belongs\n to different account system than the local user's authenticated account.\n The availability of this field is dependent on account system specifics."]
    pub AccountId: *const ::std::os::raw::c_char,
    #[doc = " The identity provider that owns the external account."]
    pub AccountIdType: EOS_EExternalAccountType,
    #[doc = " The POSIX timestamp for the time the user last logged in, or EOS_CONNECT_TIME_UNDEFINED."]
    pub LastLoginTime: i64,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_ExternalAccountInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_ExternalAccountInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_ExternalAccountInfo>(),
        48usize,
        concat!("Size of: ", stringify!(_tagEOS_Connect_ExternalAccountInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_ExternalAccountInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_ExternalAccountInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_ExternalAccountInfo),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProductUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_ExternalAccountInfo),
            "::",
            stringify!(ProductUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisplayName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_ExternalAccountInfo),
            "::",
            stringify!(DisplayName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccountId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_ExternalAccountInfo),
            "::",
            stringify!(AccountId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccountIdType) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_ExternalAccountInfo),
            "::",
            stringify!(AccountIdType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastLoginTime) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_ExternalAccountInfo),
            "::",
            stringify!(LastLoginTime)
        )
    );
}
pub type EOS_Connect_ExternalAccountInfo = _tagEOS_Connect_ExternalAccountInfo;
extern "C" {
    #[doc = " Release the memory associated with an external account info. This must be called on data retrieved from\n EOS_Connect_CopyProductUserExternalAccountByIndex, EOS_Connect_CopyProductUserExternalAccountByAccountType,\n EOS_Connect_CopyProductUserExternalAccountByAccountId or EOS_Connect_CopyProductUserInfo.\n\n @param ExternalAccountInfo The external account info data to release.\n\n @see EOS_Connect_CopyProductUserExternalAccountByIndex\n @see EOS_Connect_CopyProductUserExternalAccountByAccountType\n @see EOS_Connect_CopyProductUserExternalAccountByAccountId\n @see EOS_Connect_CopyProductUserInfo"]
    pub fn EOS_Connect_ExternalAccountInfo_Release(
        ExternalAccountInfo: *mut EOS_Connect_ExternalAccountInfo,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_AddNotifyAuthExpirationOptions {
    #[doc = " API Version: Set this to EOS_CONNECT_ADDNOTIFYAUTHEXPIRATION_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_AddNotifyAuthExpirationOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_AddNotifyAuthExpirationOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_AddNotifyAuthExpirationOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Connect_AddNotifyAuthExpirationOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_AddNotifyAuthExpirationOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_AddNotifyAuthExpirationOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_AddNotifyAuthExpirationOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Connect_AddNotifyAuthExpirationOptions =
    _tagEOS_Connect_AddNotifyAuthExpirationOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_AuthExpirationCallbackInfo {
    #[doc = " Context that was passed into EOS_Connect_AddNotifyAuthExpiration."]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the local player whose status has changed."]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_AuthExpirationCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_AuthExpirationCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_AuthExpirationCallbackInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Connect_AuthExpirationCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_AuthExpirationCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_AuthExpirationCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_AuthExpirationCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_AuthExpirationCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Connect_AuthExpirationCallbackInfo = _tagEOS_Connect_AuthExpirationCallbackInfo;
pub type EOS_Connect_OnAuthExpirationCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Connect_AuthExpirationCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_AddNotifyLoginStatusChangedOptions {
    #[doc = " API Version: Set this to EOS_CONNECT_ADDNOTIFYLOGINSTATUSCHANGED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_AddNotifyLoginStatusChangedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_AddNotifyLoginStatusChangedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_AddNotifyLoginStatusChangedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Connect_AddNotifyLoginStatusChangedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_AddNotifyLoginStatusChangedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_AddNotifyLoginStatusChangedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_AddNotifyLoginStatusChangedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Connect_AddNotifyLoginStatusChangedOptions =
    _tagEOS_Connect_AddNotifyLoginStatusChangedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_LoginStatusChangedCallbackInfo {
    #[doc = " Context that was passed into EOS_Connect_AddNotifyLoginStatusChanged."]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the local player whose status has changed."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The status prior to the change."]
    pub PreviousStatus: EOS_ELoginStatus,
    #[doc = " The status at the time of the notification."]
    pub CurrentStatus: EOS_ELoginStatus,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_LoginStatusChangedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_LoginStatusChangedCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_LoginStatusChangedCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Connect_LoginStatusChangedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_LoginStatusChangedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_LoginStatusChangedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_LoginStatusChangedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_LoginStatusChangedCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PreviousStatus) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_LoginStatusChangedCallbackInfo),
            "::",
            stringify!(PreviousStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurrentStatus) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_LoginStatusChangedCallbackInfo),
            "::",
            stringify!(CurrentStatus)
        )
    );
}
pub type EOS_Connect_LoginStatusChangedCallbackInfo =
    _tagEOS_Connect_LoginStatusChangedCallbackInfo;
pub type EOS_Connect_OnLoginStatusChangedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Connect_LoginStatusChangedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_IdToken {
    #[doc = " API Version: Set this to EOS_CONNECT_IDTOKEN_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID described by the ID token.\n Use EOS_ProductUserId_FromString to populate this field when validating a received ID token."]
    pub ProductUserId: EOS_ProductUserId,
    #[doc = " The ID token as a Json Web Token (JWT) string."]
    pub JsonWebToken: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_IdToken() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_IdToken> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_IdToken>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Connect_IdToken))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_IdToken>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Connect_IdToken))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_IdToken),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProductUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_IdToken),
            "::",
            stringify!(ProductUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).JsonWebToken) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_IdToken),
            "::",
            stringify!(JsonWebToken)
        )
    );
}
pub type EOS_Connect_IdToken = _tagEOS_Connect_IdToken;
extern "C" {
    #[doc = " Release the memory associated with an EOS_Connect_IdToken structure. This must be called on data retrieved from EOS_Connect_CopyIdToken.\n\n @param IdToken The ID token structure to be released.\n\n @see EOS_Connect_IdToken\n @see EOS_Connect_CopyIdToken"]
    pub fn EOS_Connect_IdToken_Release(IdToken: *mut EOS_Connect_IdToken);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_CopyIdTokenOptions {
    #[doc = " API Version: Set this to EOS_CONNECT_COPYIDTOKEN_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The local Product User ID whose ID token should be copied."]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_CopyIdTokenOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_CopyIdTokenOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_CopyIdTokenOptions>(),
        16usize,
        concat!("Size of: ", stringify!(_tagEOS_Connect_CopyIdTokenOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_CopyIdTokenOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_CopyIdTokenOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_CopyIdTokenOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_CopyIdTokenOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Connect_CopyIdTokenOptions = _tagEOS_Connect_CopyIdTokenOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_VerifyIdTokenOptions {
    #[doc = " API Version: Set this to EOS_CONNECT_VERIFYIDTOKEN_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The ID token to verify.\n Use EOS_ProductUserId_FromString to populate the ProductUserId field of this struct."]
    pub IdToken: *const EOS_Connect_IdToken,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_VerifyIdTokenOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_VerifyIdTokenOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_VerifyIdTokenOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Connect_VerifyIdTokenOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_VerifyIdTokenOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_VerifyIdTokenOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_VerifyIdTokenOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IdToken) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_VerifyIdTokenOptions),
            "::",
            stringify!(IdToken)
        )
    );
}
pub type EOS_Connect_VerifyIdTokenOptions = _tagEOS_Connect_VerifyIdTokenOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Connect_VerifyIdTokenCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Connect_VerifyIdToken"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID associated with the ID token."]
    pub ProductUserId: EOS_ProductUserId,
    #[doc = " Flag set to indicate whether account information is available.\n Applications must always first check this value to be set before attempting\n to read the AccountType, AccountId, Platform and DeviceType fields.\n\n This flag is always false for users that authenticated using EOS Connect Device ID."]
    pub bIsAccountInfoPresent: EOS_Bool,
    #[doc = " The identity provider that the user authenticated with to EOS Connect.\n\n If bIsAccountInfoPresent is set, this field describes the external account type."]
    pub AccountIdType: EOS_EExternalAccountType,
    #[doc = " The external account ID of the authenticated user.\n\n This value may be set to an empty string."]
    pub AccountId: *const ::std::os::raw::c_char,
    #[doc = " Platform that the user is connected from.\n\n This value may be set to an empty string."]
    pub Platform: *const ::std::os::raw::c_char,
    #[doc = " Identifies the device type that the user is connected from.\n Can be used to securely verify that the user is connected through a real Console device.\n\n This value may be set to an empty string."]
    pub DeviceType: *const ::std::os::raw::c_char,
    #[doc = " Client ID of the authorized client."]
    pub ClientId: *const ::std::os::raw::c_char,
    #[doc = " Product ID."]
    pub ProductId: *const ::std::os::raw::c_char,
    #[doc = " Sandbox ID."]
    pub SandboxId: *const ::std::os::raw::c_char,
    #[doc = " Deployment ID."]
    pub DeploymentId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Connect_VerifyIdTokenCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Connect_VerifyIdTokenCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Connect_VerifyIdTokenCallbackInfo>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Connect_VerifyIdTokenCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Connect_VerifyIdTokenCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Connect_VerifyIdTokenCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_VerifyIdTokenCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_VerifyIdTokenCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProductUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_VerifyIdTokenCallbackInfo),
            "::",
            stringify!(ProductUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsAccountInfoPresent) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_VerifyIdTokenCallbackInfo),
            "::",
            stringify!(bIsAccountInfoPresent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccountIdType) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_VerifyIdTokenCallbackInfo),
            "::",
            stringify!(AccountIdType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccountId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_VerifyIdTokenCallbackInfo),
            "::",
            stringify!(AccountId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Platform) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_VerifyIdTokenCallbackInfo),
            "::",
            stringify!(Platform)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DeviceType) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_VerifyIdTokenCallbackInfo),
            "::",
            stringify!(DeviceType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientId) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_VerifyIdTokenCallbackInfo),
            "::",
            stringify!(ClientId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProductId) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_VerifyIdTokenCallbackInfo),
            "::",
            stringify!(ProductId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SandboxId) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_VerifyIdTokenCallbackInfo),
            "::",
            stringify!(SandboxId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DeploymentId) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Connect_VerifyIdTokenCallbackInfo),
            "::",
            stringify!(DeploymentId)
        )
    );
}
pub type EOS_Connect_VerifyIdTokenCallbackInfo = _tagEOS_Connect_VerifyIdTokenCallbackInfo;
pub type EOS_Connect_OnVerifyIdTokenCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Connect_VerifyIdTokenCallbackInfo)>;
extern "C" {
    #[doc = " Login/Authenticate given a valid set of external auth credentials.\n\n @param Options structure containing the external account credentials and type to use during the login operation.\n @param ClientData arbitrary data that is passed back to you in the CompletionDelegate.\n @param CompletionDelegate a callback that is fired when the login operation completes, either successfully or in error."]
    pub fn EOS_Connect_Login(
        Handle: EOS_HConnect,
        Options: *const EOS_Connect_LoginOptions,
        ClientData: *mut ::std::os::raw::c_void,
        CompletionDelegate: EOS_Connect_OnLoginCallback,
    );
}
extern "C" {
    #[doc = " Create an account association with the Epic Online Service as a product user given their external auth credentials.\n\n @param Options structure containing a continuance token from a \"user not found\" response during Login (always try login first).\n @param ClientData arbitrary data that is passed back to you in the CompletionDelegate.\n @param CompletionDelegate a callback that is fired when the create operation completes, either successfully or in error."]
    pub fn EOS_Connect_CreateUser(
        Handle: EOS_HConnect,
        Options: *const EOS_Connect_CreateUserOptions,
        ClientData: *mut ::std::os::raw::c_void,
        CompletionDelegate: EOS_Connect_OnCreateUserCallback,
    );
}
extern "C" {
    #[doc = " Link a set of external auth credentials with an existing product user on the Epic Online Service.\n\n @param Options structure containing a continuance token from a \"user not found\" response during Login (always try login first) and a currently logged in user not already associated with this external auth provider.\n @param ClientData arbitrary data that is passed back to you in the CompletionDelegate.\n @param CompletionDelegate a callback that is fired when the link operation completes, either successfully or in error."]
    pub fn EOS_Connect_LinkAccount(
        Handle: EOS_HConnect,
        Options: *const EOS_Connect_LinkAccountOptions,
        ClientData: *mut ::std::os::raw::c_void,
        CompletionDelegate: EOS_Connect_OnLinkAccountCallback,
    );
}
extern "C" {
    #[doc = " Unlink external auth credentials from the owning keychain of a logged in product user.\n\n This function allows recovering the user from scenarios where they have accidentally proceeded to creating\n a new product user for the local native user account, instead of linking it with an existing keychain that\n they have previously created by playing the game (or another game owned by the organization) on another platform.\n\n In such scenario, after the initial platform login and a new product user creation, the user wishes to re-login\n using other set of external auth credentials to connect with their existing game progression data. In order to\n allow automatic login also on the current platform, they will need to unlink the accidentally created new keychain\n and product user and then use the EOS_Connect_Login and EOS_Connect_LinkAccount APIs to link the local native platform\n account with that previously created existing product user and its owning keychain.\n\n In another scenario, the user may simply want to disassociate the account that they have logged in with from the current\n keychain that it is linked with, perhaps to link it against another keychain or to separate the game progressions again.\n\n In order to protect against account theft, it is only possible to unlink user accounts that have been authenticated\n and logged in to the product user in the current session. This prevents a malicious actor from gaining access to one\n of the linked accounts and using it to remove all other accounts linked with the keychain. This also prevents a malicious\n actor from replacing the unlinked account with their own corresponding account on the same platform, as the unlinking\n operation will ensure that any existing authentication session cannot be used to re-link and overwrite the entry without\n authenticating with one of the other linked accounts in the keychain. These restrictions limit the potential attack surface\n related to account theft scenarios.\n\n @param Options structure containing operation input parameters.\n @param ClientData arbitrary data that is passed back to you in the CompletionDelegate.\n @param CompletionDelegate a callback that is fired when the unlink operation completes, either successfully or in error."]
    pub fn EOS_Connect_UnlinkAccount(
        Handle: EOS_HConnect,
        Options: *const EOS_Connect_UnlinkAccountOptions,
        ClientData: *mut ::std::os::raw::c_void,
        CompletionDelegate: EOS_Connect_OnUnlinkAccountCallback,
    );
}
extern "C" {
    #[doc = " Create a new unique pseudo-account that can be used to identify the current user profile on the local device.\n\n This function is intended to be used by mobile games and PC games that wish to allow\n a new user to start playing without requiring to login to the game using any user identity.\n In addition to this, the Device ID feature is used to automatically login the local user\n also when they have linked at least one external user account(s) with the local Device ID.\n\n It is possible to link many devices with the same user's account keyring using the Device ID feature.\n\n Linking a device later or immediately with a real user account will ensure that the player\n will not lose their progress if they switch devices or lose the device at some point,\n as they will be always able to login with one of their linked real accounts and also link\n another new device with the user account associations keychain. Otherwise, without having\n at least one permanent user account linked to the Device ID, the player would lose all of their\n game data and progression permanently should something happen to their device or the local\n user profile on the device.\n\n After a successful one-time CreateDeviceId operation, the game can login the local user\n automatically on subsequent game starts with EOS_Connect_Login using the EOS_ECT_DEVICEID_ACCESS_TOKEN\n credentials type. If a Device ID already exists for the local user on the device then EOS_DuplicateNotAllowed\n error result is returned and the caller should proceed to calling EOS_Connect_Login directly.\n\n @param Options structure containing operation input parameters.\n @param ClientData arbitrary data that is passed back to you in the CompletionDelegate.\n @param CompletionDelegate a callback that is fired when the create operation completes, either successfully or in error."]
    pub fn EOS_Connect_CreateDeviceId(
        Handle: EOS_HConnect,
        Options: *const EOS_Connect_CreateDeviceIdOptions,
        ClientData: *mut ::std::os::raw::c_void,
        CompletionDelegate: EOS_Connect_OnCreateDeviceIdCallback,
    );
}
extern "C" {
    #[doc = " Delete any existing Device ID access credentials for the current user profile on the local device.\n\n The deletion is permanent and it is not possible to recover lost game data and progression\n if the Device ID had not been linked with at least one real external user account.\n\n On Android and iOS devices, uninstalling the application will automatically delete any local\n Device ID credentials created by the application.\n\n On Desktop platforms (Linux, macOS, Windows), Device ID credentials are not automatically deleted.\n Applications may re-use existing Device ID credentials for the local OS user when the application is\n re-installed, or call the DeleteDeviceId API on the first run to ensure a fresh start for the user.\n\n @param Options structure containing operation input parameters\n @param ClientData arbitrary data that is passed back to you in the CompletionDelegate\n @param CompletionDelegate a callback that is fired when the delete operation completes, either successfully or in error"]
    pub fn EOS_Connect_DeleteDeviceId(
        Handle: EOS_HConnect,
        Options: *const EOS_Connect_DeleteDeviceIdOptions,
        ClientData: *mut ::std::os::raw::c_void,
        CompletionDelegate: EOS_Connect_OnDeleteDeviceIdCallback,
    );
}
extern "C" {
    #[doc = " Transfer a Device ID pseudo-account and the product user associated with it into another\n keychain linked with real user accounts (such as Epic Games, PlayStation(TM)Network, Xbox Live, and other).\n\n This function allows transferring a product user, i.e. the local user's game progression\n backend data from a Device ID owned keychain into a keychain with real user accounts\n linked to it. The transfer of Device ID owned product user into a keychain of real user\n accounts allows persisting the user's game data on the backend in the event that they\n would lose access to the local device or otherwise switch to another device or platform.\n\n This function is only applicable in the situation of where the local user first plays\n the game using the anonymous Device ID login, then later logs in using a real user\n account that they have also already used to play the same game or another game under the\n same organization within Epic Online Services. In such situation, while normally the login\n attempt with a real user account would return EOS_InvalidUser and an EOS_ContinuanceToken\n and allow calling the EOS_Connect_LinkAccount API to link it with the Device ID's keychain,\n instead the login operation succeeds and finds an existing user because the association\n already exists. Because the user cannot have two product users simultaneously to play with,\n the game should prompt the user to choose which profile to keep and which one to discard\n permanently. Based on the user choice, the game may then proceed to transfer the Device ID\n login into the keychain that is persistent and backed by real user accounts, and if the user\n chooses so, move the product user as well into the destination keychain and overwrite the\n existing previous product user with it. To clarify, moving the product user with the Device ID\n login in this way into a persisted keychain allows to preserve the so far only locally persisted\n game progression and thus protect the user against a case where they lose access to the device.\n\n On success, the completion callback will return the preserved EOS_ProductUserId that remains\n logged in while the discarded EOS_ProductUserId has been invalidated and deleted permanently.\n Consecutive logins using the existing Device ID login type or the external account will\n connect the user to the same backend data belonging to the preserved EOS_ProductUserId.\n\n Example walkthrough: Cross-platform mobile game using the anonymous Device ID login.\n\n For onboarding new users, the game will attempt to always automatically login the local user\n by calling EOS_Connect_Login using the EOS_ECT_DEVICEID_ACCESS_TOKEN login type. If the local\n Device ID credentials are not found, and the game wants a frictionless entry for the first time\n user experience, the game will automatically call EOS_Connect_CreateDeviceId to create new\n Device ID pseudo-account and then login the local user into it. Consecutive game starts will\n thus automatically login the user to their locally persisted Device ID account.\n\n The user starts playing anonymously using the Device ID login type and makes significant game progress.\n Later, they login using an external account that they have already used previously for the\n same game perhaps on another platform, or another game owned by the same organization.\n In such case, EOS_Connect_Login will automatically login the user to their existing account\n linking keychain and create automatically a new empty product user for this product.\n\n In order for the user to use their existing previously created keychain and have the locally\n created Device ID login reference to that keychain instead, the user's current product user\n needs to be moved to be under that keychain so that their existing game progression will be\n preserved. To do so, the game can call EOS_Connect_TransferDeviceIdAccount to transfer the\n Device ID login and the product user associated with it into the other keychain that has real\n external user account(s) linked to it. Note that it is important that the game either automatically\n checks that the other product user does not have any meaningful progression data, or otherwise\n will prompt the user to make the choice on which game progression to preserve and which can\n be discarded permanently. The other product user will be discarded permanently and cannot be\n recovered, so it is very important that the user is guided to make the right choice to avoid\n accidental loss of all game progression.\n\n @see EOS_Connect_Login\n @see EOS_Connect_CreateDeviceId\n\n @param Options structure containing the logged in product users and specifying which one will be preserved.\n @param ClientData arbitrary data that is passed back to you in the CompletionDelegate.\n @param CompletionDelegate a callback that is fired when the transfer operation completes, either successfully or in error."]
    pub fn EOS_Connect_TransferDeviceIdAccount(
        Handle: EOS_HConnect,
        Options: *const EOS_Connect_TransferDeviceIdAccountOptions,
        ClientData: *mut ::std::os::raw::c_void,
        CompletionDelegate: EOS_Connect_OnTransferDeviceIdAccountCallback,
    );
}
extern "C" {
    #[doc = " Retrieve the equivalent Product User IDs from a list of external account IDs from supported account providers.\n The values will be cached and retrievable through EOS_Connect_GetExternalAccountMapping.\n\n @note A common use case is to query other users who are connected through the same account system as the local user.\n Queries using external account IDs of another account system may not be available, depending on the account system specifics.\n\n @param Options structure containing a list of external account IDs, in string form, to query for the Product User ID representation.\n @param ClientData arbitrary data that is passed back to you in the CompletionDelegate.\n @param CompletionDelegate a callback that is fired when the query operation completes, either successfully or in error."]
    pub fn EOS_Connect_QueryExternalAccountMappings(
        Handle: EOS_HConnect,
        Options: *const EOS_Connect_QueryExternalAccountMappingsOptions,
        ClientData: *mut ::std::os::raw::c_void,
        CompletionDelegate: EOS_Connect_OnQueryExternalAccountMappingsCallback,
    );
}
extern "C" {
    #[doc = " Retrieve the equivalent external account mappings from a list of Product User IDs.\n\n The values will be cached and retrievable via EOS_Connect_GetProductUserIdMapping, EOS_Connect_CopyProductUserExternalAccountByIndex,\n EOS_Connect_CopyProductUserExternalAccountByAccountType or EOS_Connect_CopyProductUserExternalAccountByAccountId.\n\n @see EOS_Connect_ExternalAccountInfo\n @see EOS_Connect_GetProductUserExternalAccountCount\n @see EOS_Connect_GetProductUserIdMapping\n @see EOS_Connect_CopyProductUserExternalAccountByIndex\n @see EOS_Connect_CopyProductUserExternalAccountByAccountType\n @see EOS_Connect_CopyProductUserExternalAccountByAccountId\n @see EOS_Connect_CopyProductUserInfo\n\n @param Options structure containing a list of Product User IDs to query for the external account representation.\n @param ClientData arbitrary data that is passed back to you in the CompletionDelegate.\n @param CompletionDelegate a callback that is fired when the query operation completes, either successfully or in error."]
    pub fn EOS_Connect_QueryProductUserIdMappings(
        Handle: EOS_HConnect,
        Options: *const EOS_Connect_QueryProductUserIdMappingsOptions,
        ClientData: *mut ::std::os::raw::c_void,
        CompletionDelegate: EOS_Connect_OnQueryProductUserIdMappingsCallback,
    );
}
extern "C" {
    #[doc = " Fetch a Product User ID that maps to an external account ID cached from a previous query.\n\n @param Options structure containing the local user and target external account ID.\n\n @return The Product User ID, previously retrieved from the backend service, for the given target external account."]
    pub fn EOS_Connect_GetExternalAccountMapping(
        Handle: EOS_HConnect,
        Options: *const EOS_Connect_GetExternalAccountMappingsOptions,
    ) -> EOS_ProductUserId;
}
extern "C" {
    #[doc = " Fetch an external account ID, in string form, that maps to a given Product User ID.\n\n @param Options structure containing the local user and target Product User ID.\n @param OutBuffer The buffer into which the external account ID data should be written. The buffer must be long enough to hold a string of EOS_CONNECT_EXTERNAL_ACCOUNT_ID_MAX_LENGTH.\n @param InOutBufferLength The size of the OutBuffer in characters.\n                          The input buffer should include enough space to be null-terminated.\n                          When the function returns, this parameter will be filled with the length of the string copied into OutBuffer.\n\n @return An EOS_EResult that indicates the external account ID was copied into the OutBuffer.\n         EOS_Success if the information is available and passed out in OutUserInfo.\n         EOS_InvalidParameters if you pass a null pointer for the out parameter.\n         EOS_NotFound if the mapping doesn't exist or hasn't been queried yet.\n         EOS_LimitExceeded if the OutBuffer is not large enough to receive the external account ID. InOutBufferLength contains the required minimum length to perform the operation successfully."]
    pub fn EOS_Connect_GetProductUserIdMapping(
        Handle: EOS_HConnect,
        Options: *const EOS_Connect_GetProductUserIdMappingOptions,
        OutBuffer: *mut ::std::os::raw::c_char,
        InOutBufferLength: *mut i32,
    ) -> EOS_EResult;
}
extern "C" {
    #[doc = " Fetch the number of linked external accounts for a Product User ID.\n\n @param Options The Options associated with retrieving the external account info count.\n\n @see EOS_Connect_CopyProductUserExternalAccountByIndex\n\n @return Number of external accounts or 0 otherwise."]
    pub fn EOS_Connect_GetProductUserExternalAccountCount(
        Handle: EOS_HConnect,
        Options: *const EOS_Connect_GetProductUserExternalAccountCountOptions,
    ) -> u32;
}
extern "C" {
    #[doc = " Fetch information about an external account linked to a Product User ID.\n On a successful call, the caller must release the returned structure using the EOS_Connect_ExternalAccountInfo_Release API.\n\n @param Options Structure containing the target index.\n @param OutExternalAccountInfo The external account info data for the user with given index.\n\n @see EOS_Connect_ExternalAccountInfo_Release\n\n @return An EOS_EResult that indicates the external account data was copied into the OutExternalAccountInfo.\n         EOS_Success if the information is available and passed out in OutExternalAccountInfo.\n         EOS_InvalidParameters if you pass a null pointer for the out parameter.\n         EOS_NotFound if the account data doesn't exist or hasn't been queried yet."]
    pub fn EOS_Connect_CopyProductUserExternalAccountByIndex(
        Handle: EOS_HConnect,
        Options: *const EOS_Connect_CopyProductUserExternalAccountByIndexOptions,
        OutExternalAccountInfo: *mut *mut EOS_Connect_ExternalAccountInfo,
    ) -> EOS_EResult;
}
extern "C" {
    #[doc = " Fetch information about an external account of a specific type linked to a Product User ID.\n On a successful call, the caller must release the returned structure using the EOS_Connect_ExternalAccountInfo_Release API.\n\n @param Options Structure containing the target external account type.\n @param OutExternalAccountInfo The external account info data for the user with given external account type.\n\n @see EOS_Connect_ExternalAccountInfo_Release\n\n @return An EOS_EResult that indicates the external account data was copied into the OutExternalAccountInfo.\n         EOS_Success if the information is available and passed out in OutExternalAccountInfo.\n         EOS_InvalidParameters if you pass a null pointer for the out parameter.\n         EOS_NotFound if the account data doesn't exist or hasn't been queried yet."]
    pub fn EOS_Connect_CopyProductUserExternalAccountByAccountType(
        Handle: EOS_HConnect,
        Options: *const EOS_Connect_CopyProductUserExternalAccountByAccountTypeOptions,
        OutExternalAccountInfo: *mut *mut EOS_Connect_ExternalAccountInfo,
    ) -> EOS_EResult;
}
extern "C" {
    #[doc = " Fetch information about an external account linked to a Product User ID.\n On a successful call, the caller must release the returned structure using the EOS_Connect_ExternalAccountInfo_Release API.\n\n @param Options Structure containing the target external account ID.\n @param OutExternalAccountInfo The external account info data for the user with given external account ID.\n\n @see EOS_Connect_ExternalAccountInfo_Release\n\n @return An EOS_EResult that indicates the external account data was copied into the OutExternalAccountInfo.\n         EOS_Success if the information is available and passed out in OutExternalAccountInfo.\n         EOS_InvalidParameters if you pass a null pointer for the out parameter.\n         EOS_NotFound if the account data doesn't exist or hasn't been queried yet."]
    pub fn EOS_Connect_CopyProductUserExternalAccountByAccountId(
        Handle: EOS_HConnect,
        Options: *const EOS_Connect_CopyProductUserExternalAccountByAccountIdOptions,
        OutExternalAccountInfo: *mut *mut EOS_Connect_ExternalAccountInfo,
    ) -> EOS_EResult;
}
extern "C" {
    #[doc = " Fetch information about a Product User, using the external account that they most recently logged in with as the reference.\n On a successful call, the caller must release the returned structure using the EOS_Connect_ExternalAccountInfo_Release API.\n\n @param Options Structure containing the target external account ID.\n @param OutExternalAccountInfo The external account info data last logged in for the user.\n\n @see EOS_Connect_ExternalAccountInfo_Release\n\n @return An EOS_EResult that indicates the external account data was copied into the OutExternalAccountInfo.\n         EOS_Success if the information is available and passed out in OutExternalAccountInfo.\n         EOS_InvalidParameters if you pass a null pointer for the out parameter.\n         EOS_NotFound if the account data doesn't exist or hasn't been queried yet."]
    pub fn EOS_Connect_CopyProductUserInfo(
        Handle: EOS_HConnect,
        Options: *const EOS_Connect_CopyProductUserInfoOptions,
        OutExternalAccountInfo: *mut *mut EOS_Connect_ExternalAccountInfo,
    ) -> EOS_EResult;
}
extern "C" {
    #[doc = " Fetch the number of product users that are logged in.\n\n @return the number of product users logged in."]
    pub fn EOS_Connect_GetLoggedInUsersCount(Handle: EOS_HConnect) -> i32;
}
extern "C" {
    #[doc = " Fetch a Product User ID that is logged in. This Product User ID is in the Epic Online Services namespace.\n\n @param Index an index into the list of logged in users. If the index is out of bounds, the returned Product User ID will be invalid.\n\n @return the Product User ID associated with the index passed."]
    pub fn EOS_Connect_GetLoggedInUserByIndex(
        Handle: EOS_HConnect,
        Index: i32,
    ) -> EOS_ProductUserId;
}
extern "C" {
    #[doc = " Fetches the login status for an Product User ID.  This Product User ID is considered logged in as long as the underlying access token has not expired.\n\n @param LocalUserId the Product User ID of the user being queried.\n\n @return the enum value of a user's login status."]
    pub fn EOS_Connect_GetLoginStatus(
        Handle: EOS_HConnect,
        LocalUserId: EOS_ProductUserId,
    ) -> EOS_ELoginStatus;
}
extern "C" {
    #[doc = " Register to receive upcoming authentication expiration notifications.\n Notification is approximately 10 minutes prior to expiration.\n Call EOS_Connect_Login again with valid third party credentials to refresh access.\n\n @note must call RemoveNotifyAuthExpiration to remove the notification.\n\n @param Options structure containing the API version of the callback to use.\n @param ClientData arbitrary data that is passed back to you in the callback.\n @param Notification a callback that is fired when the authentication is about to expire.\n\n @return handle representing the registered callback."]
    pub fn EOS_Connect_AddNotifyAuthExpiration(
        Handle: EOS_HConnect,
        Options: *const EOS_Connect_AddNotifyAuthExpirationOptions,
        ClientData: *mut ::std::os::raw::c_void,
        Notification: EOS_Connect_OnAuthExpirationCallback,
    ) -> EOS_NotificationId;
}
extern "C" {
    #[doc = " Unregister from receiving expiration notifications.\n\n @param InId handle representing the registered callback."]
    pub fn EOS_Connect_RemoveNotifyAuthExpiration(Handle: EOS_HConnect, InId: EOS_NotificationId);
}
extern "C" {
    #[doc = " Register to receive user login status updates.\n @note must call RemoveNotifyLoginStatusChanged to remove the notification.\n\n @param Options structure containing the API version of the callback to use.\n @param ClientData arbitrary data that is passed back to you in the callback.\n @param Notification a callback that is fired when the login status for a user changes.\n\n @return handle representing the registered callback."]
    pub fn EOS_Connect_AddNotifyLoginStatusChanged(
        Handle: EOS_HConnect,
        Options: *const EOS_Connect_AddNotifyLoginStatusChangedOptions,
        ClientData: *mut ::std::os::raw::c_void,
        Notification: EOS_Connect_OnLoginStatusChangedCallback,
    ) -> EOS_NotificationId;
}
extern "C" {
    #[doc = " Unregister from receiving user login status updates.\n\n @param InId handle representing the registered callback."]
    pub fn EOS_Connect_RemoveNotifyLoginStatusChanged(
        Handle: EOS_HConnect,
        InId: EOS_NotificationId,
    );
}
extern "C" {
    #[doc = " Fetches an ID token for a Product User ID.\n\n @param Options Structure containing information about the ID token to copy.\n @param OutIdToken The ID token for the given user, if it exists and is valid; use EOS_Connect_IdToken_Release when finished.\n\n @see EOS_Connect_IdToken_Release\n\n @return EOS_Success if the information is available and passed out in OutIdToken.\n         EOS_InvalidParameters if you pass a null pointer for the out parameter.\n         EOS_NotFound if the ID token is not found or expired."]
    pub fn EOS_Connect_CopyIdToken(
        Handle: EOS_HConnect,
        Options: *const EOS_Connect_CopyIdTokenOptions,
        OutIdToken: *mut *mut EOS_Connect_IdToken,
    ) -> EOS_EResult;
}
extern "C" {
    #[doc = " Verify a given ID token for authenticity and validity.\n\n @param Options structure containing information about the ID token to verify.\n @param ClientData arbitrary data that is passed back to you in the callback.\n @param CompletionDelegate a callback that is fired when the operation completes, either successfully or in error."]
    pub fn EOS_Connect_VerifyIdToken(
        Handle: EOS_HConnect,
        Options: *const EOS_Connect_VerifyIdTokenOptions,
        ClientData: *mut ::std::os::raw::c_void,
        CompletionDelegate: EOS_Connect_OnVerifyIdTokenCallback,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_AchievementsHandle {
    _unused: [u8; 0],
}
pub type EOS_HAchievements = *mut EOS_AchievementsHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Achievements_QueryDefinitionsOptions {
    #[doc = " API Version: Set this to EOS_ACHIEVEMENTS_QUERYDEFINITIONS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Product User ID for user who is querying definitions.\n The localized text returned will be based on the locale code of the given user if they have a linked Epic Account ID.\n The localized text returned can also be overridden using EOS_Platform_SetOverrideLocaleCode to override the locale.\n If the locale code is not overridden and LocalUserId is not valid, default text will be returned."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Deprecated"]
    pub EpicUserId_DEPRECATED: EOS_EpicAccountId,
    #[doc = " Deprecated"]
    pub HiddenAchievementIds_DEPRECATED: *mut *const ::std::os::raw::c_char,
    #[doc = " Deprecated"]
    pub HiddenAchievementsCount_DEPRECATED: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Achievements_QueryDefinitionsOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Achievements_QueryDefinitionsOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Achievements_QueryDefinitionsOptions>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Achievements_QueryDefinitionsOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Achievements_QueryDefinitionsOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Achievements_QueryDefinitionsOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_QueryDefinitionsOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_QueryDefinitionsOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EpicUserId_DEPRECATED) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_QueryDefinitionsOptions),
            "::",
            stringify!(EpicUserId_DEPRECATED)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).HiddenAchievementIds_DEPRECATED) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_QueryDefinitionsOptions),
            "::",
            stringify!(HiddenAchievementIds_DEPRECATED)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).HiddenAchievementsCount_DEPRECATED) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_QueryDefinitionsOptions),
            "::",
            stringify!(HiddenAchievementsCount_DEPRECATED)
        )
    );
}
pub type EOS_Achievements_QueryDefinitionsOptions = _tagEOS_Achievements_QueryDefinitionsOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Achievements_StatThresholds {
    #[doc = " API Version: Set this to EOS_ACHIEVEMENTS_STATTHRESHOLDS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The name of the stat."]
    pub Name: *const ::std::os::raw::c_char,
    #[doc = " The value that the stat must surpass to satisfy the requirement for unlocking an achievement."]
    pub Threshold: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Achievements_StatThresholds() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Achievements_StatThresholds> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Achievements_StatThresholds>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Achievements_StatThresholds))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Achievements_StatThresholds>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Achievements_StatThresholds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_StatThresholds),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_StatThresholds),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Threshold) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_StatThresholds),
            "::",
            stringify!(Threshold)
        )
    );
}
pub type EOS_Achievements_StatThresholds = _tagEOS_Achievements_StatThresholds;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Achievements_PlayerStatInfo {
    #[doc = " API Version: Set this to EOS_ACHIEVEMENTS_PLAYERSTATINFO_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The name of the stat."]
    pub Name: *const ::std::os::raw::c_char,
    #[doc = " The current value of the stat."]
    pub CurrentValue: i32,
    #[doc = " The threshold value of the stat, used in determining when to unlock an achievement."]
    pub ThresholdValue: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Achievements_PlayerStatInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Achievements_PlayerStatInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Achievements_PlayerStatInfo>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Achievements_PlayerStatInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Achievements_PlayerStatInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Achievements_PlayerStatInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_PlayerStatInfo),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_PlayerStatInfo),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurrentValue) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_PlayerStatInfo),
            "::",
            stringify!(CurrentValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ThresholdValue) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_PlayerStatInfo),
            "::",
            stringify!(ThresholdValue)
        )
    );
}
pub type EOS_Achievements_PlayerStatInfo = _tagEOS_Achievements_PlayerStatInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Achievements_DefinitionV2 {
    #[doc = " API Version: Set this to EOS_ACHIEVEMENTS_DEFINITIONV2_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Achievement ID that can be used to uniquely identify the achievement."]
    pub AchievementId: *const ::std::os::raw::c_char,
    #[doc = " Localized display name for the achievement when it has been unlocked."]
    pub UnlockedDisplayName: *const ::std::os::raw::c_char,
    #[doc = " Localized description for the achievement when it has been unlocked."]
    pub UnlockedDescription: *const ::std::os::raw::c_char,
    #[doc = " Localized display name for the achievement when it is locked or hidden."]
    pub LockedDisplayName: *const ::std::os::raw::c_char,
    #[doc = " Localized description for the achievement when it is locked or hidden."]
    pub LockedDescription: *const ::std::os::raw::c_char,
    #[doc = " Localized flavor text that can be used by the game in an arbitrary manner. This may be null if there is no data configured in the dev portal."]
    pub FlavorText: *const ::std::os::raw::c_char,
    #[doc = " URL of an icon to display for the achievement when it is unlocked. This may be null if there is no data configured in the dev portal."]
    pub UnlockedIconURL: *const ::std::os::raw::c_char,
    #[doc = " URL of an icon to display for the achievement when it is locked or hidden. This may be null if there is no data configured in the dev portal."]
    pub LockedIconURL: *const ::std::os::raw::c_char,
    #[doc = " EOS_TRUE if the achievement is hidden; EOS_FALSE otherwise."]
    pub bIsHidden: EOS_Bool,
    #[doc = " The number of stat thresholds used to monitor progress towards this achievement."]
    pub StatThresholdsCount: u32,
    #[doc = " Array of `EOS_Achievements_StatThresholds` that need to be satisfied to unlock this achievement. Consists of Name and Threshold Value."]
    pub StatThresholds: *const EOS_Achievements_StatThresholds,
}
#[test]
fn bindgen_test_layout__tagEOS_Achievements_DefinitionV2() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Achievements_DefinitionV2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Achievements_DefinitionV2>(),
        88usize,
        concat!("Size of: ", stringify!(_tagEOS_Achievements_DefinitionV2))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Achievements_DefinitionV2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Achievements_DefinitionV2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_DefinitionV2),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AchievementId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_DefinitionV2),
            "::",
            stringify!(AchievementId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UnlockedDisplayName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_DefinitionV2),
            "::",
            stringify!(UnlockedDisplayName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UnlockedDescription) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_DefinitionV2),
            "::",
            stringify!(UnlockedDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LockedDisplayName) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_DefinitionV2),
            "::",
            stringify!(LockedDisplayName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LockedDescription) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_DefinitionV2),
            "::",
            stringify!(LockedDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FlavorText) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_DefinitionV2),
            "::",
            stringify!(FlavorText)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UnlockedIconURL) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_DefinitionV2),
            "::",
            stringify!(UnlockedIconURL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LockedIconURL) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_DefinitionV2),
            "::",
            stringify!(LockedIconURL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsHidden) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_DefinitionV2),
            "::",
            stringify!(bIsHidden)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatThresholdsCount) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_DefinitionV2),
            "::",
            stringify!(StatThresholdsCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatThresholds) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_DefinitionV2),
            "::",
            stringify!(StatThresholds)
        )
    );
}
pub type EOS_Achievements_DefinitionV2 = _tagEOS_Achievements_DefinitionV2;
extern "C" {
    #[doc = " Release the memory associated with EOS_Achievements_DefinitionV2. This must be called on data retrieved from\n EOS_Achievements_CopyAchievementDefinitionV2ByIndex or EOS_Achievements_CopyAchievementDefinitionV2ByAchievementId.\n\n @param AchievementDefinition - The achievement definition to release.\n\n @see EOS_Achievements_DefinitionV2\n @see EOS_Achievements_CopyAchievementDefinitionV2ByIndex\n @see EOS_Achievements_CopyAchievementDefinitionV2ByAchievementId"]
    pub fn EOS_Achievements_DefinitionV2_Release(
        AchievementDefinition: *mut EOS_Achievements_DefinitionV2,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Achievements_GetAchievementDefinitionCountOptions {
    #[doc = " API Version: Set this to EOS_ACHIEVEMENTS_GETACHIEVEMENTDEFINITIONCOUNT_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Achievements_GetAchievementDefinitionCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Achievements_GetAchievementDefinitionCountOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Achievements_GetAchievementDefinitionCountOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Achievements_GetAchievementDefinitionCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Achievements_GetAchievementDefinitionCountOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Achievements_GetAchievementDefinitionCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_GetAchievementDefinitionCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Achievements_GetAchievementDefinitionCountOptions =
    _tagEOS_Achievements_GetAchievementDefinitionCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Achievements_CopyAchievementDefinitionV2ByIndexOptions {
    #[doc = " API Version: Set this to EOS_ACHIEVEMENTS_COPYACHIEVEMENTDEFINITIONV2BYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Index of the achievement definition to retrieve from the cache."]
    pub AchievementIndex: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Achievements_CopyAchievementDefinitionV2ByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Achievements_CopyAchievementDefinitionV2ByIndexOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Achievements_CopyAchievementDefinitionV2ByIndexOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Achievements_CopyAchievementDefinitionV2ByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Achievements_CopyAchievementDefinitionV2ByIndexOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Achievements_CopyAchievementDefinitionV2ByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_CopyAchievementDefinitionV2ByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AchievementIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_CopyAchievementDefinitionV2ByIndexOptions),
            "::",
            stringify!(AchievementIndex)
        )
    );
}
pub type EOS_Achievements_CopyAchievementDefinitionV2ByIndexOptions =
    _tagEOS_Achievements_CopyAchievementDefinitionV2ByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Achievements_CopyAchievementDefinitionV2ByAchievementIdOptions {
    #[doc = " API Version: Set this to EOS_ACHIEVEMENTS_COPYACHIEVEMENTDEFINITIONV2BYACHIEVEMENTID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Achievement ID to look for when copying the definition from the cache."]
    pub AchievementId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Achievements_CopyAchievementDefinitionV2ByAchievementIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Achievements_CopyAchievementDefinitionV2ByAchievementIdOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Achievements_CopyAchievementDefinitionV2ByAchievementIdOptions>(
        ),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Achievements_CopyAchievementDefinitionV2ByAchievementIdOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _tagEOS_Achievements_CopyAchievementDefinitionV2ByAchievementIdOptions,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Achievements_CopyAchievementDefinitionV2ByAchievementIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_CopyAchievementDefinitionV2ByAchievementIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AchievementId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_CopyAchievementDefinitionV2ByAchievementIdOptions),
            "::",
            stringify!(AchievementId)
        )
    );
}
pub type EOS_Achievements_CopyAchievementDefinitionV2ByAchievementIdOptions =
    _tagEOS_Achievements_CopyAchievementDefinitionV2ByAchievementIdOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Achievements_OnQueryDefinitionsCompleteCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " User-defined context that was passed into EOS_Achievements_QueryDefinitions."]
    pub ClientData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_Achievements_OnQueryDefinitionsCompleteCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Achievements_OnQueryDefinitionsCompleteCallbackInfo,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Achievements_OnQueryDefinitionsCompleteCallbackInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Achievements_OnQueryDefinitionsCompleteCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Achievements_OnQueryDefinitionsCompleteCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Achievements_OnQueryDefinitionsCompleteCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_OnQueryDefinitionsCompleteCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_OnQueryDefinitionsCompleteCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
}
pub type EOS_Achievements_OnQueryDefinitionsCompleteCallbackInfo =
    _tagEOS_Achievements_OnQueryDefinitionsCompleteCallbackInfo;
pub type EOS_Achievements_OnQueryDefinitionsCompleteCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Achievements_OnQueryDefinitionsCompleteCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Achievements_QueryPlayerAchievementsOptions {
    #[doc = " API Version: Set this to EOS_ACHIEVEMENTS_QUERYPLAYERACHIEVEMENTS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID for the user whose achievements are to be retrieved."]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " The Product User ID for the user who is querying for player achievements. For a Dedicated Server this should be null."]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Achievements_QueryPlayerAchievementsOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Achievements_QueryPlayerAchievementsOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Achievements_QueryPlayerAchievementsOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Achievements_QueryPlayerAchievementsOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Achievements_QueryPlayerAchievementsOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Achievements_QueryPlayerAchievementsOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_QueryPlayerAchievementsOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_QueryPlayerAchievementsOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_QueryPlayerAchievementsOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Achievements_QueryPlayerAchievementsOptions =
    _tagEOS_Achievements_QueryPlayerAchievementsOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Achievements_PlayerAchievement {
    #[doc = " API Version: Set this to EOS_ACHIEVEMENTS_PLAYERACHIEVEMENT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " This achievement's unique identifier."]
    pub AchievementId: *const ::std::os::raw::c_char,
    #[doc = " Progress towards completing this achievement (as a percentage)."]
    pub Progress: f64,
    #[doc = " The POSIX timestamp when the achievement was unlocked. If the achievement has not been unlocked, this value will be EOS_ACHIEVEMENTS_ACHIEVEMENT_UNLOCKTIME_UNDEFINED."]
    pub UnlockTime: i64,
    #[doc = " The number of player stat info entries associated with this achievement."]
    pub StatInfoCount: i32,
    #[doc = " Array of EOS_Achievements_PlayerStatInfo structures containing information about stat thresholds used to unlock the achievement and the player's current values for those stats."]
    pub StatInfo: *const EOS_Achievements_PlayerStatInfo,
    #[doc = " Localized display name for the achievement based on this specific player's current progress on the achievement.\n @note The current progress is updated when EOS_Achievements_QueryPlayerAchievements succeeds and when an achievement is unlocked."]
    pub DisplayName: *const ::std::os::raw::c_char,
    #[doc = " Localized description for the achievement based on this specific player's current progress on the achievement.\n @note The current progress is updated when EOS_Achievements_QueryPlayerAchievements succeeds and when an achievement is unlocked."]
    pub Description: *const ::std::os::raw::c_char,
    #[doc = " URL of an icon to display for the achievement based on this specific player's current progress on the achievement. This may be null if there is no data configured in the dev portal.\n @note The current progress is updated when EOS_Achievements_QueryPlayerAchievements succeeds and when an achievement is unlocked."]
    pub IconURL: *const ::std::os::raw::c_char,
    #[doc = " Localized flavor text that can be used by the game in an arbitrary manner. This may be null if there is no data configured in the dev portal."]
    pub FlavorText: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Achievements_PlayerAchievement() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Achievements_PlayerAchievement> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Achievements_PlayerAchievement>(),
        80usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Achievements_PlayerAchievement)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Achievements_PlayerAchievement>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Achievements_PlayerAchievement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_PlayerAchievement),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AchievementId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_PlayerAchievement),
            "::",
            stringify!(AchievementId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Progress) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_PlayerAchievement),
            "::",
            stringify!(Progress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UnlockTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_PlayerAchievement),
            "::",
            stringify!(UnlockTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatInfoCount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_PlayerAchievement),
            "::",
            stringify!(StatInfoCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatInfo) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_PlayerAchievement),
            "::",
            stringify!(StatInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisplayName) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_PlayerAchievement),
            "::",
            stringify!(DisplayName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Description) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_PlayerAchievement),
            "::",
            stringify!(Description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IconURL) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_PlayerAchievement),
            "::",
            stringify!(IconURL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FlavorText) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_PlayerAchievement),
            "::",
            stringify!(FlavorText)
        )
    );
}
pub type EOS_Achievements_PlayerAchievement = _tagEOS_Achievements_PlayerAchievement;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Achievements_GetPlayerAchievementCountOptions {
    #[doc = " API Version: Set this to EOS_ACHIEVEMENTS_GETPLAYERACHIEVEMENTCOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID for the user whose achievement count is being retrieved."]
    pub UserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Achievements_GetPlayerAchievementCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Achievements_GetPlayerAchievementCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Achievements_GetPlayerAchievementCountOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Achievements_GetPlayerAchievementCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Achievements_GetPlayerAchievementCountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Achievements_GetPlayerAchievementCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_GetPlayerAchievementCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_GetPlayerAchievementCountOptions),
            "::",
            stringify!(UserId)
        )
    );
}
pub type EOS_Achievements_GetPlayerAchievementCountOptions =
    _tagEOS_Achievements_GetPlayerAchievementCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Achievements_CopyPlayerAchievementByIndexOptions {
    #[doc = " API Version: Set this to EOS_ACHIEVEMENTS_COPYPLAYERACHIEVEMENTBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID for the user whose achievement is to be retrieved."]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " The index of the player achievement data to retrieve from the cache."]
    pub AchievementIndex: u32,
    #[doc = " The Product User ID for the user who is querying for a player achievement. For a Dedicated Server this should be null."]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Achievements_CopyPlayerAchievementByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Achievements_CopyPlayerAchievementByIndexOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Achievements_CopyPlayerAchievementByIndexOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Achievements_CopyPlayerAchievementByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Achievements_CopyPlayerAchievementByIndexOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Achievements_CopyPlayerAchievementByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_CopyPlayerAchievementByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_CopyPlayerAchievementByIndexOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AchievementIndex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_CopyPlayerAchievementByIndexOptions),
            "::",
            stringify!(AchievementIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_CopyPlayerAchievementByIndexOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Achievements_CopyPlayerAchievementByIndexOptions =
    _tagEOS_Achievements_CopyPlayerAchievementByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Achievements_CopyPlayerAchievementByAchievementIdOptions {
    #[doc = " API Version: Set this to EOS_ACHIEVEMENTS_COPYPLAYERACHIEVEMENTBYACHIEVEMENTID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID for the user whose achievement is to be retrieved."]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " Achievement ID to search for when retrieving player achievement data from the cache."]
    pub AchievementId: *const ::std::os::raw::c_char,
    #[doc = " The Product User ID for the user who is querying for a player achievement. For a Dedicated Server this should be null."]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Achievements_CopyPlayerAchievementByAchievementIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Achievements_CopyPlayerAchievementByAchievementIdOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Achievements_CopyPlayerAchievementByAchievementIdOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Achievements_CopyPlayerAchievementByAchievementIdOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Achievements_CopyPlayerAchievementByAchievementIdOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Achievements_CopyPlayerAchievementByAchievementIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_CopyPlayerAchievementByAchievementIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_CopyPlayerAchievementByAchievementIdOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AchievementId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_CopyPlayerAchievementByAchievementIdOptions),
            "::",
            stringify!(AchievementId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_CopyPlayerAchievementByAchievementIdOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Achievements_CopyPlayerAchievementByAchievementIdOptions =
    _tagEOS_Achievements_CopyPlayerAchievementByAchievementIdOptions;
extern "C" {
    #[doc = " Release the memory associated with a player achievement. This must be called on data retrieved from\n EOS_Achievements_CopyPlayerAchievementByIndex or EOS_Achievements_CopyPlayerAchievementByAchievementId.\n\n @param Achievement - The achievement data to release.\n\n @see EOS_Achievements_PlayerAchievement\n @see EOS_Achievements_CopyPlayerAchievementByIndex\n @see EOS_Achievements_CopyPlayerAchievementByAchievementId"]
    pub fn EOS_Achievements_PlayerAchievement_Release(
        Achievement: *mut EOS_Achievements_PlayerAchievement,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Achievements_OnQueryPlayerAchievementsCompleteCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Achievements_QueryPlayerAchievements."]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the user who initiated this request."]
    pub UserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Achievements_OnQueryPlayerAchievementsCompleteCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Achievements_OnQueryPlayerAchievementsCompleteCallbackInfo,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Achievements_OnQueryPlayerAchievementsCompleteCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Achievements_OnQueryPlayerAchievementsCompleteCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Achievements_OnQueryPlayerAchievementsCompleteCallbackInfo>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Achievements_OnQueryPlayerAchievementsCompleteCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_OnQueryPlayerAchievementsCompleteCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_OnQueryPlayerAchievementsCompleteCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_OnQueryPlayerAchievementsCompleteCallbackInfo),
            "::",
            stringify!(UserId)
        )
    );
}
pub type EOS_Achievements_OnQueryPlayerAchievementsCompleteCallbackInfo =
    _tagEOS_Achievements_OnQueryPlayerAchievementsCompleteCallbackInfo;
pub type EOS_Achievements_OnQueryPlayerAchievementsCompleteCallback = ::std::option::Option<
    unsafe extern "C" fn(
        Data: *const EOS_Achievements_OnQueryPlayerAchievementsCompleteCallbackInfo,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Achievements_UnlockAchievementsOptions {
    #[doc = " API Version: Set this to EOS_ACHIEVEMENTS_UNLOCKACHIEVEMENTS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID for the user whose achievements we want to unlock."]
    pub UserId: EOS_ProductUserId,
    #[doc = " An array of Achievement IDs to unlock."]
    pub AchievementIds: *mut *const ::std::os::raw::c_char,
    #[doc = " The number of achievements to unlock."]
    pub AchievementsCount: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Achievements_UnlockAchievementsOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Achievements_UnlockAchievementsOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Achievements_UnlockAchievementsOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Achievements_UnlockAchievementsOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Achievements_UnlockAchievementsOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Achievements_UnlockAchievementsOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_UnlockAchievementsOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_UnlockAchievementsOptions),
            "::",
            stringify!(UserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AchievementIds) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_UnlockAchievementsOptions),
            "::",
            stringify!(AchievementIds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AchievementsCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_UnlockAchievementsOptions),
            "::",
            stringify!(AchievementsCount)
        )
    );
}
pub type EOS_Achievements_UnlockAchievementsOptions =
    _tagEOS_Achievements_UnlockAchievementsOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Achievements_OnUnlockAchievementsCompleteCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Achievements_UnlockAchievements."]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the user who initiated this request."]
    pub UserId: EOS_ProductUserId,
    #[doc = " The number of achievements that the operation unlocked."]
    pub AchievementsCount: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Achievements_OnUnlockAchievementsCompleteCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Achievements_OnUnlockAchievementsCompleteCallbackInfo,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Achievements_OnUnlockAchievementsCompleteCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Achievements_OnUnlockAchievementsCompleteCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Achievements_OnUnlockAchievementsCompleteCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Achievements_OnUnlockAchievementsCompleteCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_OnUnlockAchievementsCompleteCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_OnUnlockAchievementsCompleteCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_OnUnlockAchievementsCompleteCallbackInfo),
            "::",
            stringify!(UserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AchievementsCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_OnUnlockAchievementsCompleteCallbackInfo),
            "::",
            stringify!(AchievementsCount)
        )
    );
}
pub type EOS_Achievements_OnUnlockAchievementsCompleteCallbackInfo =
    _tagEOS_Achievements_OnUnlockAchievementsCompleteCallbackInfo;
pub type EOS_Achievements_OnUnlockAchievementsCompleteCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Achievements_OnUnlockAchievementsCompleteCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Achievements_AddNotifyAchievementsUnlockedV2Options {
    #[doc = " API Version: Set this to EOS_ACHIEVEMENTS_ADDNOTIFYACHIEVEMENTSUNLOCKEDV2_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Achievements_AddNotifyAchievementsUnlockedV2Options() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Achievements_AddNotifyAchievementsUnlockedV2Options,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Achievements_AddNotifyAchievementsUnlockedV2Options>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Achievements_AddNotifyAchievementsUnlockedV2Options)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Achievements_AddNotifyAchievementsUnlockedV2Options>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Achievements_AddNotifyAchievementsUnlockedV2Options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_AddNotifyAchievementsUnlockedV2Options),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Achievements_AddNotifyAchievementsUnlockedV2Options =
    _tagEOS_Achievements_AddNotifyAchievementsUnlockedV2Options;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Achievements_OnAchievementsUnlockedCallbackV2Info {
    #[doc = " Context that was passed into EOS_Achievements_AddNotifyAchievementsUnlocked"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID for the user who received the unlocked achievements notification"]
    pub UserId: EOS_ProductUserId,
    #[doc = " The Achievement ID for the achievement that was unlocked. Pass this to EOS_Achievements_CopyPlayerAchievementByAchievementId to get the full achievement information."]
    pub AchievementId: *const ::std::os::raw::c_char,
    #[doc = " POSIX timestamp when the achievement was unlocked."]
    pub UnlockTime: i64,
}
#[test]
fn bindgen_test_layout__tagEOS_Achievements_OnAchievementsUnlockedCallbackV2Info() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Achievements_OnAchievementsUnlockedCallbackV2Info,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Achievements_OnAchievementsUnlockedCallbackV2Info>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Achievements_OnAchievementsUnlockedCallbackV2Info)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Achievements_OnAchievementsUnlockedCallbackV2Info>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Achievements_OnAchievementsUnlockedCallbackV2Info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_OnAchievementsUnlockedCallbackV2Info),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_OnAchievementsUnlockedCallbackV2Info),
            "::",
            stringify!(UserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AchievementId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_OnAchievementsUnlockedCallbackV2Info),
            "::",
            stringify!(AchievementId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UnlockTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_OnAchievementsUnlockedCallbackV2Info),
            "::",
            stringify!(UnlockTime)
        )
    );
}
pub type EOS_Achievements_OnAchievementsUnlockedCallbackV2Info =
    _tagEOS_Achievements_OnAchievementsUnlockedCallbackV2Info;
pub type EOS_Achievements_OnAchievementsUnlockedCallbackV2 = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Achievements_OnAchievementsUnlockedCallbackV2Info),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Achievements_Definition {
    #[doc = " API Version: Set this to EOS_ACHIEVEMENTS_DEFINITION_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Achievement ID that can be used to uniquely identify the achievement."]
    pub AchievementId: *const ::std::os::raw::c_char,
    #[doc = " Text representing the Name to display in-game when achievement has been unlocked."]
    pub DisplayName: *const ::std::os::raw::c_char,
    #[doc = " Text representing the description to display in-game when achievement has been unlocked."]
    pub Description: *const ::std::os::raw::c_char,
    #[doc = " Text representing the name to display in-game when achievement is locked."]
    pub LockedDisplayName: *const ::std::os::raw::c_char,
    #[doc = " Text representing the description of what needs to be done to trigger the unlock of this achievement."]
    pub LockedDescription: *const ::std::os::raw::c_char,
    #[doc = " Text representing the description to display in-game when achievement is hidden."]
    pub HiddenDescription: *const ::std::os::raw::c_char,
    #[doc = " Text representing the description of what happens when the achievement is unlocked."]
    pub CompletionDescription: *const ::std::os::raw::c_char,
    #[doc = " Text representing the icon to display in-game when achievement is unlocked."]
    pub UnlockedIconId: *const ::std::os::raw::c_char,
    #[doc = " Text representing the icon to display in-game when achievement is locked."]
    pub LockedIconId: *const ::std::os::raw::c_char,
    #[doc = " True if achievement is hidden, false otherwise."]
    pub bIsHidden: EOS_Bool,
    #[doc = " The number of stat thresholds."]
    pub StatThresholdsCount: i32,
    #[doc = " Array of stat thresholds that need to be satisfied to unlock the achievement."]
    pub StatThresholds: *const EOS_Achievements_StatThresholds,
}
#[test]
fn bindgen_test_layout__tagEOS_Achievements_Definition() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Achievements_Definition> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Achievements_Definition>(),
        96usize,
        concat!("Size of: ", stringify!(_tagEOS_Achievements_Definition))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Achievements_Definition>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Achievements_Definition))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_Definition),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AchievementId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_Definition),
            "::",
            stringify!(AchievementId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisplayName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_Definition),
            "::",
            stringify!(DisplayName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Description) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_Definition),
            "::",
            stringify!(Description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LockedDisplayName) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_Definition),
            "::",
            stringify!(LockedDisplayName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LockedDescription) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_Definition),
            "::",
            stringify!(LockedDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HiddenDescription) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_Definition),
            "::",
            stringify!(HiddenDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CompletionDescription) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_Definition),
            "::",
            stringify!(CompletionDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UnlockedIconId) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_Definition),
            "::",
            stringify!(UnlockedIconId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LockedIconId) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_Definition),
            "::",
            stringify!(LockedIconId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsHidden) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_Definition),
            "::",
            stringify!(bIsHidden)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatThresholdsCount) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_Definition),
            "::",
            stringify!(StatThresholdsCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatThresholds) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_Definition),
            "::",
            stringify!(StatThresholds)
        )
    );
}
pub type EOS_Achievements_Definition = _tagEOS_Achievements_Definition;
extern "C" {
    #[doc = " Release the memory associated with achievement definitions. This must be called on data retrieved from\n EOS_Achievements_CopyAchievementDefinitionByIndex or EOS_Achievements_CopyAchievementDefinitionByAchievementId.\n\n @param AchievementDefinition - The achievement definition to release.\n\n @see EOS_Achievements_Definition\n @see EOS_Achievements_CopyAchievementDefinitionByIndex\n @see EOS_Achievements_CopyAchievementDefinitionByAchievementId"]
    pub fn EOS_Achievements_Definition_Release(
        AchievementDefinition: *mut EOS_Achievements_Definition,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Achievements_CopyAchievementDefinitionByIndexOptions {
    #[doc = " API Version: Set this to EOS_ACHIEVEMENTS_COPYDEFINITIONBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Index of the achievement definition to retrieve from the cache"]
    pub AchievementIndex: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Achievements_CopyAchievementDefinitionByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Achievements_CopyAchievementDefinitionByIndexOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Achievements_CopyAchievementDefinitionByIndexOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Achievements_CopyAchievementDefinitionByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Achievements_CopyAchievementDefinitionByIndexOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Achievements_CopyAchievementDefinitionByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_CopyAchievementDefinitionByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AchievementIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_CopyAchievementDefinitionByIndexOptions),
            "::",
            stringify!(AchievementIndex)
        )
    );
}
pub type EOS_Achievements_CopyAchievementDefinitionByIndexOptions =
    _tagEOS_Achievements_CopyAchievementDefinitionByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Achievements_CopyAchievementDefinitionByAchievementIdOptions {
    #[doc = " API Version: Set this to EOS_ACHIEVEMENTS_COPYDEFINITIONBYACHIEVEMENTID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Achievement ID to look for when copying definition from the cache"]
    pub AchievementId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Achievements_CopyAchievementDefinitionByAchievementIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Achievements_CopyAchievementDefinitionByAchievementIdOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Achievements_CopyAchievementDefinitionByAchievementIdOptions>(
        ),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Achievements_CopyAchievementDefinitionByAchievementIdOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Achievements_CopyAchievementDefinitionByAchievementIdOptions>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Achievements_CopyAchievementDefinitionByAchievementIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_CopyAchievementDefinitionByAchievementIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AchievementId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_CopyAchievementDefinitionByAchievementIdOptions),
            "::",
            stringify!(AchievementId)
        )
    );
}
pub type EOS_Achievements_CopyAchievementDefinitionByAchievementIdOptions =
    _tagEOS_Achievements_CopyAchievementDefinitionByAchievementIdOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Achievements_UnlockedAchievement {
    #[doc = " API Version: Set this to EOS_ACHIEVEMENTS_UNLOCKEDACHIEVEMENT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Achievement ID that can be used to uniquely identify the unlocked achievement."]
    pub AchievementId: *const ::std::os::raw::c_char,
    #[doc = " If not EOS_ACHIEVEMENTS_ACHIEVEMENT_UNLOCKTIME_UNDEFINED then this is the POSIX timestamp that the achievement was unlocked."]
    pub UnlockTime: i64,
}
#[test]
fn bindgen_test_layout__tagEOS_Achievements_UnlockedAchievement() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Achievements_UnlockedAchievement> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Achievements_UnlockedAchievement>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Achievements_UnlockedAchievement)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Achievements_UnlockedAchievement>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Achievements_UnlockedAchievement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_UnlockedAchievement),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AchievementId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_UnlockedAchievement),
            "::",
            stringify!(AchievementId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UnlockTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_UnlockedAchievement),
            "::",
            stringify!(UnlockTime)
        )
    );
}
pub type EOS_Achievements_UnlockedAchievement = _tagEOS_Achievements_UnlockedAchievement;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Achievements_GetUnlockedAchievementCountOptions {
    #[doc = " API Version: Set this to EOS_ACHIEVEMENTS_GETUNLOCKEDACHIEVEMENTCOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Product User ID for which to retrieve the unlocked achievement count"]
    pub UserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Achievements_GetUnlockedAchievementCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Achievements_GetUnlockedAchievementCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Achievements_GetUnlockedAchievementCountOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Achievements_GetUnlockedAchievementCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Achievements_GetUnlockedAchievementCountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Achievements_GetUnlockedAchievementCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_GetUnlockedAchievementCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_GetUnlockedAchievementCountOptions),
            "::",
            stringify!(UserId)
        )
    );
}
pub type EOS_Achievements_GetUnlockedAchievementCountOptions =
    _tagEOS_Achievements_GetUnlockedAchievementCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Achievements_CopyUnlockedAchievementByIndexOptions {
    #[doc = " API Version: Set this to EOS_ACHIEVEMENTS_COPYUNLOCKEDACHIEVEMENTBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID for the user who is copying the unlocked achievement"]
    pub UserId: EOS_ProductUserId,
    #[doc = " Index of the unlocked achievement to retrieve from the cache"]
    pub AchievementIndex: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Achievements_CopyUnlockedAchievementByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Achievements_CopyUnlockedAchievementByIndexOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Achievements_CopyUnlockedAchievementByIndexOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Achievements_CopyUnlockedAchievementByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Achievements_CopyUnlockedAchievementByIndexOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Achievements_CopyUnlockedAchievementByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_CopyUnlockedAchievementByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_CopyUnlockedAchievementByIndexOptions),
            "::",
            stringify!(UserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AchievementIndex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_CopyUnlockedAchievementByIndexOptions),
            "::",
            stringify!(AchievementIndex)
        )
    );
}
pub type EOS_Achievements_CopyUnlockedAchievementByIndexOptions =
    _tagEOS_Achievements_CopyUnlockedAchievementByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Achievements_CopyUnlockedAchievementByAchievementIdOptions {
    #[doc = " API Version: Set this to EOS_ACHIEVEMENTS_COPYUNLOCKEDACHIEVEMENTBYACHIEVEMENTID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID for the user who is copying the unlocked achievement"]
    pub UserId: EOS_ProductUserId,
    #[doc = " AchievementId of the unlocked achievement to retrieve from the cache"]
    pub AchievementId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Achievements_CopyUnlockedAchievementByAchievementIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Achievements_CopyUnlockedAchievementByAchievementIdOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Achievements_CopyUnlockedAchievementByAchievementIdOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Achievements_CopyUnlockedAchievementByAchievementIdOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Achievements_CopyUnlockedAchievementByAchievementIdOptions>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Achievements_CopyUnlockedAchievementByAchievementIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_CopyUnlockedAchievementByAchievementIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_CopyUnlockedAchievementByAchievementIdOptions),
            "::",
            stringify!(UserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AchievementId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_CopyUnlockedAchievementByAchievementIdOptions),
            "::",
            stringify!(AchievementId)
        )
    );
}
pub type EOS_Achievements_CopyUnlockedAchievementByAchievementIdOptions =
    _tagEOS_Achievements_CopyUnlockedAchievementByAchievementIdOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Achievements_AddNotifyAchievementsUnlockedOptions {
    #[doc = " API Version: Set this to EOS_ACHIEVEMENTS_ADDNOTIFYACHIEVEMENTSUNLOCKED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Achievements_AddNotifyAchievementsUnlockedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Achievements_AddNotifyAchievementsUnlockedOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Achievements_AddNotifyAchievementsUnlockedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Achievements_AddNotifyAchievementsUnlockedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Achievements_AddNotifyAchievementsUnlockedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Achievements_AddNotifyAchievementsUnlockedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_AddNotifyAchievementsUnlockedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Achievements_AddNotifyAchievementsUnlockedOptions =
    _tagEOS_Achievements_AddNotifyAchievementsUnlockedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Achievements_OnAchievementsUnlockedCallbackInfo {
    #[doc = " Context that was passed into EOS_Achievements_AddNotifyAchievementsUnlocked"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID for the user who received the unlocked achievements notification"]
    pub UserId: EOS_ProductUserId,
    #[doc = " The number of achievements."]
    pub AchievementsCount: u32,
    #[doc = " This member is not used and will always be set to NULL."]
    pub AchievementIds: *mut *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Achievements_OnAchievementsUnlockedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Achievements_OnAchievementsUnlockedCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Achievements_OnAchievementsUnlockedCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Achievements_OnAchievementsUnlockedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Achievements_OnAchievementsUnlockedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Achievements_OnAchievementsUnlockedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_OnAchievementsUnlockedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_OnAchievementsUnlockedCallbackInfo),
            "::",
            stringify!(UserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AchievementsCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_OnAchievementsUnlockedCallbackInfo),
            "::",
            stringify!(AchievementsCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AchievementIds) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Achievements_OnAchievementsUnlockedCallbackInfo),
            "::",
            stringify!(AchievementIds)
        )
    );
}
pub type EOS_Achievements_OnAchievementsUnlockedCallbackInfo =
    _tagEOS_Achievements_OnAchievementsUnlockedCallbackInfo;
pub type EOS_Achievements_OnAchievementsUnlockedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Achievements_OnAchievementsUnlockedCallbackInfo),
>;
extern "C" {
    #[doc = " Release the memory associated with an unlocked achievement. This must be called on data retrieved from\n EOS_Achievements_CopyUnlockedAchievementByIndex or EOS_Achievements_CopyUnlockedAchievementByAchievementId.\n\n @param Achievement - The unlocked achievement data to release.\n\n @see EOS_Achievements_UnlockedAchievement\n @see EOS_Achievements_CopyUnlockedAchievementByIndex\n @see EOS_Achievements_CopyUnlockedAchievementByAchievementId"]
    pub fn EOS_Achievements_UnlockedAchievement_Release(
        Achievement: *mut EOS_Achievements_UnlockedAchievement,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_StatsHandle {
    _unused: [u8; 0],
}
pub type EOS_HStats = *mut EOS_StatsHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Stats_IngestData {
    #[doc = " API Version: Set this to EOS_STATS_INGESTDATA_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The name of the stat to ingest."]
    pub StatName: *const ::std::os::raw::c_char,
    #[doc = " The amount to ingest the stat."]
    pub IngestAmount: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Stats_IngestData() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Stats_IngestData> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Stats_IngestData>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Stats_IngestData))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Stats_IngestData>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Stats_IngestData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_IngestData),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_IngestData),
            "::",
            stringify!(StatName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IngestAmount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_IngestData),
            "::",
            stringify!(IngestAmount)
        )
    );
}
pub type EOS_Stats_IngestData = _tagEOS_Stats_IngestData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Stats_IngestStatOptions {
    #[doc = " API Version: Set this to EOS_STATS_INGESTSTAT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user requesting the ingest.  Set to null for dedicated server."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Stats to ingest."]
    pub Stats: *const EOS_Stats_IngestData,
    #[doc = " The number of stats to ingest, may not exceed EOS_STATS_MAX_INGEST_STATS."]
    pub StatsCount: u32,
    #[doc = " The Product User ID for the user whose stat is being ingested."]
    pub TargetUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Stats_IngestStatOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Stats_IngestStatOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Stats_IngestStatOptions>(),
        40usize,
        concat!("Size of: ", stringify!(_tagEOS_Stats_IngestStatOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Stats_IngestStatOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Stats_IngestStatOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_IngestStatOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_IngestStatOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Stats) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_IngestStatOptions),
            "::",
            stringify!(Stats)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatsCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_IngestStatOptions),
            "::",
            stringify!(StatsCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_IngestStatOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Stats_IngestStatOptions = _tagEOS_Stats_IngestStatOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Stats_IngestStatCompleteCallbackInfo {
    #[doc = " Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Stats_IngestStat."]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID for the user requesting the ingest"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The Product User ID for the user whose stat is being ingested"]
    pub TargetUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Stats_IngestStatCompleteCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Stats_IngestStatCompleteCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Stats_IngestStatCompleteCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Stats_IngestStatCompleteCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Stats_IngestStatCompleteCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Stats_IngestStatCompleteCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_IngestStatCompleteCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_IngestStatCompleteCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_IngestStatCompleteCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_IngestStatCompleteCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Stats_IngestStatCompleteCallbackInfo = _tagEOS_Stats_IngestStatCompleteCallbackInfo;
pub type EOS_Stats_OnIngestStatCompleteCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Stats_IngestStatCompleteCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Stats_QueryStatsOptions {
    #[doc = " API Version: Set this to EOS_STATS_QUERYSTATS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user requesting the stats. Set to null for dedicated server."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " If not EOS_STATS_TIME_UNDEFINED then this is the POSIX timestamp for start time (Optional)."]
    pub StartTime: i64,
    #[doc = " If not EOS_STATS_TIME_UNDEFINED then this is the POSIX timestamp for end time (Optional)."]
    pub EndTime: i64,
    #[doc = " An array of stat names to query for (Optional)."]
    pub StatNames: *mut *const ::std::os::raw::c_char,
    #[doc = " The number of stat names included in query (Optional), may not exceed EOS_STATS_MAX_QUERY_STATS."]
    pub StatNamesCount: u32,
    #[doc = " The Product User ID for the user whose stats are being retrieved"]
    pub TargetUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Stats_QueryStatsOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Stats_QueryStatsOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Stats_QueryStatsOptions>(),
        56usize,
        concat!("Size of: ", stringify!(_tagEOS_Stats_QueryStatsOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Stats_QueryStatsOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Stats_QueryStatsOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_QueryStatsOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_QueryStatsOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StartTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_QueryStatsOptions),
            "::",
            stringify!(StartTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_QueryStatsOptions),
            "::",
            stringify!(EndTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatNames) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_QueryStatsOptions),
            "::",
            stringify!(StatNames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatNamesCount) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_QueryStatsOptions),
            "::",
            stringify!(StatNamesCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_QueryStatsOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Stats_QueryStatsOptions = _tagEOS_Stats_QueryStatsOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Stats_Stat {
    #[doc = " API Version: Set this to EOS_STATS_STAT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Name of the stat."]
    pub Name: *const ::std::os::raw::c_char,
    #[doc = " If not EOS_STATS_TIME_UNDEFINED then this is the POSIX timestamp for start time."]
    pub StartTime: i64,
    #[doc = " If not EOS_STATS_TIME_UNDEFINED then this is the POSIX timestamp for end time."]
    pub EndTime: i64,
    #[doc = " Current value for the stat."]
    pub Value: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Stats_Stat() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Stats_Stat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Stats_Stat>(),
        40usize,
        concat!("Size of: ", stringify!(_tagEOS_Stats_Stat))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Stats_Stat>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Stats_Stat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_Stat),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_Stat),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StartTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_Stat),
            "::",
            stringify!(StartTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_Stat),
            "::",
            stringify!(EndTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_Stat),
            "::",
            stringify!(Value)
        )
    );
}
pub type EOS_Stats_Stat = _tagEOS_Stats_Stat;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Stats_GetStatCountOptions {
    #[doc = " API Version: Set this to EOS_STATS_GETSTATSCOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID for the user whose stats are being counted"]
    pub TargetUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Stats_GetStatCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Stats_GetStatCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Stats_GetStatCountOptions>(),
        16usize,
        concat!("Size of: ", stringify!(_tagEOS_Stats_GetStatCountOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Stats_GetStatCountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Stats_GetStatCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_GetStatCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_GetStatCountOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Stats_GetStatCountOptions = _tagEOS_Stats_GetStatCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Stats_CopyStatByIndexOptions {
    #[doc = " API Version: Set this to EOS_STATS_COPYSTATBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the user who owns the stat"]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " Index of the stat to retrieve from the cache"]
    pub StatIndex: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Stats_CopyStatByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Stats_CopyStatByIndexOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Stats_CopyStatByIndexOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Stats_CopyStatByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Stats_CopyStatByIndexOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Stats_CopyStatByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_CopyStatByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_CopyStatByIndexOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatIndex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_CopyStatByIndexOptions),
            "::",
            stringify!(StatIndex)
        )
    );
}
pub type EOS_Stats_CopyStatByIndexOptions = _tagEOS_Stats_CopyStatByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Stats_CopyStatByNameOptions {
    #[doc = " API Version: Set this to EOS_STATS_COPYSTATBYNAME_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the user who owns the stat"]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " Name of the stat to retrieve from the cache"]
    pub Name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Stats_CopyStatByNameOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Stats_CopyStatByNameOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Stats_CopyStatByNameOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Stats_CopyStatByNameOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Stats_CopyStatByNameOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Stats_CopyStatByNameOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_CopyStatByNameOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_CopyStatByNameOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_CopyStatByNameOptions),
            "::",
            stringify!(Name)
        )
    );
}
pub type EOS_Stats_CopyStatByNameOptions = _tagEOS_Stats_CopyStatByNameOptions;
extern "C" {
    #[doc = " Release the memory associated with a stat. This must be called on data retrieved from EOS_Stats_CopyStatByIndex or EOS_Stats_CopyStatByName.\n\n @param Stat - The stat data to release.\n\n @see EOS_Stats_Stat\n @see EOS_Stats_CopyStatByIndex\n @see EOS_Stats_CopyStatByName"]
    pub fn EOS_Stats_Stat_Release(Stat: *mut EOS_Stats_Stat);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Stats_OnQueryStatsCompleteCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Stats_QueryStats"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the user who initiated this request"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The Product User ID whose stats which were retrieved"]
    pub TargetUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Stats_OnQueryStatsCompleteCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Stats_OnQueryStatsCompleteCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Stats_OnQueryStatsCompleteCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Stats_OnQueryStatsCompleteCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Stats_OnQueryStatsCompleteCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Stats_OnQueryStatsCompleteCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_OnQueryStatsCompleteCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_OnQueryStatsCompleteCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_OnQueryStatsCompleteCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Stats_OnQueryStatsCompleteCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Stats_OnQueryStatsCompleteCallbackInfo =
    _tagEOS_Stats_OnQueryStatsCompleteCallbackInfo;
pub type EOS_Stats_OnQueryStatsCompleteCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Stats_OnQueryStatsCompleteCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_LeaderboardsHandle {
    _unused: [u8; 0],
}
pub type EOS_HLeaderboards = *mut EOS_LeaderboardsHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Leaderboards_QueryLeaderboardDefinitionsOptions {
    #[doc = " API Version: Set this to EOS_LEADERBOARDS_QUERYLEADERBOARDDEFINITIONS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " An optional POSIX timestamp for the leaderboard's start time, or EOS_LEADERBOARDS_TIME_UNDEFINED"]
    pub StartTime: i64,
    #[doc = " An optional POSIX timestamp for the leaderboard's end time, or EOS_LEADERBOARDS_TIME_UNDEFINED"]
    pub EndTime: i64,
    #[doc = " Product User ID for user who is querying definitions.\n Must be set when using a client policy that requires a valid logged in user.\n Not used for Dedicated Server where no user is available."]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Leaderboards_QueryLeaderboardDefinitionsOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Leaderboards_QueryLeaderboardDefinitionsOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Leaderboards_QueryLeaderboardDefinitionsOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Leaderboards_QueryLeaderboardDefinitionsOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Leaderboards_QueryLeaderboardDefinitionsOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Leaderboards_QueryLeaderboardDefinitionsOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_QueryLeaderboardDefinitionsOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StartTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_QueryLeaderboardDefinitionsOptions),
            "::",
            stringify!(StartTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_QueryLeaderboardDefinitionsOptions),
            "::",
            stringify!(EndTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_QueryLeaderboardDefinitionsOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Leaderboards_QueryLeaderboardDefinitionsOptions =
    _tagEOS_Leaderboards_QueryLeaderboardDefinitionsOptions;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_ELeaderboardAggregation {
    #[doc = " Minimum"]
    EOS_LA_Min = 0,
    #[doc = " Maximum"]
    EOS_LA_Max = 1,
    #[doc = " Sum"]
    EOS_LA_Sum = 2,
    #[doc = " Latest"]
    EOS_LA_Latest = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Leaderboards_Definition {
    #[doc = " API Version: Set this to EOS_LEADERBOARDS_DEFINITION_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Unique ID to identify leaderboard."]
    pub LeaderboardId: *const ::std::os::raw::c_char,
    #[doc = " Name of stat used to rank leaderboard."]
    pub StatName: *const ::std::os::raw::c_char,
    #[doc = " Aggregation used to sort leaderboard."]
    pub Aggregation: EOS_ELeaderboardAggregation,
    #[doc = " The POSIX timestamp for the start time, or EOS_LEADERBOARDS_TIME_UNDEFINED."]
    pub StartTime: i64,
    #[doc = " The POSIX timestamp for the end time, or EOS_LEADERBOARDS_TIME_UNDEFINED."]
    pub EndTime: i64,
}
#[test]
fn bindgen_test_layout__tagEOS_Leaderboards_Definition() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Leaderboards_Definition> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Leaderboards_Definition>(),
        48usize,
        concat!("Size of: ", stringify!(_tagEOS_Leaderboards_Definition))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Leaderboards_Definition>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Leaderboards_Definition))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_Definition),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LeaderboardId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_Definition),
            "::",
            stringify!(LeaderboardId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_Definition),
            "::",
            stringify!(StatName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Aggregation) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_Definition),
            "::",
            stringify!(Aggregation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StartTime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_Definition),
            "::",
            stringify!(StartTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndTime) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_Definition),
            "::",
            stringify!(EndTime)
        )
    );
}
pub type EOS_Leaderboards_Definition = _tagEOS_Leaderboards_Definition;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Leaderboards_GetLeaderboardDefinitionCountOptions {
    #[doc = " API Version: Set this to EOS_LEADERBOARDS_GETLEADERBOARDDEFINITIONCOUNT_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Leaderboards_GetLeaderboardDefinitionCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Leaderboards_GetLeaderboardDefinitionCountOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Leaderboards_GetLeaderboardDefinitionCountOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Leaderboards_GetLeaderboardDefinitionCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Leaderboards_GetLeaderboardDefinitionCountOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Leaderboards_GetLeaderboardDefinitionCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_GetLeaderboardDefinitionCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Leaderboards_GetLeaderboardDefinitionCountOptions =
    _tagEOS_Leaderboards_GetLeaderboardDefinitionCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Leaderboards_CopyLeaderboardDefinitionByIndexOptions {
    #[doc = " API Version: Set this to EOS_LEADERBOARDS_COPYLEADERBOARDDEFINITIONBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Index of the leaderboard definition to retrieve from the cache"]
    pub LeaderboardIndex: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Leaderboards_CopyLeaderboardDefinitionByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Leaderboards_CopyLeaderboardDefinitionByIndexOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Leaderboards_CopyLeaderboardDefinitionByIndexOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Leaderboards_CopyLeaderboardDefinitionByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Leaderboards_CopyLeaderboardDefinitionByIndexOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Leaderboards_CopyLeaderboardDefinitionByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_CopyLeaderboardDefinitionByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LeaderboardIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_CopyLeaderboardDefinitionByIndexOptions),
            "::",
            stringify!(LeaderboardIndex)
        )
    );
}
pub type EOS_Leaderboards_CopyLeaderboardDefinitionByIndexOptions =
    _tagEOS_Leaderboards_CopyLeaderboardDefinitionByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardIdOptions {
    #[doc = " API Version: Set this to EOS_LEADERBOARDS_COPYLEADERBOARDDEFINITIONBYLEADERBOARDID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The ID of the leaderboard whose definition you want to copy from the cache"]
    pub LeaderboardId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardIdOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardIdOptions>(
        ),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardIdOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardIdOptions>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LeaderboardId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardIdOptions),
            "::",
            stringify!(LeaderboardId)
        )
    );
}
pub type EOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardIdOptions =
    _tagEOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardIdOptions;
extern "C" {
    #[doc = " Release the memory associated with a leaderboard definition. This must be called on data retrieved from\n EOS_Leaderboards_CopyLeaderboardDefinitionByIndex or EOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardId.\n\n @param LeaderboardDefinition - The Leaderboard definition to release.\n\n @see EOS_Leaderboards_Definition\n @see EOS_Leaderboards_CopyLeaderboardDefinitionByIndex\n @see EOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardId"]
    pub fn EOS_Leaderboards_Definition_Release(
        LeaderboardDefinition: *mut EOS_Leaderboards_Definition,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Leaderboards_OnQueryLeaderboardDefinitionsCompleteCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Leaderboards_QueryLeaderboardDefinitions."]
    pub ClientData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_Leaderboards_OnQueryLeaderboardDefinitionsCompleteCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Leaderboards_OnQueryLeaderboardDefinitionsCompleteCallbackInfo,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Leaderboards_OnQueryLeaderboardDefinitionsCompleteCallbackInfo>(
        ),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Leaderboards_OnQueryLeaderboardDefinitionsCompleteCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _tagEOS_Leaderboards_OnQueryLeaderboardDefinitionsCompleteCallbackInfo,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Leaderboards_OnQueryLeaderboardDefinitionsCompleteCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_OnQueryLeaderboardDefinitionsCompleteCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_OnQueryLeaderboardDefinitionsCompleteCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
}
pub type EOS_Leaderboards_OnQueryLeaderboardDefinitionsCompleteCallbackInfo =
    _tagEOS_Leaderboards_OnQueryLeaderboardDefinitionsCompleteCallbackInfo;
pub type EOS_Leaderboards_OnQueryLeaderboardDefinitionsCompleteCallback = ::std::option::Option<
    unsafe extern "C" fn(
        Data: *const EOS_Leaderboards_OnQueryLeaderboardDefinitionsCompleteCallbackInfo,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Leaderboards_UserScoresQueryStatInfo {
    #[doc = " API Version: Set this to EOS_LEADERBOARDS_USERSCORESQUERYSTATINFO_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The name of the stat to query."]
    pub StatName: *const ::std::os::raw::c_char,
    #[doc = " Aggregation used to sort the cached user scores."]
    pub Aggregation: EOS_ELeaderboardAggregation,
}
#[test]
fn bindgen_test_layout__tagEOS_Leaderboards_UserScoresQueryStatInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Leaderboards_UserScoresQueryStatInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Leaderboards_UserScoresQueryStatInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Leaderboards_UserScoresQueryStatInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Leaderboards_UserScoresQueryStatInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Leaderboards_UserScoresQueryStatInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_UserScoresQueryStatInfo),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_UserScoresQueryStatInfo),
            "::",
            stringify!(StatName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Aggregation) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_UserScoresQueryStatInfo),
            "::",
            stringify!(Aggregation)
        )
    );
}
pub type EOS_Leaderboards_UserScoresQueryStatInfo = _tagEOS_Leaderboards_UserScoresQueryStatInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Leaderboards_QueryLeaderboardUserScoresOptions {
    #[doc = " API Version: Set this to EOS_LEADERBOARDS_QUERYLEADERBOARDUSERSCORES_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " An array of Product User IDs indicating the users whose scores you want to retrieve"]
    pub UserIds: *const EOS_ProductUserId,
    #[doc = " The number of users included in query"]
    pub UserIdsCount: u32,
    #[doc = " The stats to be collected, along with the sorting method to use when determining rank order for each stat"]
    pub StatInfo: *const EOS_Leaderboards_UserScoresQueryStatInfo,
    #[doc = " The number of stats to query"]
    pub StatInfoCount: u32,
    #[doc = " An optional POSIX timestamp, or EOS_LEADERBOARDS_TIME_UNDEFINED; results will only include scores made after this time"]
    pub StartTime: i64,
    #[doc = " An optional POSIX timestamp, or EOS_LEADERBOARDS_TIME_UNDEFINED; results will only include scores made before this time"]
    pub EndTime: i64,
    #[doc = " Product User ID for user who is querying user scores.\n Must be set when using a client policy that requires a valid logged in user.\n Not used for Dedicated Server where no user is available."]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Leaderboards_QueryLeaderboardUserScoresOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Leaderboards_QueryLeaderboardUserScoresOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Leaderboards_QueryLeaderboardUserScoresOptions>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Leaderboards_QueryLeaderboardUserScoresOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Leaderboards_QueryLeaderboardUserScoresOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Leaderboards_QueryLeaderboardUserScoresOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_QueryLeaderboardUserScoresOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserIds) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_QueryLeaderboardUserScoresOptions),
            "::",
            stringify!(UserIds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserIdsCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_QueryLeaderboardUserScoresOptions),
            "::",
            stringify!(UserIdsCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatInfo) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_QueryLeaderboardUserScoresOptions),
            "::",
            stringify!(StatInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatInfoCount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_QueryLeaderboardUserScoresOptions),
            "::",
            stringify!(StatInfoCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StartTime) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_QueryLeaderboardUserScoresOptions),
            "::",
            stringify!(StartTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndTime) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_QueryLeaderboardUserScoresOptions),
            "::",
            stringify!(EndTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_QueryLeaderboardUserScoresOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Leaderboards_QueryLeaderboardUserScoresOptions =
    _tagEOS_Leaderboards_QueryLeaderboardUserScoresOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Leaderboards_LeaderboardUserScore {
    #[doc = " API Version: Set this to EOS_LEADERBOARDS_LEADERBOARDUSERSCORE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the user who got this score"]
    pub UserId: EOS_ProductUserId,
    #[doc = " Leaderboard score"]
    pub Score: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Leaderboards_LeaderboardUserScore() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Leaderboards_LeaderboardUserScore> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Leaderboards_LeaderboardUserScore>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Leaderboards_LeaderboardUserScore)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Leaderboards_LeaderboardUserScore>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Leaderboards_LeaderboardUserScore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_LeaderboardUserScore),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_LeaderboardUserScore),
            "::",
            stringify!(UserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Score) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_LeaderboardUserScore),
            "::",
            stringify!(Score)
        )
    );
}
pub type EOS_Leaderboards_LeaderboardUserScore = _tagEOS_Leaderboards_LeaderboardUserScore;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Leaderboards_GetLeaderboardUserScoreCountOptions {
    #[doc = " API Version: Set this to EOS_LEADERBOARDS_GETLEADERBOARDUSERSCORECOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Name of stat used to rank leaderboard."]
    pub StatName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Leaderboards_GetLeaderboardUserScoreCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Leaderboards_GetLeaderboardUserScoreCountOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Leaderboards_GetLeaderboardUserScoreCountOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Leaderboards_GetLeaderboardUserScoreCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Leaderboards_GetLeaderboardUserScoreCountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Leaderboards_GetLeaderboardUserScoreCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_GetLeaderboardUserScoreCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_GetLeaderboardUserScoreCountOptions),
            "::",
            stringify!(StatName)
        )
    );
}
pub type EOS_Leaderboards_GetLeaderboardUserScoreCountOptions =
    _tagEOS_Leaderboards_GetLeaderboardUserScoreCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Leaderboards_CopyLeaderboardUserScoreByIndexOptions {
    #[doc = " API Version: Set this to EOS_LEADERBOARDS_COPYLEADERBOARDUSERSCOREBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Index of the sorted leaderboard user score to retrieve from the cache."]
    pub LeaderboardUserScoreIndex: u32,
    #[doc = " Name of the stat used to rank the leaderboard."]
    pub StatName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Leaderboards_CopyLeaderboardUserScoreByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Leaderboards_CopyLeaderboardUserScoreByIndexOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Leaderboards_CopyLeaderboardUserScoreByIndexOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Leaderboards_CopyLeaderboardUserScoreByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Leaderboards_CopyLeaderboardUserScoreByIndexOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Leaderboards_CopyLeaderboardUserScoreByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_CopyLeaderboardUserScoreByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LeaderboardUserScoreIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_CopyLeaderboardUserScoreByIndexOptions),
            "::",
            stringify!(LeaderboardUserScoreIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_CopyLeaderboardUserScoreByIndexOptions),
            "::",
            stringify!(StatName)
        )
    );
}
pub type EOS_Leaderboards_CopyLeaderboardUserScoreByIndexOptions =
    _tagEOS_Leaderboards_CopyLeaderboardUserScoreByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Leaderboards_CopyLeaderboardUserScoreByUserIdOptions {
    #[doc = " API Version: Set this to EOS_LEADERBOARDS_COPYLEADERBOARDUSERSCOREBYUSERID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID to look for when copying leaderboard score data from the cache"]
    pub UserId: EOS_ProductUserId,
    #[doc = " The name of the stat that is used to rank this leaderboard"]
    pub StatName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Leaderboards_CopyLeaderboardUserScoreByUserIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Leaderboards_CopyLeaderboardUserScoreByUserIdOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Leaderboards_CopyLeaderboardUserScoreByUserIdOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Leaderboards_CopyLeaderboardUserScoreByUserIdOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Leaderboards_CopyLeaderboardUserScoreByUserIdOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Leaderboards_CopyLeaderboardUserScoreByUserIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_CopyLeaderboardUserScoreByUserIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_CopyLeaderboardUserScoreByUserIdOptions),
            "::",
            stringify!(UserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_CopyLeaderboardUserScoreByUserIdOptions),
            "::",
            stringify!(StatName)
        )
    );
}
pub type EOS_Leaderboards_CopyLeaderboardUserScoreByUserIdOptions =
    _tagEOS_Leaderboards_CopyLeaderboardUserScoreByUserIdOptions;
extern "C" {
    #[doc = " Release the memory associated with leaderboard user score. This must be called on data retrieved from\n EOS_Leaderboards_CopyLeaderboardUserScoreByIndex or EOS_Leaderboards_CopyLeaderboardUserScoreByUserId.\n\n @param LeaderboardUserScore - The Leaderboard user score to release.\n\n @see EOS_Leaderboards_LeaderboardUserScore\n @see EOS_Leaderboards_CopyLeaderboardUserScoreByIndex\n @see EOS_Leaderboards_CopyLeaderboardUserScoreByUserId"]
    pub fn EOS_Leaderboards_LeaderboardUserScore_Release(
        LeaderboardUserScore: *mut EOS_Leaderboards_LeaderboardUserScore,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Leaderboards_QueryLeaderboardUserScores."]
    pub ClientData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallbackInfo,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallbackInfo>(
        ),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallbackInfo>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
}
pub type EOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallbackInfo =
    _tagEOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallbackInfo;
pub type EOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallback = ::std::option::Option<
    unsafe extern "C" fn(
        Data: *const EOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallbackInfo,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Leaderboards_QueryLeaderboardRanksOptions {
    #[doc = " API Version: Set this to EOS_LEADERBOARDS_QUERYLEADERBOARDRANKS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The ID of the leaderboard whose information you want to retrieve."]
    pub LeaderboardId: *const ::std::os::raw::c_char,
    #[doc = " Product User ID for user who is querying ranks.\n Must be set when using a client policy that requires a valid logged in user.\n Not used for Dedicated Server where no user is available."]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Leaderboards_QueryLeaderboardRanksOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Leaderboards_QueryLeaderboardRanksOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Leaderboards_QueryLeaderboardRanksOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Leaderboards_QueryLeaderboardRanksOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Leaderboards_QueryLeaderboardRanksOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Leaderboards_QueryLeaderboardRanksOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_QueryLeaderboardRanksOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LeaderboardId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_QueryLeaderboardRanksOptions),
            "::",
            stringify!(LeaderboardId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_QueryLeaderboardRanksOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Leaderboards_QueryLeaderboardRanksOptions =
    _tagEOS_Leaderboards_QueryLeaderboardRanksOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Leaderboards_LeaderboardRecord {
    #[doc = " API Version: Set this to EOS_LEADERBOARDS_LEADERBOARDRECORD_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID associated with this record"]
    pub UserId: EOS_ProductUserId,
    #[doc = " Sorted position on leaderboard"]
    pub Rank: u32,
    #[doc = " Leaderboard score"]
    pub Score: i32,
    #[doc = " The latest display name seen for the user since they last time logged in. This is empty if the user does not have a display name set."]
    pub UserDisplayName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Leaderboards_LeaderboardRecord() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Leaderboards_LeaderboardRecord> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Leaderboards_LeaderboardRecord>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Leaderboards_LeaderboardRecord)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Leaderboards_LeaderboardRecord>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Leaderboards_LeaderboardRecord)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_LeaderboardRecord),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_LeaderboardRecord),
            "::",
            stringify!(UserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Rank) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_LeaderboardRecord),
            "::",
            stringify!(Rank)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Score) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_LeaderboardRecord),
            "::",
            stringify!(Score)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserDisplayName) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_LeaderboardRecord),
            "::",
            stringify!(UserDisplayName)
        )
    );
}
pub type EOS_Leaderboards_LeaderboardRecord = _tagEOS_Leaderboards_LeaderboardRecord;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Leaderboards_GetLeaderboardRecordCountOptions {
    #[doc = " API Version: Set this to EOS_LEADERBOARDS_GETLEADERBOARDRECORDCOUNT_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_Leaderboards_GetLeaderboardRecordCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Leaderboards_GetLeaderboardRecordCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Leaderboards_GetLeaderboardRecordCountOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Leaderboards_GetLeaderboardRecordCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Leaderboards_GetLeaderboardRecordCountOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Leaderboards_GetLeaderboardRecordCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_GetLeaderboardRecordCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_Leaderboards_GetLeaderboardRecordCountOptions =
    _tagEOS_Leaderboards_GetLeaderboardRecordCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Leaderboards_CopyLeaderboardRecordByIndexOptions {
    #[doc = " API Version: Set this to EOS_LEADERBOARDS_COPYLEADERBOARDRECORDBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Index of the leaderboard record to retrieve from the cache"]
    pub LeaderboardRecordIndex: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Leaderboards_CopyLeaderboardRecordByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Leaderboards_CopyLeaderboardRecordByIndexOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Leaderboards_CopyLeaderboardRecordByIndexOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Leaderboards_CopyLeaderboardRecordByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Leaderboards_CopyLeaderboardRecordByIndexOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Leaderboards_CopyLeaderboardRecordByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_CopyLeaderboardRecordByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LeaderboardRecordIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_CopyLeaderboardRecordByIndexOptions),
            "::",
            stringify!(LeaderboardRecordIndex)
        )
    );
}
pub type EOS_Leaderboards_CopyLeaderboardRecordByIndexOptions =
    _tagEOS_Leaderboards_CopyLeaderboardRecordByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Leaderboards_CopyLeaderboardRecordByUserIdOptions {
    #[doc = " API Version: Set this to EOS_LEADERBOARDS_COPYLEADERBOARDRECORDBYUSERID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Leaderboard data will be copied from the cache if it relates to the user matching this Product User ID"]
    pub UserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Leaderboards_CopyLeaderboardRecordByUserIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Leaderboards_CopyLeaderboardRecordByUserIdOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Leaderboards_CopyLeaderboardRecordByUserIdOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Leaderboards_CopyLeaderboardRecordByUserIdOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Leaderboards_CopyLeaderboardRecordByUserIdOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Leaderboards_CopyLeaderboardRecordByUserIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_CopyLeaderboardRecordByUserIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_CopyLeaderboardRecordByUserIdOptions),
            "::",
            stringify!(UserId)
        )
    );
}
pub type EOS_Leaderboards_CopyLeaderboardRecordByUserIdOptions =
    _tagEOS_Leaderboards_CopyLeaderboardRecordByUserIdOptions;
extern "C" {
    #[doc = " Release the memory associated with leaderboard record. This must be called on data retrieved from\n EOS_Leaderboards_CopyLeaderboardRecordByIndex or EOS_Leaderboards_CopyLeaderboardRecordByUserId.\n\n @param LeaderboardRecord - The Leaderboard record to release.\n\n @see EOS_Leaderboards_LeaderboardRecord\n @see EOS_Leaderboards_CopyLeaderboardRecordByIndex\n @see EOS_Leaderboards_CopyLeaderboardRecordByUserId"]
    pub fn EOS_Leaderboards_LeaderboardRecord_Release(
        LeaderboardRecord: *mut EOS_Leaderboards_LeaderboardRecord,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Leaderboards_QueryLeaderboardRanks."]
    pub ClientData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallbackInfo,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallbackInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
}
pub type EOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallbackInfo =
    _tagEOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallbackInfo;
pub type EOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallbackInfo),
>;
extern "C" {
    #[doc = " Do not use. Alias to the previous API name for backwards compatibility in compilation."]
    pub fn EOS_Leaderboards_LeaderboardDefinition_Release(
        LeaderboardDefinition: *mut EOS_Leaderboards_Definition,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_ModsHandle {
    _unused: [u8; 0],
}
pub type EOS_HMods = *mut EOS_ModsHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Mod_Identifier {
    #[doc = " API Version: Set this to EOS_MOD_IDENTIFIER_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Product namespace id in which this mod item exists"]
    pub NamespaceId: *const ::std::os::raw::c_char,
    #[doc = " Item id of the Mod"]
    pub ItemId: *const ::std::os::raw::c_char,
    #[doc = " Artifact id of the Mod"]
    pub ArtifactId: *const ::std::os::raw::c_char,
    #[doc = " Represent mod item title."]
    pub Title: *const ::std::os::raw::c_char,
    #[doc = " Represent mod item version."]
    pub Version: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Mod_Identifier() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Mod_Identifier> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Mod_Identifier>(),
        48usize,
        concat!("Size of: ", stringify!(_tagEOS_Mod_Identifier))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Mod_Identifier>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Mod_Identifier))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mod_Identifier),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NamespaceId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mod_Identifier),
            "::",
            stringify!(NamespaceId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ItemId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mod_Identifier),
            "::",
            stringify!(ItemId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ArtifactId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mod_Identifier),
            "::",
            stringify!(ArtifactId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Title) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mod_Identifier),
            "::",
            stringify!(Title)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mod_Identifier),
            "::",
            stringify!(Version)
        )
    );
}
pub type EOS_Mod_Identifier = _tagEOS_Mod_Identifier;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Mods_InstallModOptions {
    #[doc = " API Version: Set this to EOS_MODS_INSTALLMOD_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the user for which the mod should be installed"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The mod to install"]
    pub Mod: *const EOS_Mod_Identifier,
    #[doc = " Indicates whether the mod should be uninstalled after exiting the game or not."]
    pub bRemoveAfterExit: EOS_Bool,
}
#[test]
fn bindgen_test_layout__tagEOS_Mods_InstallModOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Mods_InstallModOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Mods_InstallModOptions>(),
        32usize,
        concat!("Size of: ", stringify!(_tagEOS_Mods_InstallModOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Mods_InstallModOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Mods_InstallModOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_InstallModOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_InstallModOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mod) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_InstallModOptions),
            "::",
            stringify!(Mod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bRemoveAfterExit) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_InstallModOptions),
            "::",
            stringify!(bRemoveAfterExit)
        )
    );
}
pub type EOS_Mods_InstallModOptions = _tagEOS_Mods_InstallModOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Mods_InstallModCallbackInfo {
    #[doc = " Result code for the operation. EOS_Success is returned if the installation was successful, otherwise one of the error codes is returned."]
    pub ResultCode: EOS_EResult,
    #[doc = " The Epic Account ID of the user for which mod installation was requested"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " Context that is passed into EOS_Mods_InstallMod"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Mod for which installation was requested"]
    pub Mod: *const EOS_Mod_Identifier,
}
#[test]
fn bindgen_test_layout__tagEOS_Mods_InstallModCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Mods_InstallModCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Mods_InstallModCallbackInfo>(),
        32usize,
        concat!("Size of: ", stringify!(_tagEOS_Mods_InstallModCallbackInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Mods_InstallModCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Mods_InstallModCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_InstallModCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_InstallModCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_InstallModCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mod) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_InstallModCallbackInfo),
            "::",
            stringify!(Mod)
        )
    );
}
pub type EOS_Mods_InstallModCallbackInfo = _tagEOS_Mods_InstallModCallbackInfo;
pub type EOS_Mods_OnInstallModCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Mods_InstallModCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Mods_UninstallModOptions {
    #[doc = " API Version: Set this to EOS_MODS_UNINSTALLMOD_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the user for which the mod should be uninstalled"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The mod to uninstall"]
    pub Mod: *const EOS_Mod_Identifier,
}
#[test]
fn bindgen_test_layout__tagEOS_Mods_UninstallModOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Mods_UninstallModOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Mods_UninstallModOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Mods_UninstallModOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Mods_UninstallModOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Mods_UninstallModOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_UninstallModOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_UninstallModOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mod) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_UninstallModOptions),
            "::",
            stringify!(Mod)
        )
    );
}
pub type EOS_Mods_UninstallModOptions = _tagEOS_Mods_UninstallModOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Mods_UninstallModCallbackInfo {
    #[doc = " Result code for the operation. EOS_Success is returned if the uninstallation was successful, otherwise one of the error codes is returned."]
    pub ResultCode: EOS_EResult,
    #[doc = " The Epic Account ID of the user for which mod uninstallation was requested"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " Context that is passed into EOS_Mods_UninstallMod"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Mod for which uninstallation was requested"]
    pub Mod: *const EOS_Mod_Identifier,
}
#[test]
fn bindgen_test_layout__tagEOS_Mods_UninstallModCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Mods_UninstallModCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Mods_UninstallModCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Mods_UninstallModCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Mods_UninstallModCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Mods_UninstallModCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_UninstallModCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_UninstallModCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_UninstallModCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mod) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_UninstallModCallbackInfo),
            "::",
            stringify!(Mod)
        )
    );
}
pub type EOS_Mods_UninstallModCallbackInfo = _tagEOS_Mods_UninstallModCallbackInfo;
pub type EOS_Mods_OnUninstallModCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Mods_UninstallModCallbackInfo)>;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EModEnumerationType {
    #[doc = " Installed mods"]
    EOS_MET_INSTALLED = 0,
    #[doc = " All available mods"]
    EOS_MET_ALL_AVAILABLE = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Mods_EnumerateModsOptions {
    #[doc = " API Version: Set this to EOS_MODS_ENUMERATEMODS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the user for which the mod should be enumerated"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " Type of the mods to enumerate"]
    pub Type: EOS_EModEnumerationType,
}
#[test]
fn bindgen_test_layout__tagEOS_Mods_EnumerateModsOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Mods_EnumerateModsOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Mods_EnumerateModsOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Mods_EnumerateModsOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Mods_EnumerateModsOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Mods_EnumerateModsOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_EnumerateModsOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_EnumerateModsOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_EnumerateModsOptions),
            "::",
            stringify!(Type)
        )
    );
}
pub type EOS_Mods_EnumerateModsOptions = _tagEOS_Mods_EnumerateModsOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Mods_EnumerateModsCallbackInfo {
    #[doc = " Result code for the operation. EOS_Success is returned if the enumeration was successful, otherwise one of the error codes is returned."]
    pub ResultCode: EOS_EResult,
    #[doc = " The Epic Account ID of the user for which mod enumeration was requested"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " Context that is passed into EOS_Mods_EnumerateMods"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Type of the enumerated mods"]
    pub Type: EOS_EModEnumerationType,
}
#[test]
fn bindgen_test_layout__tagEOS_Mods_EnumerateModsCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Mods_EnumerateModsCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Mods_EnumerateModsCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Mods_EnumerateModsCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Mods_EnumerateModsCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Mods_EnumerateModsCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_EnumerateModsCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_EnumerateModsCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_EnumerateModsCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_EnumerateModsCallbackInfo),
            "::",
            stringify!(Type)
        )
    );
}
pub type EOS_Mods_EnumerateModsCallbackInfo = _tagEOS_Mods_EnumerateModsCallbackInfo;
pub type EOS_Mods_OnEnumerateModsCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Mods_EnumerateModsCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Mods_CopyModInfoOptions {
    #[doc = " API Version: Set this to EOS_MODS_COPYMODINFO_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the user for which mods should be copied"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " Type of the enumerated mod to copy"]
    pub Type: EOS_EModEnumerationType,
}
#[test]
fn bindgen_test_layout__tagEOS_Mods_CopyModInfoOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Mods_CopyModInfoOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Mods_CopyModInfoOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Mods_CopyModInfoOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Mods_CopyModInfoOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Mods_CopyModInfoOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_CopyModInfoOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_CopyModInfoOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_CopyModInfoOptions),
            "::",
            stringify!(Type)
        )
    );
}
pub type EOS_Mods_CopyModInfoOptions = _tagEOS_Mods_CopyModInfoOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Mods_ModInfo {
    #[doc = " API Version: Set this to EOS_MODS_MODINFO_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The count of enumerated mods"]
    pub ModsCount: i32,
    #[doc = " The array of enumerated mods or NULL if no such type of mods were enumerated"]
    pub Mods: *mut EOS_Mod_Identifier,
    #[doc = " Type of the mods"]
    pub Type: EOS_EModEnumerationType,
}
#[test]
fn bindgen_test_layout__tagEOS_Mods_ModInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Mods_ModInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Mods_ModInfo>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Mods_ModInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Mods_ModInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Mods_ModInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_ModInfo),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ModsCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_ModInfo),
            "::",
            stringify!(ModsCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mods) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_ModInfo),
            "::",
            stringify!(Mods)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_ModInfo),
            "::",
            stringify!(Type)
        )
    );
}
pub type EOS_Mods_ModInfo = _tagEOS_Mods_ModInfo;
extern "C" {
    #[doc = " Release the memory associated with an EOS_Mods_ModInfo structure and its sub-objects. This must be called on data retrieved from EOS_Mods_CopyModInfo.\n\n @param ModInfo the info structure to be release\n\n @see EOS_Mods_ModInfo\n @see EOS_Mods_CopyModInfo"]
    pub fn EOS_Mods_ModInfo_Release(ModInfo: *mut EOS_Mods_ModInfo);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Mods_UpdateModOptions {
    #[doc = " API Version: Set this to EOS_MODS_UPDATEMOD_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Epic Account ID of the user for which the mod should be updated"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " The mod to update"]
    pub Mod: *const EOS_Mod_Identifier,
}
#[test]
fn bindgen_test_layout__tagEOS_Mods_UpdateModOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Mods_UpdateModOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Mods_UpdateModOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_Mods_UpdateModOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Mods_UpdateModOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_Mods_UpdateModOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_UpdateModOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_UpdateModOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mod) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_UpdateModOptions),
            "::",
            stringify!(Mod)
        )
    );
}
pub type EOS_Mods_UpdateModOptions = _tagEOS_Mods_UpdateModOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Mods_UpdateModCallbackInfo {
    #[doc = " Result code for the operation. EOS_Success is returned if the request to update was successful, otherwise one of the error codes is returned."]
    pub ResultCode: EOS_EResult,
    #[doc = " The Epic Account ID of the user for which mod update was requested"]
    pub LocalUserId: EOS_EpicAccountId,
    #[doc = " Context that is passed into EOS_Mods_UpdateMod"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Mod for which update was requested"]
    pub Mod: *const EOS_Mod_Identifier,
}
#[test]
fn bindgen_test_layout__tagEOS_Mods_UpdateModCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Mods_UpdateModCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Mods_UpdateModCallbackInfo>(),
        32usize,
        concat!("Size of: ", stringify!(_tagEOS_Mods_UpdateModCallbackInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Mods_UpdateModCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Mods_UpdateModCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_UpdateModCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_UpdateModCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_UpdateModCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mod) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Mods_UpdateModCallbackInfo),
            "::",
            stringify!(Mod)
        )
    );
}
pub type EOS_Mods_UpdateModCallbackInfo = _tagEOS_Mods_UpdateModCallbackInfo;
pub type EOS_Mods_OnUpdateModCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_Mods_UpdateModCallbackInfo)>;
#[doc = " Arbitrary data that is a unique local identifier for\n a single remote client or peer.\n\n Typically this is a pointer to an object describing the\n player, but it can be anything that is locally unique."]
pub type EOS_AntiCheatCommon_ClientHandle = *mut ::std::os::raw::c_void;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EAntiCheatCommonClientType {
    #[doc = " An ordinary player that requires anti-cheat client protection to play"]
    EOS_ACCCT_ProtectedClient = 0,
    #[doc = " The player does not need the anti-cheat client to play because of their platform or other factors"]
    EOS_ACCCT_UnprotectedClient = 1,
    #[doc = " The client is an AI bot, not an actual human"]
    EOS_ACCCT_AIBot = 2,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EAntiCheatCommonClientPlatform {
    #[doc = " Unknown platform"]
    EOS_ACCCP_Unknown = 0,
    #[doc = " The client is playing on Windows"]
    EOS_ACCCP_Windows = 1,
    #[doc = " The client is playing on Mac"]
    EOS_ACCCP_Mac = 2,
    #[doc = " The client is playing on Linux"]
    EOS_ACCCP_Linux = 3,
    #[doc = " The client is playing on an Xbox device"]
    EOS_ACCCP_Xbox = 4,
    #[doc = " The client is playing on a PlayStation device"]
    EOS_ACCCP_PlayStation = 5,
    #[doc = " The client is playing on a Nintendo device"]
    EOS_ACCCP_Nintendo = 6,
    #[doc = " The client is playing on iOS"]
    EOS_ACCCP_iOS = 7,
    #[doc = " The client is playing on Android"]
    EOS_ACCCP_Android = 8,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EAntiCheatCommonClientAction {
    #[doc = " Not used"]
    EOS_ACCCA_Invalid = 0,
    #[doc = " The client/peer must be removed from the current game session"]
    EOS_ACCCA_RemovePlayer = 1,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EAntiCheatCommonClientActionReason {
    #[doc = " Not used"]
    EOS_ACCCAR_Invalid = 0,
    #[doc = " An internal error occurred"]
    EOS_ACCCAR_InternalError = 1,
    #[doc = " An anti-cheat message received from the client/peer was corrupt or invalid"]
    EOS_ACCCAR_InvalidMessage = 2,
    #[doc = " The client/peer's anti-cheat authentication failed"]
    EOS_ACCCAR_AuthenticationFailed = 3,
    #[doc = " The client/peer failed to load the anti-cheat module at startup"]
    EOS_ACCCAR_NullClient = 4,
    #[doc = " The client/peer's anti-cheat heartbeat was not received"]
    EOS_ACCCAR_HeartbeatTimeout = 5,
    #[doc = " The client/peer failed an anti-cheat client runtime check"]
    EOS_ACCCAR_ClientViolation = 6,
    #[doc = " The client/peer failed an anti-cheat backend runtime check"]
    EOS_ACCCAR_BackendViolation = 7,
    #[doc = " The client/peer is temporarily blocked from playing on this game server"]
    EOS_ACCCAR_TemporaryCooldown = 8,
    #[doc = " The client/peer is temporarily banned"]
    EOS_ACCCAR_TemporaryBanned = 9,
    #[doc = " The client/peer is permanently banned"]
    EOS_ACCCAR_PermanentBanned = 10,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EAntiCheatCommonClientAuthStatus {
    #[doc = " Not used"]
    EOS_ACCCAS_Invalid = 0,
    #[doc = " The client/peer's anti-cheat functionality has been validated by this game server"]
    EOS_ACCCAS_LocalAuthComplete = 1,
    #[doc = " The client/peer's anti-cheat functionality has been validated by the anti-cheat backend service"]
    EOS_ACCCAS_RemoteAuthComplete = 2,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EAntiCheatCommonClientFlags {
    #[doc = " No particular flags relevant for this client"]
    EOS_ACCCF_None = 0,
    #[doc = " The client has admin privileges on the game server"]
    EOS_ACCCF_Admin = 1,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EAntiCheatCommonClientInput {
    #[doc = " Unknown input device"]
    EOS_ACCCI_Unknown = 0,
    #[doc = " The client is using mouse and keyboard"]
    EOS_ACCCI_MouseKeyboard = 1,
    #[doc = " The client is using a gamepad or game controller"]
    EOS_ACCCI_Gamepad = 2,
    #[doc = " The client is using a touch input device (e.g. phone/tablet screen)"]
    EOS_ACCCI_TouchInput = 3,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EAntiCheatCommonEventType {
    #[doc = " Not used"]
    EOS_ACCET_Invalid = 0,
    #[doc = " A general game event that is not specific to any individual player.\n Low memory use which is constant with respect to the number of players."]
    EOS_ACCET_GameEvent = 1,
    #[doc = " An event that is logically associated with a specific player. Events logged in\n this category require a specific ClientHandle to which they will be attached.\n Higher memory use which scales according to the number of players."]
    EOS_ACCET_PlayerEvent = 2,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EAntiCheatCommonEventParamType {
    #[doc = " Not used"]
    EOS_ACCEPT_Invalid = 0,
    #[doc = " EOS_AntiCheatCommon_ClientHandle"]
    EOS_ACCEPT_ClientHandle = 1,
    #[doc = " const char*"]
    EOS_ACCEPT_String = 2,
    #[doc = " uint32_t"]
    EOS_ACCEPT_UInt32 = 3,
    #[doc = " int32_t"]
    EOS_ACCEPT_Int32 = 4,
    #[doc = " uint64_t"]
    EOS_ACCEPT_UInt64 = 5,
    #[doc = " int64_t"]
    EOS_ACCEPT_Int64 = 6,
    #[doc = " EOS_AntiCheatCommon_Vec3f"]
    EOS_ACCEPT_Vector3f = 7,
    #[doc = " EOS_AntiCheatCommon_Quat"]
    EOS_ACCEPT_Quat = 8,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EAntiCheatCommonPlayerMovementState {
    #[doc = " No particular state applies"]
    EOS_ACCPMS_None = 0,
    #[doc = " Player is crouching"]
    EOS_ACCPMS_Crouching = 1,
    #[doc = " Player is prone"]
    EOS_ACCPMS_Prone = 2,
    #[doc = " Player is mounted in a vehicle or similar"]
    EOS_ACCPMS_Mounted = 3,
    #[doc = " Player is swimming in a fluid volume"]
    EOS_ACCPMS_Swimming = 4,
    #[doc = " Player is falling under the effects of gravity, such as when jumping or walking off the edge of a surface"]
    EOS_ACCPMS_Falling = 5,
    #[doc = " Player is flying, ignoring the effects of gravity"]
    EOS_ACCPMS_Flying = 6,
    #[doc = " Player is on a ladder"]
    EOS_ACCPMS_OnLadder = 7,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EAntiCheatCommonPlayerTakeDamageSource {
    #[doc = " No particular source relevant"]
    EOS_ACCPTDS_None = 0,
    #[doc = " Damage caused by a player controlled character"]
    EOS_ACCPTDS_Player = 1,
    #[doc = " Damage caused by a non-player character such as an AI enemy"]
    EOS_ACCPTDS_NonPlayerCharacter = 2,
    #[doc = " Damage caused by the world (falling off level, into lava, etc)"]
    EOS_ACCPTDS_World = 3,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EAntiCheatCommonPlayerTakeDamageType {
    #[doc = " No particular type relevant"]
    EOS_ACCPTDT_None = 0,
    #[doc = " Damage caused by a point source such as a bullet or melee attack"]
    EOS_ACCPTDT_PointDamage = 1,
    #[doc = " Damage caused by a radial source such as an explosion"]
    EOS_ACCPTDT_RadialDamage = 2,
    #[doc = " Damage over time such as bleeding, poison, etc"]
    EOS_ACCPTDT_DamageOverTime = 3,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EAntiCheatCommonPlayerTakeDamageResult {
    #[doc = " No direct state change consequence for the victim"]
    EOS_ACCPTDR_None = 0,
    #[doc = " Player character is temporarily incapacitated and requires assistance to recover"]
    EOS_ACCPTDR_Downed = 1,
    #[doc = " Player character is permanently incapacitated and cannot recover (e.g. dead)"]
    EOS_ACCPTDR_Eliminated = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatCommon_Vec3f {
    #[doc = " X axis coordinate - forward direction"]
    pub x: f32,
    #[doc = " Y axis coordinate - right direction"]
    pub y: f32,
    #[doc = " Z axis coordinate - up direction"]
    pub z: f32,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatCommon_Vec3f() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatCommon_Vec3f> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatCommon_Vec3f>(),
        12usize,
        concat!("Size of: ", stringify!(_tagEOS_AntiCheatCommon_Vec3f))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatCommon_Vec3f>(),
        4usize,
        concat!("Alignment of ", stringify!(_tagEOS_AntiCheatCommon_Vec3f))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_Vec3f),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_Vec3f),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_Vec3f),
            "::",
            stringify!(z)
        )
    );
}
pub type EOS_AntiCheatCommon_Vec3f = _tagEOS_AntiCheatCommon_Vec3f;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatCommon_Quat {
    #[doc = " W component - scalar part"]
    pub w: f32,
    #[doc = " X component - forward direction"]
    pub x: f32,
    #[doc = " Y component - right direction"]
    pub y: f32,
    #[doc = " Z component - up direction"]
    pub z: f32,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatCommon_Quat() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatCommon_Quat> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatCommon_Quat>(),
        16usize,
        concat!("Size of: ", stringify!(_tagEOS_AntiCheatCommon_Quat))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatCommon_Quat>(),
        4usize,
        concat!("Alignment of ", stringify!(_tagEOS_AntiCheatCommon_Quat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_Quat),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_Quat),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_Quat),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_Quat),
            "::",
            stringify!(z)
        )
    );
}
pub type EOS_AntiCheatCommon_Quat = _tagEOS_AntiCheatCommon_Quat;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatCommon_OnMessageToClientCallbackInfo {
    #[doc = " Caller-specified context data"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The identifier of the client/peer that this message must be delivered to. See the RegisterClient and RegisterPeer functions."]
    pub ClientHandle: EOS_AntiCheatCommon_ClientHandle,
    #[doc = " The message data that must be sent to the client"]
    pub MessageData: *const ::std::os::raw::c_void,
    #[doc = " The size in bytes of MessageData"]
    pub MessageDataSizeBytes: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatCommon_OnMessageToClientCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatCommon_OnMessageToClientCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatCommon_OnMessageToClientCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatCommon_OnMessageToClientCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatCommon_OnMessageToClientCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatCommon_OnMessageToClientCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_OnMessageToClientCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_OnMessageToClientCallbackInfo),
            "::",
            stringify!(ClientHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MessageData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_OnMessageToClientCallbackInfo),
            "::",
            stringify!(MessageData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MessageDataSizeBytes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_OnMessageToClientCallbackInfo),
            "::",
            stringify!(MessageDataSizeBytes)
        )
    );
}
pub type EOS_AntiCheatCommon_OnMessageToClientCallbackInfo =
    _tagEOS_AntiCheatCommon_OnMessageToClientCallbackInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo {
    #[doc = " Caller-specified context data"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The identifier of the client/peer that this action applies to. See the RegisterClient and RegisterPeer functions."]
    pub ClientHandle: EOS_AntiCheatCommon_ClientHandle,
    #[doc = " The action that must be applied to the specified client/peer"]
    pub ClientAction: EOS_EAntiCheatCommonClientAction,
    #[doc = " Code indicating the reason for the action. This can be displayed to the affected player."]
    pub ActionReasonCode: EOS_EAntiCheatCommonClientActionReason,
    #[doc = " String containing details about the action reason. This can be displayed to the affected player."]
    pub ActionReasonDetailsString: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo),
            "::",
            stringify!(ClientHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientAction) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo),
            "::",
            stringify!(ClientAction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ActionReasonCode) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo),
            "::",
            stringify!(ActionReasonCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ActionReasonDetailsString) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo),
            "::",
            stringify!(ActionReasonDetailsString)
        )
    );
}
pub type EOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo =
    _tagEOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatCommon_OnClientAuthStatusChangedCallbackInfo {
    #[doc = " Caller-specified context data"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The identifier of the client/peer that this status change applies to. See the RegisterClient and RegisterPeer functions."]
    pub ClientHandle: EOS_AntiCheatCommon_ClientHandle,
    #[doc = " The client/peer's new authentication status"]
    pub ClientAuthStatus: EOS_EAntiCheatCommonClientAuthStatus,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatCommon_OnClientAuthStatusChangedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_AntiCheatCommon_OnClientAuthStatusChangedCallbackInfo,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatCommon_OnClientAuthStatusChangedCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatCommon_OnClientAuthStatusChangedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatCommon_OnClientAuthStatusChangedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatCommon_OnClientAuthStatusChangedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_OnClientAuthStatusChangedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_OnClientAuthStatusChangedCallbackInfo),
            "::",
            stringify!(ClientHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientAuthStatus) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_OnClientAuthStatusChangedCallbackInfo),
            "::",
            stringify!(ClientAuthStatus)
        )
    );
}
pub type EOS_AntiCheatCommon_OnClientAuthStatusChangedCallbackInfo =
    _tagEOS_AntiCheatCommon_OnClientAuthStatusChangedCallbackInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatCommon_SetClientDetailsOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCOMMON_SETCLIENTDETAILS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Locally unique value used in RegisterClient/RegisterPeer"]
    pub ClientHandle: EOS_AntiCheatCommon_ClientHandle,
    #[doc = " General flags associated with this client, if any"]
    pub ClientFlags: EOS_EAntiCheatCommonClientFlags,
    #[doc = " Input device being used by this client, if known"]
    pub ClientInputMethod: EOS_EAntiCheatCommonClientInput,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatCommon_SetClientDetailsOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatCommon_SetClientDetailsOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatCommon_SetClientDetailsOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatCommon_SetClientDetailsOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatCommon_SetClientDetailsOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatCommon_SetClientDetailsOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_SetClientDetailsOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_SetClientDetailsOptions),
            "::",
            stringify!(ClientHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientFlags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_SetClientDetailsOptions),
            "::",
            stringify!(ClientFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientInputMethod) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_SetClientDetailsOptions),
            "::",
            stringify!(ClientInputMethod)
        )
    );
}
pub type EOS_AntiCheatCommon_SetClientDetailsOptions =
    _tagEOS_AntiCheatCommon_SetClientDetailsOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatCommon_SetGameSessionIdOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCOMMON_SETGAMESESSIONID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Game session identifier"]
    pub GameSessionId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatCommon_SetGameSessionIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatCommon_SetGameSessionIdOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatCommon_SetGameSessionIdOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatCommon_SetGameSessionIdOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatCommon_SetGameSessionIdOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatCommon_SetGameSessionIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_SetGameSessionIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GameSessionId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_SetGameSessionIdOptions),
            "::",
            stringify!(GameSessionId)
        )
    );
}
pub type EOS_AntiCheatCommon_SetGameSessionIdOptions =
    _tagEOS_AntiCheatCommon_SetGameSessionIdOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatCommon_RegisterEventParamDef {
    #[doc = " Parameter name. Allowed characters are 0-9, A-Z, a-z, '_', '-'"]
    pub ParamName: *const ::std::os::raw::c_char,
    #[doc = " Parameter type"]
    pub ParamType: EOS_EAntiCheatCommonEventParamType,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatCommon_RegisterEventParamDef() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatCommon_RegisterEventParamDef> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatCommon_RegisterEventParamDef>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatCommon_RegisterEventParamDef)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatCommon_RegisterEventParamDef>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatCommon_RegisterEventParamDef)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ParamName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_RegisterEventParamDef),
            "::",
            stringify!(ParamName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ParamType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_RegisterEventParamDef),
            "::",
            stringify!(ParamType)
        )
    );
}
pub type EOS_AntiCheatCommon_RegisterEventParamDef = _tagEOS_AntiCheatCommon_RegisterEventParamDef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatCommon_RegisterEventOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCOMMON_REGISTEREVENT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Unique event identifier. Must be >= EOS_ANTICHEATCOMMON_REGISTEREVENT_CUSTOMEVENTBASE."]
    pub EventId: u32,
    #[doc = " Name of the custom event. Allowed characters are 0-9, A-Z, a-z, '_', '-'"]
    pub EventName: *const ::std::os::raw::c_char,
    #[doc = " Type of the custom event"]
    pub EventType: EOS_EAntiCheatCommonEventType,
    #[doc = " Number of parameters described in ParamDefs. Must be <= EOS_ANTICHEATCOMMON_REGISTEREVENT_MAX_PARAMDEFSCOUNT."]
    pub ParamDefsCount: u32,
    #[doc = " Pointer to an array of EOS_AntiCheatCommon_RegisterEventParamDef with ParamDefsCount elements"]
    pub ParamDefs: *const EOS_AntiCheatCommon_RegisterEventParamDef,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatCommon_RegisterEventOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatCommon_RegisterEventOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatCommon_RegisterEventOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatCommon_RegisterEventOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatCommon_RegisterEventOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatCommon_RegisterEventOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_RegisterEventOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EventId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_RegisterEventOptions),
            "::",
            stringify!(EventId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EventName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_RegisterEventOptions),
            "::",
            stringify!(EventName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EventType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_RegisterEventOptions),
            "::",
            stringify!(EventType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ParamDefsCount) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_RegisterEventOptions),
            "::",
            stringify!(ParamDefsCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ParamDefs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_RegisterEventOptions),
            "::",
            stringify!(ParamDefs)
        )
    );
}
pub type EOS_AntiCheatCommon_RegisterEventOptions = _tagEOS_AntiCheatCommon_RegisterEventOptions;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _tagEOS_AntiCheatCommon_LogEventParamPair {
    #[doc = " Parameter type"]
    pub ParamValueType: EOS_EAntiCheatCommonEventParamType,
    #[doc = " Parameter value"]
    pub ParamValue: _tagEOS_AntiCheatCommon_LogEventParamPair__bindgen_ty_1,
}
#[doc = " Parameter value"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _tagEOS_AntiCheatCommon_LogEventParamPair__bindgen_ty_1 {
    pub ClientHandle: EOS_AntiCheatCommon_ClientHandle,
    pub String: *const ::std::os::raw::c_char,
    pub UInt32: u32,
    pub Int32: i32,
    pub UInt64: u64,
    pub Int64: i64,
    pub Vec3f: EOS_AntiCheatCommon_Vec3f,
    pub Quat: EOS_AntiCheatCommon_Quat,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatCommon_LogEventParamPair__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatCommon_LogEventParamPair__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatCommon_LogEventParamPair__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatCommon_LogEventParamPair__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatCommon_LogEventParamPair__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatCommon_LogEventParamPair__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogEventParamPair__bindgen_ty_1),
            "::",
            stringify!(ClientHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).String) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogEventParamPair__bindgen_ty_1),
            "::",
            stringify!(String)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UInt32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogEventParamPair__bindgen_ty_1),
            "::",
            stringify!(UInt32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Int32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogEventParamPair__bindgen_ty_1),
            "::",
            stringify!(Int32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UInt64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogEventParamPair__bindgen_ty_1),
            "::",
            stringify!(UInt64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Int64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogEventParamPair__bindgen_ty_1),
            "::",
            stringify!(Int64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Vec3f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogEventParamPair__bindgen_ty_1),
            "::",
            stringify!(Vec3f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Quat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogEventParamPair__bindgen_ty_1),
            "::",
            stringify!(Quat)
        )
    );
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatCommon_LogEventParamPair() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatCommon_LogEventParamPair> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatCommon_LogEventParamPair>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatCommon_LogEventParamPair)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatCommon_LogEventParamPair>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatCommon_LogEventParamPair)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ParamValueType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogEventParamPair),
            "::",
            stringify!(ParamValueType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ParamValue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogEventParamPair),
            "::",
            stringify!(ParamValue)
        )
    );
}
pub type EOS_AntiCheatCommon_LogEventParamPair = _tagEOS_AntiCheatCommon_LogEventParamPair;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatCommon_LogEventOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCOMMON_LOGEVENT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Optional client who this event is primarily associated with. If not applicable, use 0."]
    pub ClientHandle: EOS_AntiCheatCommon_ClientHandle,
    #[doc = " Unique event identifier previously configured in RegisterEvent"]
    pub EventId: u32,
    #[doc = " Number of parameters described in Params"]
    pub ParamsCount: u32,
    #[doc = " Set of parameter types previously configured in RegisterEvent, and their values"]
    pub Params: *const EOS_AntiCheatCommon_LogEventParamPair,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatCommon_LogEventOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatCommon_LogEventOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatCommon_LogEventOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatCommon_LogEventOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatCommon_LogEventOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatCommon_LogEventOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogEventOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogEventOptions),
            "::",
            stringify!(ClientHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EventId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogEventOptions),
            "::",
            stringify!(EventId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ParamsCount) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogEventOptions),
            "::",
            stringify!(ParamsCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Params) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogEventOptions),
            "::",
            stringify!(Params)
        )
    );
}
pub type EOS_AntiCheatCommon_LogEventOptions = _tagEOS_AntiCheatCommon_LogEventOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatCommon_LogGameRoundStartOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCOMMON_LOGGAMEROUNDSTART_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Optional game session or match identifier useful for some backend API integrations"]
    pub SessionIdentifier: *const ::std::os::raw::c_char,
    #[doc = " Optional name of the map being played"]
    pub LevelName: *const ::std::os::raw::c_char,
    #[doc = " Optional name of the game mode being played"]
    pub ModeName: *const ::std::os::raw::c_char,
    #[doc = " Optional length of the game round to be played, in seconds. If none, use 0."]
    pub RoundTimeSeconds: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatCommon_LogGameRoundStartOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatCommon_LogGameRoundStartOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatCommon_LogGameRoundStartOptions>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatCommon_LogGameRoundStartOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatCommon_LogGameRoundStartOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatCommon_LogGameRoundStartOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogGameRoundStartOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionIdentifier) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogGameRoundStartOptions),
            "::",
            stringify!(SessionIdentifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LevelName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogGameRoundStartOptions),
            "::",
            stringify!(LevelName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ModeName) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogGameRoundStartOptions),
            "::",
            stringify!(ModeName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RoundTimeSeconds) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogGameRoundStartOptions),
            "::",
            stringify!(RoundTimeSeconds)
        )
    );
}
pub type EOS_AntiCheatCommon_LogGameRoundStartOptions =
    _tagEOS_AntiCheatCommon_LogGameRoundStartOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatCommon_LogGameRoundEndOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCOMMON_LOGGAMEROUNDEND_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Optional identifier for the winning team"]
    pub WinningTeamId: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatCommon_LogGameRoundEndOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatCommon_LogGameRoundEndOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatCommon_LogGameRoundEndOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatCommon_LogGameRoundEndOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatCommon_LogGameRoundEndOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatCommon_LogGameRoundEndOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogGameRoundEndOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WinningTeamId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogGameRoundEndOptions),
            "::",
            stringify!(WinningTeamId)
        )
    );
}
pub type EOS_AntiCheatCommon_LogGameRoundEndOptions =
    _tagEOS_AntiCheatCommon_LogGameRoundEndOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatCommon_LogPlayerSpawnOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCOMMON_LOGPLAYERSPAWN_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Locally unique value used in RegisterClient/RegisterPeer"]
    pub SpawnedPlayerHandle: EOS_AntiCheatCommon_ClientHandle,
    #[doc = " Optional identifier for the player's team. If none, use 0."]
    pub TeamId: u32,
    #[doc = " Optional identifier for the player's character. If none, use 0."]
    pub CharacterId: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatCommon_LogPlayerSpawnOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatCommon_LogPlayerSpawnOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatCommon_LogPlayerSpawnOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerSpawnOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatCommon_LogPlayerSpawnOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerSpawnOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerSpawnOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SpawnedPlayerHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerSpawnOptions),
            "::",
            stringify!(SpawnedPlayerHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TeamId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerSpawnOptions),
            "::",
            stringify!(TeamId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CharacterId) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerSpawnOptions),
            "::",
            stringify!(CharacterId)
        )
    );
}
pub type EOS_AntiCheatCommon_LogPlayerSpawnOptions = _tagEOS_AntiCheatCommon_LogPlayerSpawnOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatCommon_LogPlayerDespawnOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCOMMON_LOGPLAYERDESPAWN_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Locally unique value used in RegisterClient/RegisterPeer"]
    pub DespawnedPlayerHandle: EOS_AntiCheatCommon_ClientHandle,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatCommon_LogPlayerDespawnOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatCommon_LogPlayerDespawnOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatCommon_LogPlayerDespawnOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerDespawnOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatCommon_LogPlayerDespawnOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerDespawnOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerDespawnOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DespawnedPlayerHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerDespawnOptions),
            "::",
            stringify!(DespawnedPlayerHandle)
        )
    );
}
pub type EOS_AntiCheatCommon_LogPlayerDespawnOptions =
    _tagEOS_AntiCheatCommon_LogPlayerDespawnOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatCommon_LogPlayerReviveOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCOMMON_LOGPLAYERREVIVE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Locally unique value used in RegisterClient/RegisterPeer"]
    pub RevivedPlayerHandle: EOS_AntiCheatCommon_ClientHandle,
    #[doc = " Locally unique value used in RegisterClient/RegisterPeer"]
    pub ReviverPlayerHandle: EOS_AntiCheatCommon_ClientHandle,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatCommon_LogPlayerReviveOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatCommon_LogPlayerReviveOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatCommon_LogPlayerReviveOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerReviveOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatCommon_LogPlayerReviveOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerReviveOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerReviveOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RevivedPlayerHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerReviveOptions),
            "::",
            stringify!(RevivedPlayerHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReviverPlayerHandle) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerReviveOptions),
            "::",
            stringify!(ReviverPlayerHandle)
        )
    );
}
pub type EOS_AntiCheatCommon_LogPlayerReviveOptions =
    _tagEOS_AntiCheatCommon_LogPlayerReviveOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatCommon_LogPlayerTickOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCOMMON_LOGPLAYERTICK_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Locally unique value used in RegisterClient/RegisterPeer"]
    pub PlayerHandle: EOS_AntiCheatCommon_ClientHandle,
    #[doc = " Player's current world position as a 3D vector"]
    pub PlayerPosition: *mut EOS_AntiCheatCommon_Vec3f,
    #[doc = " Player's view rotation as a quaternion"]
    pub PlayerViewRotation: *mut EOS_AntiCheatCommon_Quat,
    #[doc = " True if the player's view is zoomed (e.g. using a sniper rifle), otherwise false"]
    pub bIsPlayerViewZoomed: EOS_Bool,
    #[doc = " Player's current health value"]
    pub PlayerHealth: f32,
    #[doc = " Any movement state applicable"]
    pub PlayerMovementState: EOS_EAntiCheatCommonPlayerMovementState,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatCommon_LogPlayerTickOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatCommon_LogPlayerTickOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatCommon_LogPlayerTickOptions>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTickOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatCommon_LogPlayerTickOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTickOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTickOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PlayerHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTickOptions),
            "::",
            stringify!(PlayerHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PlayerPosition) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTickOptions),
            "::",
            stringify!(PlayerPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PlayerViewRotation) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTickOptions),
            "::",
            stringify!(PlayerViewRotation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsPlayerViewZoomed) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTickOptions),
            "::",
            stringify!(bIsPlayerViewZoomed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PlayerHealth) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTickOptions),
            "::",
            stringify!(PlayerHealth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PlayerMovementState) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTickOptions),
            "::",
            stringify!(PlayerMovementState)
        )
    );
}
pub type EOS_AntiCheatCommon_LogPlayerTickOptions = _tagEOS_AntiCheatCommon_LogPlayerTickOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatCommon_LogPlayerUseWeaponData {
    #[doc = " Locally unique value used in RegisterClient/RegisterPeer"]
    pub PlayerHandle: EOS_AntiCheatCommon_ClientHandle,
    #[doc = " Attack origin world position as a 3D vector"]
    pub PlayerPosition: *mut EOS_AntiCheatCommon_Vec3f,
    #[doc = " Attack direction as a quaternion"]
    pub PlayerViewRotation: *mut EOS_AntiCheatCommon_Quat,
    #[doc = " True if the player's view is zoomed (e.g. using a sniper rifle), otherwise false"]
    pub bIsPlayerViewZoomed: EOS_Bool,
    #[doc = " Set to true if the player is using a melee attack, otherwise false"]
    pub bIsMeleeAttack: EOS_Bool,
    #[doc = " Name of the weapon used. Will be truncated to EOS_ANTICHEATCOMMON_LOGPLAYERUSEWEAPON_WEAPONNAME_MAX_LENGTH bytes if longer."]
    pub WeaponName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatCommon_LogPlayerUseWeaponData() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatCommon_LogPlayerUseWeaponData> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatCommon_LogPlayerUseWeaponData>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerUseWeaponData)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatCommon_LogPlayerUseWeaponData>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerUseWeaponData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PlayerHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerUseWeaponData),
            "::",
            stringify!(PlayerHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PlayerPosition) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerUseWeaponData),
            "::",
            stringify!(PlayerPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PlayerViewRotation) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerUseWeaponData),
            "::",
            stringify!(PlayerViewRotation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsPlayerViewZoomed) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerUseWeaponData),
            "::",
            stringify!(bIsPlayerViewZoomed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsMeleeAttack) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerUseWeaponData),
            "::",
            stringify!(bIsMeleeAttack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WeaponName) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerUseWeaponData),
            "::",
            stringify!(WeaponName)
        )
    );
}
pub type EOS_AntiCheatCommon_LogPlayerUseWeaponData =
    _tagEOS_AntiCheatCommon_LogPlayerUseWeaponData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatCommon_LogPlayerUseWeaponOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCOMMON_LOGPLAYERUSEWEAPON_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Struct containing detailed information about a weapon use event"]
    pub UseWeaponData: *mut EOS_AntiCheatCommon_LogPlayerUseWeaponData,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatCommon_LogPlayerUseWeaponOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatCommon_LogPlayerUseWeaponOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatCommon_LogPlayerUseWeaponOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerUseWeaponOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatCommon_LogPlayerUseWeaponOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerUseWeaponOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerUseWeaponOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UseWeaponData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerUseWeaponOptions),
            "::",
            stringify!(UseWeaponData)
        )
    );
}
pub type EOS_AntiCheatCommon_LogPlayerUseWeaponOptions =
    _tagEOS_AntiCheatCommon_LogPlayerUseWeaponOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatCommon_LogPlayerUseAbilityOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCOMMON_LOGPLAYERUSEABILITY_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Locally unique value used in RegisterClient/RegisterPeer"]
    pub PlayerHandle: EOS_AntiCheatCommon_ClientHandle,
    #[doc = " Game defined unique identifier for the ability being used"]
    pub AbilityId: u32,
    #[doc = " Duration of the ability effect in milliseconds. If not applicable, use 0."]
    pub AbilityDurationMs: u32,
    #[doc = " Cooldown until the ability can be used again in milliseconds. If not applicable, use 0."]
    pub AbilityCooldownMs: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatCommon_LogPlayerUseAbilityOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatCommon_LogPlayerUseAbilityOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatCommon_LogPlayerUseAbilityOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerUseAbilityOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatCommon_LogPlayerUseAbilityOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerUseAbilityOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerUseAbilityOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PlayerHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerUseAbilityOptions),
            "::",
            stringify!(PlayerHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AbilityId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerUseAbilityOptions),
            "::",
            stringify!(AbilityId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AbilityDurationMs) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerUseAbilityOptions),
            "::",
            stringify!(AbilityDurationMs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AbilityCooldownMs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerUseAbilityOptions),
            "::",
            stringify!(AbilityCooldownMs)
        )
    );
}
pub type EOS_AntiCheatCommon_LogPlayerUseAbilityOptions =
    _tagEOS_AntiCheatCommon_LogPlayerUseAbilityOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatCommon_LogPlayerTakeDamageOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCOMMON_LOGPLAYERTAKEDAMAGE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Locally unique value used in RegisterClient/RegisterPeer"]
    pub VictimPlayerHandle: EOS_AntiCheatCommon_ClientHandle,
    #[doc = " Victim player's current world position as a 3D vector"]
    pub VictimPlayerPosition: *mut EOS_AntiCheatCommon_Vec3f,
    #[doc = " Victim player's view rotation as a quaternion"]
    pub VictimPlayerViewRotation: *mut EOS_AntiCheatCommon_Quat,
    #[doc = " Locally unique value used in RegisterClient/RegisterPeer if applicable, otherwise 0."]
    pub AttackerPlayerHandle: EOS_AntiCheatCommon_ClientHandle,
    #[doc = " Attacker player's current world position as a 3D vector if applicable, otherwise NULL."]
    pub AttackerPlayerPosition: *mut EOS_AntiCheatCommon_Vec3f,
    #[doc = " Attacker player's view rotation as a quaternion if applicable, otherwise NULL."]
    pub AttackerPlayerViewRotation: *mut EOS_AntiCheatCommon_Quat,
    #[doc = " True if the damage was applied instantly at the time of attack from the game\n simulation's perspective, otherwise false (simulated ballistics, arrow, etc)."]
    pub bIsHitscanAttack: EOS_Bool,
    #[doc = " True if there is a visible line of sight between the attacker and the victim at the time\n that damage is being applied, false if there is an obstacle like a wall or terrain in\n the way. For some situations like melee or hitscan weapons this is trivially\n true, for others like projectiles with simulated physics it may not be e.g. a player\n could fire a slow moving projectile and then move behind cover before it strikes.\n\n This can be an estimate, or can simply be always set to true if it is not feasible\n to compute in your game."]
    pub bHasLineOfSight: EOS_Bool,
    #[doc = " True if this was a critical hit that causes extra damage (e.g. headshot)"]
    pub bIsCriticalHit: EOS_Bool,
    #[doc = " Deprecated - use DamagePosition instead"]
    pub HitBoneId_DEPRECATED: u32,
    #[doc = " Number of health points that the victim lost due to this damage event"]
    pub DamageTaken: f32,
    #[doc = " Number of health points that the victim has remaining after this damage event"]
    pub HealthRemaining: f32,
    #[doc = " Source of the damage event"]
    pub DamageSource: EOS_EAntiCheatCommonPlayerTakeDamageSource,
    #[doc = " Type of the damage being applied"]
    pub DamageType: EOS_EAntiCheatCommonPlayerTakeDamageType,
    #[doc = " Result of the damage for the victim, if any"]
    pub DamageResult: EOS_EAntiCheatCommonPlayerTakeDamageResult,
    #[doc = " PlayerUseWeaponData associated with this damage event if available, otherwise NULL"]
    pub PlayerUseWeaponData: *mut EOS_AntiCheatCommon_LogPlayerUseWeaponData,
    #[doc = " Time in milliseconds since the associated PlayerUseWeaponData event occurred if available, otherwise 0"]
    pub TimeSincePlayerUseWeaponMs: u32,
    #[doc = " World position where damage hit the victim as a 3D vector if available, otherwise NULL"]
    pub DamagePosition: *mut EOS_AntiCheatCommon_Vec3f,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatCommon_LogPlayerTakeDamageOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatCommon_LogPlayerTakeDamageOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatCommon_LogPlayerTakeDamageOptions>(),
        120usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTakeDamageOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatCommon_LogPlayerTakeDamageOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTakeDamageOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTakeDamageOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VictimPlayerHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTakeDamageOptions),
            "::",
            stringify!(VictimPlayerHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VictimPlayerPosition) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTakeDamageOptions),
            "::",
            stringify!(VictimPlayerPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VictimPlayerViewRotation) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTakeDamageOptions),
            "::",
            stringify!(VictimPlayerViewRotation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AttackerPlayerHandle) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTakeDamageOptions),
            "::",
            stringify!(AttackerPlayerHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AttackerPlayerPosition) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTakeDamageOptions),
            "::",
            stringify!(AttackerPlayerPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AttackerPlayerViewRotation) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTakeDamageOptions),
            "::",
            stringify!(AttackerPlayerViewRotation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsHitscanAttack) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTakeDamageOptions),
            "::",
            stringify!(bIsHitscanAttack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bHasLineOfSight) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTakeDamageOptions),
            "::",
            stringify!(bHasLineOfSight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsCriticalHit) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTakeDamageOptions),
            "::",
            stringify!(bIsCriticalHit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HitBoneId_DEPRECATED) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTakeDamageOptions),
            "::",
            stringify!(HitBoneId_DEPRECATED)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DamageTaken) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTakeDamageOptions),
            "::",
            stringify!(DamageTaken)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HealthRemaining) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTakeDamageOptions),
            "::",
            stringify!(HealthRemaining)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DamageSource) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTakeDamageOptions),
            "::",
            stringify!(DamageSource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DamageType) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTakeDamageOptions),
            "::",
            stringify!(DamageType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DamageResult) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTakeDamageOptions),
            "::",
            stringify!(DamageResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PlayerUseWeaponData) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTakeDamageOptions),
            "::",
            stringify!(PlayerUseWeaponData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeSincePlayerUseWeaponMs) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTakeDamageOptions),
            "::",
            stringify!(TimeSincePlayerUseWeaponMs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DamagePosition) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatCommon_LogPlayerTakeDamageOptions),
            "::",
            stringify!(DamagePosition)
        )
    );
}
pub type EOS_AntiCheatCommon_LogPlayerTakeDamageOptions =
    _tagEOS_AntiCheatCommon_LogPlayerTakeDamageOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_AntiCheatClientHandle {
    _unused: [u8; 0],
}
pub type EOS_HAntiCheatClient = *mut EOS_AntiCheatClientHandle;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EAntiCheatClientMode {
    #[doc = " Not used"]
    EOS_ACCM_Invalid = 0,
    #[doc = " Dedicated or listen server mode"]
    EOS_ACCM_ClientServer = 1,
    #[doc = " Full mesh peer-to-peer mode"]
    EOS_ACCM_PeerToPeer = 2,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EAntiCheatClientViolationType {
    #[doc = " Not used"]
    EOS_ACCVT_Invalid = 0,
    #[doc = " An anti-cheat asset integrity catalog file could not be found"]
    EOS_ACCVT_IntegrityCatalogNotFound = 1,
    #[doc = " An anti-cheat asset integrity catalog file is corrupt or invalid"]
    EOS_ACCVT_IntegrityCatalogError = 2,
    #[doc = " An anti-cheat asset integrity catalog file's certificate has been revoked."]
    EOS_ACCVT_IntegrityCatalogCertificateRevoked = 3,
    #[doc = " The primary anti-cheat asset integrity catalog does not include an entry for the game's\n main executable, which is required."]
    EOS_ACCVT_IntegrityCatalogMissingMainExecutable = 4,
    #[doc = " A disallowed game file modification was detected"]
    EOS_ACCVT_GameFileMismatch = 5,
    #[doc = " A disallowed game file removal was detected"]
    EOS_ACCVT_RequiredGameFileNotFound = 6,
    #[doc = " A disallowed game file addition was detected"]
    EOS_ACCVT_UnknownGameFileForbidden = 7,
    #[doc = " A system file failed an integrity check"]
    EOS_ACCVT_SystemFileUntrusted = 8,
    #[doc = " A disallowed code module was loaded into the game process"]
    EOS_ACCVT_ForbiddenModuleLoaded = 9,
    #[doc = " A disallowed game process memory modification was detected"]
    EOS_ACCVT_CorruptedMemory = 10,
    #[doc = " A disallowed tool was detected running in the system"]
    EOS_ACCVT_ForbiddenToolDetected = 11,
    #[doc = " An internal anti-cheat integrity check failed"]
    EOS_ACCVT_InternalAntiCheatViolation = 12,
    #[doc = " Integrity checks on messages between the game client and game server failed"]
    EOS_ACCVT_CorruptedNetworkMessageFlow = 13,
    #[doc = " The game is running inside a disallowed virtual machine"]
    EOS_ACCVT_VirtualMachineNotAllowed = 14,
    #[doc = " A forbidden operating system configuration was detected"]
    EOS_ACCVT_ForbiddenSystemConfiguration = 15,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatClient_OnMessageToServerCallbackInfo {
    #[doc = " Caller-specified context data"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The message data that must be sent to the server"]
    pub MessageData: *const ::std::os::raw::c_void,
    #[doc = " The size in bytes of MessageData"]
    pub MessageDataSizeBytes: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatClient_OnMessageToServerCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatClient_OnMessageToServerCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatClient_OnMessageToServerCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatClient_OnMessageToServerCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatClient_OnMessageToServerCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatClient_OnMessageToServerCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_OnMessageToServerCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MessageData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_OnMessageToServerCallbackInfo),
            "::",
            stringify!(MessageData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MessageDataSizeBytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_OnMessageToServerCallbackInfo),
            "::",
            stringify!(MessageDataSizeBytes)
        )
    );
}
pub type EOS_AntiCheatClient_OnMessageToServerCallbackInfo =
    _tagEOS_AntiCheatClient_OnMessageToServerCallbackInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatClient_OnClientIntegrityViolatedCallbackInfo {
    #[doc = " Caller-specified context data"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Code describing the violation that occurred"]
    pub ViolationType: EOS_EAntiCheatClientViolationType,
    #[doc = " String describing the violation which should be displayed to the user"]
    pub ViolationMessage: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatClient_OnClientIntegrityViolatedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_AntiCheatClient_OnClientIntegrityViolatedCallbackInfo,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatClient_OnClientIntegrityViolatedCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatClient_OnClientIntegrityViolatedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatClient_OnClientIntegrityViolatedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatClient_OnClientIntegrityViolatedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_OnClientIntegrityViolatedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ViolationType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_OnClientIntegrityViolatedCallbackInfo),
            "::",
            stringify!(ViolationType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ViolationMessage) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_OnClientIntegrityViolatedCallbackInfo),
            "::",
            stringify!(ViolationMessage)
        )
    );
}
pub type EOS_AntiCheatClient_OnClientIntegrityViolatedCallbackInfo =
    _tagEOS_AntiCheatClient_OnClientIntegrityViolatedCallbackInfo;
pub type EOS_AntiCheatClient_OnMessageToServerCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_AntiCheatClient_OnMessageToServerCallbackInfo),
>;
pub type EOS_AntiCheatClient_OnClientIntegrityViolatedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_AntiCheatClient_OnClientIntegrityViolatedCallbackInfo),
>;
pub type EOS_AntiCheatClient_OnMessageToPeerCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_AntiCheatCommon_OnMessageToClientCallbackInfo),
>;
pub type EOS_AntiCheatClient_OnPeerActionRequiredCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo),
>;
pub type EOS_AntiCheatClient_OnPeerAuthStatusChangedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_AntiCheatCommon_OnClientAuthStatusChangedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatClient_AddNotifyMessageToServerOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCLIENT_ADDNOTIFYMESSAGETOSERVER_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatClient_AddNotifyMessageToServerOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatClient_AddNotifyMessageToServerOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatClient_AddNotifyMessageToServerOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatClient_AddNotifyMessageToServerOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatClient_AddNotifyMessageToServerOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatClient_AddNotifyMessageToServerOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_AddNotifyMessageToServerOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_AntiCheatClient_AddNotifyMessageToServerOptions =
    _tagEOS_AntiCheatClient_AddNotifyMessageToServerOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatClient_AddNotifyMessageToPeerOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCLIENT_ADDNOTIFYMESSAGETOPEER_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatClient_AddNotifyMessageToPeerOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatClient_AddNotifyMessageToPeerOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatClient_AddNotifyMessageToPeerOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatClient_AddNotifyMessageToPeerOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatClient_AddNotifyMessageToPeerOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatClient_AddNotifyMessageToPeerOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_AddNotifyMessageToPeerOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_AntiCheatClient_AddNotifyMessageToPeerOptions =
    _tagEOS_AntiCheatClient_AddNotifyMessageToPeerOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatClient_AddNotifyPeerActionRequiredOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCLIENT_ADDNOTIFYPEERACTIONREQUIRED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatClient_AddNotifyPeerActionRequiredOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_AntiCheatClient_AddNotifyPeerActionRequiredOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatClient_AddNotifyPeerActionRequiredOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatClient_AddNotifyPeerActionRequiredOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatClient_AddNotifyPeerActionRequiredOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatClient_AddNotifyPeerActionRequiredOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_AddNotifyPeerActionRequiredOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_AntiCheatClient_AddNotifyPeerActionRequiredOptions =
    _tagEOS_AntiCheatClient_AddNotifyPeerActionRequiredOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatClient_AddNotifyPeerAuthStatusChangedOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCLIENT_ADDNOTIFYPEERAUTHSTATUSCHANGED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatClient_AddNotifyPeerAuthStatusChangedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_AntiCheatClient_AddNotifyPeerAuthStatusChangedOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatClient_AddNotifyPeerAuthStatusChangedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatClient_AddNotifyPeerAuthStatusChangedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatClient_AddNotifyPeerAuthStatusChangedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatClient_AddNotifyPeerAuthStatusChangedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_AddNotifyPeerAuthStatusChangedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_AntiCheatClient_AddNotifyPeerAuthStatusChangedOptions =
    _tagEOS_AntiCheatClient_AddNotifyPeerAuthStatusChangedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatClient_AddNotifyClientIntegrityViolatedOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCLIENT_ADDNOTIFYPEERAUTHSTATUSCHANGED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatClient_AddNotifyClientIntegrityViolatedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_AntiCheatClient_AddNotifyClientIntegrityViolatedOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatClient_AddNotifyClientIntegrityViolatedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatClient_AddNotifyClientIntegrityViolatedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatClient_AddNotifyClientIntegrityViolatedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatClient_AddNotifyClientIntegrityViolatedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_AddNotifyClientIntegrityViolatedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_AntiCheatClient_AddNotifyClientIntegrityViolatedOptions =
    _tagEOS_AntiCheatClient_AddNotifyClientIntegrityViolatedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatClient_BeginSessionOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCLIENT_BEGINSESSION_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Logged in user identifier from earlier call to EOS_Connect_Login family of functions"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Operating mode"]
    pub Mode: EOS_EAntiCheatClientMode,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatClient_BeginSessionOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatClient_BeginSessionOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatClient_BeginSessionOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatClient_BeginSessionOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatClient_BeginSessionOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatClient_BeginSessionOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_BeginSessionOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_BeginSessionOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_BeginSessionOptions),
            "::",
            stringify!(Mode)
        )
    );
}
pub type EOS_AntiCheatClient_BeginSessionOptions = _tagEOS_AntiCheatClient_BeginSessionOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatClient_EndSessionOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCLIENT_ENDSESSION_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatClient_EndSessionOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatClient_EndSessionOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatClient_EndSessionOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatClient_EndSessionOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatClient_EndSessionOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatClient_EndSessionOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_EndSessionOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_AntiCheatClient_EndSessionOptions = _tagEOS_AntiCheatClient_EndSessionOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatClient_AddExternalIntegrityCatalogOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCLIENT_ADDEXTERNALINTEGRITYCATALOG_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " UTF-8 path to the .bin catalog file to add"]
    pub PathToBinFile: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatClient_AddExternalIntegrityCatalogOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_AntiCheatClient_AddExternalIntegrityCatalogOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatClient_AddExternalIntegrityCatalogOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatClient_AddExternalIntegrityCatalogOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatClient_AddExternalIntegrityCatalogOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatClient_AddExternalIntegrityCatalogOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_AddExternalIntegrityCatalogOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PathToBinFile) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_AddExternalIntegrityCatalogOptions),
            "::",
            stringify!(PathToBinFile)
        )
    );
}
pub type EOS_AntiCheatClient_AddExternalIntegrityCatalogOptions =
    _tagEOS_AntiCheatClient_AddExternalIntegrityCatalogOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatClient_ReceiveMessageFromServerOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCLIENT_RECEIVEMESSAGEFROMSERVER_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The size of the data received"]
    pub DataLengthBytes: u32,
    #[doc = " The data received"]
    pub Data: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatClient_ReceiveMessageFromServerOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatClient_ReceiveMessageFromServerOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatClient_ReceiveMessageFromServerOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatClient_ReceiveMessageFromServerOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatClient_ReceiveMessageFromServerOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatClient_ReceiveMessageFromServerOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_ReceiveMessageFromServerOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataLengthBytes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_ReceiveMessageFromServerOptions),
            "::",
            stringify!(DataLengthBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_ReceiveMessageFromServerOptions),
            "::",
            stringify!(Data)
        )
    );
}
pub type EOS_AntiCheatClient_ReceiveMessageFromServerOptions =
    _tagEOS_AntiCheatClient_ReceiveMessageFromServerOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatClient_GetProtectMessageOutputLengthOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCLIENT_GETPROTECTMESSAGEOUTPUTLENGTH_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Length in bytes of input"]
    pub DataLengthBytes: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatClient_GetProtectMessageOutputLengthOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_AntiCheatClient_GetProtectMessageOutputLengthOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatClient_GetProtectMessageOutputLengthOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatClient_GetProtectMessageOutputLengthOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatClient_GetProtectMessageOutputLengthOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatClient_GetProtectMessageOutputLengthOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_GetProtectMessageOutputLengthOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataLengthBytes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_GetProtectMessageOutputLengthOptions),
            "::",
            stringify!(DataLengthBytes)
        )
    );
}
pub type EOS_AntiCheatClient_GetProtectMessageOutputLengthOptions =
    _tagEOS_AntiCheatClient_GetProtectMessageOutputLengthOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatClient_ProtectMessageOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCLIENT_PROTECTMESSAGE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Length in bytes of input"]
    pub DataLengthBytes: u32,
    #[doc = " The data to encrypt"]
    pub Data: *const ::std::os::raw::c_void,
    #[doc = " The size in bytes of OutBuffer"]
    pub OutBufferSizeBytes: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatClient_ProtectMessageOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatClient_ProtectMessageOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatClient_ProtectMessageOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatClient_ProtectMessageOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatClient_ProtectMessageOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatClient_ProtectMessageOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_ProtectMessageOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataLengthBytes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_ProtectMessageOptions),
            "::",
            stringify!(DataLengthBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_ProtectMessageOptions),
            "::",
            stringify!(Data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OutBufferSizeBytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_ProtectMessageOptions),
            "::",
            stringify!(OutBufferSizeBytes)
        )
    );
}
pub type EOS_AntiCheatClient_ProtectMessageOptions = _tagEOS_AntiCheatClient_ProtectMessageOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatClient_UnprotectMessageOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCLIENT_UNPROTECTMESSAGE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Length in bytes of input"]
    pub DataLengthBytes: u32,
    #[doc = " The data to decrypt"]
    pub Data: *const ::std::os::raw::c_void,
    #[doc = " The size in bytes of OutBuffer"]
    pub OutBufferSizeBytes: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatClient_UnprotectMessageOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatClient_UnprotectMessageOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatClient_UnprotectMessageOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatClient_UnprotectMessageOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatClient_UnprotectMessageOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatClient_UnprotectMessageOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_UnprotectMessageOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataLengthBytes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_UnprotectMessageOptions),
            "::",
            stringify!(DataLengthBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_UnprotectMessageOptions),
            "::",
            stringify!(Data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OutBufferSizeBytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_UnprotectMessageOptions),
            "::",
            stringify!(OutBufferSizeBytes)
        )
    );
}
pub type EOS_AntiCheatClient_UnprotectMessageOptions =
    _tagEOS_AntiCheatClient_UnprotectMessageOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatClient_RegisterPeerOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCLIENT_REGISTERPEER_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Locally unique value describing the remote user (e.g. a player object pointer)"]
    pub PeerHandle: EOS_AntiCheatCommon_ClientHandle,
    #[doc = " Type of remote user being registered"]
    pub ClientType: EOS_EAntiCheatCommonClientType,
    #[doc = " Remote user's platform, if known"]
    pub ClientPlatform: EOS_EAntiCheatCommonClientPlatform,
    #[doc = " Time in seconds to allow newly registered peers to send the initial message containing their token."]
    pub AuthenticationTimeout: u32,
    #[doc = " Deprecated - use PeerProductUserId instead"]
    pub AccountId_DEPRECATED: *const ::std::os::raw::c_char,
    #[doc = " Optional IP address for the remote user. May be null if not available.\n IPv4 format: \"0.0.0.0\"\n IPv6 format: \"0:0:0:0:0:0:0:0\""]
    pub IpAddress: *const ::std::os::raw::c_char,
    #[doc = " EOS_ProductUserId Identifier for the remote user"]
    pub PeerProductUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatClient_RegisterPeerOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatClient_RegisterPeerOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatClient_RegisterPeerOptions>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatClient_RegisterPeerOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatClient_RegisterPeerOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatClient_RegisterPeerOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_RegisterPeerOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PeerHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_RegisterPeerOptions),
            "::",
            stringify!(PeerHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_RegisterPeerOptions),
            "::",
            stringify!(ClientType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientPlatform) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_RegisterPeerOptions),
            "::",
            stringify!(ClientPlatform)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AuthenticationTimeout) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_RegisterPeerOptions),
            "::",
            stringify!(AuthenticationTimeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccountId_DEPRECATED) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_RegisterPeerOptions),
            "::",
            stringify!(AccountId_DEPRECATED)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IpAddress) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_RegisterPeerOptions),
            "::",
            stringify!(IpAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PeerProductUserId) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_RegisterPeerOptions),
            "::",
            stringify!(PeerProductUserId)
        )
    );
}
pub type EOS_AntiCheatClient_RegisterPeerOptions = _tagEOS_AntiCheatClient_RegisterPeerOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatClient_UnregisterPeerOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCLIENT_UNREGISTERPEER_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Locally unique value describing the remote user, as previously passed to EOS_AntiCheatClient_RegisterPeer"]
    pub PeerHandle: EOS_AntiCheatCommon_ClientHandle,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatClient_UnregisterPeerOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatClient_UnregisterPeerOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatClient_UnregisterPeerOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatClient_UnregisterPeerOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatClient_UnregisterPeerOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatClient_UnregisterPeerOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_UnregisterPeerOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PeerHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_UnregisterPeerOptions),
            "::",
            stringify!(PeerHandle)
        )
    );
}
pub type EOS_AntiCheatClient_UnregisterPeerOptions = _tagEOS_AntiCheatClient_UnregisterPeerOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatClient_ReceiveMessageFromPeerOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCLIENT_RECEIVEMESSAGEFROMPEER_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The handle describing the sender of this message"]
    pub PeerHandle: EOS_AntiCheatCommon_ClientHandle,
    #[doc = " The size of the data received"]
    pub DataLengthBytes: u32,
    #[doc = " The data received"]
    pub Data: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatClient_ReceiveMessageFromPeerOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatClient_ReceiveMessageFromPeerOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatClient_ReceiveMessageFromPeerOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatClient_ReceiveMessageFromPeerOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatClient_ReceiveMessageFromPeerOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatClient_ReceiveMessageFromPeerOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_ReceiveMessageFromPeerOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PeerHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_ReceiveMessageFromPeerOptions),
            "::",
            stringify!(PeerHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataLengthBytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_ReceiveMessageFromPeerOptions),
            "::",
            stringify!(DataLengthBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_ReceiveMessageFromPeerOptions),
            "::",
            stringify!(Data)
        )
    );
}
pub type EOS_AntiCheatClient_ReceiveMessageFromPeerOptions =
    _tagEOS_AntiCheatClient_ReceiveMessageFromPeerOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatClient_PollStatusOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATCLIENT_POLLSTATUS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The size of OutMessage in bytes. Recommended size is 256 bytes."]
    pub OutMessageLength: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatClient_PollStatusOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatClient_PollStatusOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatClient_PollStatusOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatClient_PollStatusOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatClient_PollStatusOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatClient_PollStatusOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_PollStatusOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OutMessageLength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatClient_PollStatusOptions),
            "::",
            stringify!(OutMessageLength)
        )
    );
}
pub type EOS_AntiCheatClient_PollStatusOptions = _tagEOS_AntiCheatClient_PollStatusOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_AntiCheatServerHandle {
    _unused: [u8; 0],
}
pub type EOS_HAntiCheatServer = *mut EOS_AntiCheatServerHandle;
pub type EOS_AntiCheatServer_OnMessageToClientCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_AntiCheatCommon_OnMessageToClientCallbackInfo),
>;
pub type EOS_AntiCheatServer_OnClientActionRequiredCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo),
>;
pub type EOS_AntiCheatServer_OnClientAuthStatusChangedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_AntiCheatCommon_OnClientAuthStatusChangedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatServer_AddNotifyMessageToClientOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATSERVER_ADDNOTIFYMESSAGETOCLIENT_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatServer_AddNotifyMessageToClientOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatServer_AddNotifyMessageToClientOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatServer_AddNotifyMessageToClientOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatServer_AddNotifyMessageToClientOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatServer_AddNotifyMessageToClientOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatServer_AddNotifyMessageToClientOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_AddNotifyMessageToClientOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_AntiCheatServer_AddNotifyMessageToClientOptions =
    _tagEOS_AntiCheatServer_AddNotifyMessageToClientOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatServer_AddNotifyClientActionRequiredOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATSERVER_ADDNOTIFYCLIENTACTIONREQUIRED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatServer_AddNotifyClientActionRequiredOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_AntiCheatServer_AddNotifyClientActionRequiredOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatServer_AddNotifyClientActionRequiredOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatServer_AddNotifyClientActionRequiredOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatServer_AddNotifyClientActionRequiredOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatServer_AddNotifyClientActionRequiredOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_AddNotifyClientActionRequiredOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_AntiCheatServer_AddNotifyClientActionRequiredOptions =
    _tagEOS_AntiCheatServer_AddNotifyClientActionRequiredOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatServer_AddNotifyClientAuthStatusChangedOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATSERVER_ADDNOTIFYCLIENTAUTHSTATUSCHANGED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatServer_AddNotifyClientAuthStatusChangedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_AntiCheatServer_AddNotifyClientAuthStatusChangedOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatServer_AddNotifyClientAuthStatusChangedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatServer_AddNotifyClientAuthStatusChangedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatServer_AddNotifyClientAuthStatusChangedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatServer_AddNotifyClientAuthStatusChangedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_AddNotifyClientAuthStatusChangedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_AntiCheatServer_AddNotifyClientAuthStatusChangedOptions =
    _tagEOS_AntiCheatServer_AddNotifyClientAuthStatusChangedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatServer_BeginSessionOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATSERVER_BEGINSESSION_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Time in seconds to allow newly registered clients to complete anti-cheat authentication.\n Recommended value: 60"]
    pub RegisterTimeoutSeconds: u32,
    #[doc = " Optional name of this game server"]
    pub ServerName: *const ::std::os::raw::c_char,
    #[doc = " Gameplay data collection APIs such as LogPlayerTick will be enabled if set to true.\n If you do not use these APIs, it is more efficient to set this value to false."]
    pub bEnableGameplayData: EOS_Bool,
    #[doc = " The Product User ID of the local user who is associated with this session. Dedicated servers should set this to null."]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatServer_BeginSessionOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatServer_BeginSessionOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatServer_BeginSessionOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatServer_BeginSessionOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatServer_BeginSessionOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatServer_BeginSessionOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_BeginSessionOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RegisterTimeoutSeconds) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_BeginSessionOptions),
            "::",
            stringify!(RegisterTimeoutSeconds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ServerName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_BeginSessionOptions),
            "::",
            stringify!(ServerName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bEnableGameplayData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_BeginSessionOptions),
            "::",
            stringify!(bEnableGameplayData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_BeginSessionOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_AntiCheatServer_BeginSessionOptions = _tagEOS_AntiCheatServer_BeginSessionOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatServer_EndSessionOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATSERVER_ENDSESSION_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatServer_EndSessionOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatServer_EndSessionOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatServer_EndSessionOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatServer_EndSessionOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatServer_EndSessionOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatServer_EndSessionOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_EndSessionOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_AntiCheatServer_EndSessionOptions = _tagEOS_AntiCheatServer_EndSessionOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatServer_RegisterClientOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATSERVER_REGISTERCLIENT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Locally unique value describing the remote user (e.g. a player object pointer)"]
    pub ClientHandle: EOS_AntiCheatCommon_ClientHandle,
    #[doc = " Type of remote user being registered"]
    pub ClientType: EOS_EAntiCheatCommonClientType,
    #[doc = " Remote user's platform, if known"]
    pub ClientPlatform: EOS_EAntiCheatCommonClientPlatform,
    #[doc = " DEPRECATED - New code should set this to null and specify UserId instead.\n\n Identifier for the remote user. This is typically a string representation of an\n account ID, but it can be any string which is both unique (two different users will never\n have the same string) and consistent (if the same user connects to this game session\n twice, the same string will be used) in the scope of a single protected game session."]
    pub AccountId_DEPRECATED: *const ::std::os::raw::c_char,
    #[doc = " Optional IP address for the remote user. May be null if not available.\n IPv4 format: \"0.0.0.0\"\n IPv6 format: \"0:0:0:0:0:0:0:0\""]
    pub IpAddress: *const ::std::os::raw::c_char,
    #[doc = " The Product User ID for the remote user who is being registered."]
    pub UserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatServer_RegisterClientOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatServer_RegisterClientOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatServer_RegisterClientOptions>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatServer_RegisterClientOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatServer_RegisterClientOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatServer_RegisterClientOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_RegisterClientOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_RegisterClientOptions),
            "::",
            stringify!(ClientHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_RegisterClientOptions),
            "::",
            stringify!(ClientType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientPlatform) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_RegisterClientOptions),
            "::",
            stringify!(ClientPlatform)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccountId_DEPRECATED) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_RegisterClientOptions),
            "::",
            stringify!(AccountId_DEPRECATED)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IpAddress) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_RegisterClientOptions),
            "::",
            stringify!(IpAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserId) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_RegisterClientOptions),
            "::",
            stringify!(UserId)
        )
    );
}
pub type EOS_AntiCheatServer_RegisterClientOptions = _tagEOS_AntiCheatServer_RegisterClientOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatServer_UnregisterClientOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATSERVER_UNREGISTERCLIENT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Locally unique value describing the remote user, as previously passed to RegisterClient"]
    pub ClientHandle: EOS_AntiCheatCommon_ClientHandle,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatServer_UnregisterClientOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatServer_UnregisterClientOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatServer_UnregisterClientOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatServer_UnregisterClientOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatServer_UnregisterClientOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatServer_UnregisterClientOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_UnregisterClientOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_UnregisterClientOptions),
            "::",
            stringify!(ClientHandle)
        )
    );
}
pub type EOS_AntiCheatServer_UnregisterClientOptions =
    _tagEOS_AntiCheatServer_UnregisterClientOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatServer_ReceiveMessageFromClientOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATSERVER_RECEIVEMESSAGEFROMCLIENT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Locally unique value describing the corresponding remote user, as previously passed to RegisterClient"]
    pub ClientHandle: EOS_AntiCheatCommon_ClientHandle,
    #[doc = " The size of the data received"]
    pub DataLengthBytes: u32,
    #[doc = " The data received"]
    pub Data: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatServer_ReceiveMessageFromClientOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatServer_ReceiveMessageFromClientOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatServer_ReceiveMessageFromClientOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatServer_ReceiveMessageFromClientOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatServer_ReceiveMessageFromClientOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatServer_ReceiveMessageFromClientOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_ReceiveMessageFromClientOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_ReceiveMessageFromClientOptions),
            "::",
            stringify!(ClientHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataLengthBytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_ReceiveMessageFromClientOptions),
            "::",
            stringify!(DataLengthBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_ReceiveMessageFromClientOptions),
            "::",
            stringify!(Data)
        )
    );
}
pub type EOS_AntiCheatServer_ReceiveMessageFromClientOptions =
    _tagEOS_AntiCheatServer_ReceiveMessageFromClientOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatServer_SetClientNetworkStateOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATSERVER_SETCLIENTNETWORKSTATE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Locally unique value describing the remote user (e.g. a player object pointer)"]
    pub ClientHandle: EOS_AntiCheatCommon_ClientHandle,
    #[doc = " True if the network is functioning normally, false if temporarily interrupted"]
    pub bIsNetworkActive: EOS_Bool,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatServer_SetClientNetworkStateOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatServer_SetClientNetworkStateOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatServer_SetClientNetworkStateOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatServer_SetClientNetworkStateOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatServer_SetClientNetworkStateOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatServer_SetClientNetworkStateOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_SetClientNetworkStateOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_SetClientNetworkStateOptions),
            "::",
            stringify!(ClientHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsNetworkActive) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_SetClientNetworkStateOptions),
            "::",
            stringify!(bIsNetworkActive)
        )
    );
}
pub type EOS_AntiCheatServer_SetClientNetworkStateOptions =
    _tagEOS_AntiCheatServer_SetClientNetworkStateOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatServer_GetProtectMessageOutputLengthOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATSERVER_GETPROTECTMESSAGEOUTPUTLENGTH_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Length in bytes of input"]
    pub DataLengthBytes: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatServer_GetProtectMessageOutputLengthOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_AntiCheatServer_GetProtectMessageOutputLengthOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatServer_GetProtectMessageOutputLengthOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatServer_GetProtectMessageOutputLengthOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatServer_GetProtectMessageOutputLengthOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatServer_GetProtectMessageOutputLengthOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_GetProtectMessageOutputLengthOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataLengthBytes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_GetProtectMessageOutputLengthOptions),
            "::",
            stringify!(DataLengthBytes)
        )
    );
}
pub type EOS_AntiCheatServer_GetProtectMessageOutputLengthOptions =
    _tagEOS_AntiCheatServer_GetProtectMessageOutputLengthOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatServer_ProtectMessageOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATSERVER_PROTECTMESSAGE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Locally unique value describing the remote user to whom the message will be sent"]
    pub ClientHandle: EOS_AntiCheatCommon_ClientHandle,
    #[doc = " Length in bytes of input"]
    pub DataLengthBytes: u32,
    #[doc = " The data to encrypt"]
    pub Data: *const ::std::os::raw::c_void,
    #[doc = " The size in bytes of OutBuffer"]
    pub OutBufferSizeBytes: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatServer_ProtectMessageOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatServer_ProtectMessageOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatServer_ProtectMessageOptions>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatServer_ProtectMessageOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatServer_ProtectMessageOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatServer_ProtectMessageOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_ProtectMessageOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_ProtectMessageOptions),
            "::",
            stringify!(ClientHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataLengthBytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_ProtectMessageOptions),
            "::",
            stringify!(DataLengthBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_ProtectMessageOptions),
            "::",
            stringify!(Data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OutBufferSizeBytes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_ProtectMessageOptions),
            "::",
            stringify!(OutBufferSizeBytes)
        )
    );
}
pub type EOS_AntiCheatServer_ProtectMessageOptions = _tagEOS_AntiCheatServer_ProtectMessageOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_AntiCheatServer_UnprotectMessageOptions {
    #[doc = " API Version: Set this to EOS_ANTICHEATSERVER_UNPROTECTMESSAGE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Locally unique value describing the remote user from whom the message was received"]
    pub ClientHandle: EOS_AntiCheatCommon_ClientHandle,
    #[doc = " Length in bytes of input"]
    pub DataLengthBytes: u32,
    #[doc = " The data to decrypt"]
    pub Data: *const ::std::os::raw::c_void,
    #[doc = " The size in bytes of OutBuffer"]
    pub OutBufferSizeBytes: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_AntiCheatServer_UnprotectMessageOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_AntiCheatServer_UnprotectMessageOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_AntiCheatServer_UnprotectMessageOptions>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_AntiCheatServer_UnprotectMessageOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_AntiCheatServer_UnprotectMessageOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_AntiCheatServer_UnprotectMessageOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_UnprotectMessageOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_UnprotectMessageOptions),
            "::",
            stringify!(ClientHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataLengthBytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_UnprotectMessageOptions),
            "::",
            stringify!(DataLengthBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_UnprotectMessageOptions),
            "::",
            stringify!(Data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OutBufferSizeBytes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_AntiCheatServer_UnprotectMessageOptions),
            "::",
            stringify!(OutBufferSizeBytes)
        )
    );
}
pub type EOS_AntiCheatServer_UnprotectMessageOptions =
    _tagEOS_AntiCheatServer_UnprotectMessageOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_ReportsHandle {
    _unused: [u8; 0],
}
pub type EOS_HReports = *mut EOS_ReportsHandle;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EPlayerReportsCategory {
    #[doc = " Not used"]
    EOS_PRC_Invalid = 0,
    #[doc = " The reported player is cheating"]
    EOS_PRC_Cheating = 1,
    #[doc = " The reported player is exploiting the game"]
    EOS_PRC_Exploiting = 2,
    #[doc = " The reported player has an offensive profile, name, etc"]
    EOS_PRC_OffensiveProfile = 3,
    #[doc = " The reported player is being abusive in chat"]
    EOS_PRC_VerbalAbuse = 4,
    #[doc = " The reported player is scamming other players"]
    EOS_PRC_Scamming = 5,
    #[doc = " The reported player is spamming chat"]
    EOS_PRC_Spamming = 6,
    #[doc = " The player is being reported for something else"]
    EOS_PRC_Other = 7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Reports_SendPlayerBehaviorReportOptions {
    #[doc = " API Version: Set this to EOS_REPORTS_SENDPLAYERBEHAVIORREPORT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Product User ID of the reporting player"]
    pub ReporterUserId: EOS_ProductUserId,
    #[doc = " Product User ID of the reported player."]
    pub ReportedUserId: EOS_ProductUserId,
    #[doc = " Category for the player report."]
    pub Category: EOS_EPlayerReportsCategory,
    #[doc = " Optional plain text string associated with the report as UTF-8 encoded null-terminated string.\n\n The length of the message can be at maximum up to EOS_REPORTS_REPORTMESSAGE_MAX_LENGTH bytes\n and any excess characters will be truncated upon sending the report."]
    pub Message: *const ::std::os::raw::c_char,
    #[doc = " Optional JSON string associated with the report as UTF-8 encoded null-terminated string.\n This is intended as a way to associate arbitrary structured context information with a report.\n\n This string needs to be valid JSON, report will fail otherwise.\n The length of the context can be at maximum up to EOS_REPORTS_REPORTCONTEXT_MAX_LENGTH bytes, not including the null terminator, report will fail otherwise."]
    pub Context: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Reports_SendPlayerBehaviorReportOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Reports_SendPlayerBehaviorReportOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Reports_SendPlayerBehaviorReportOptions>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Reports_SendPlayerBehaviorReportOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Reports_SendPlayerBehaviorReportOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Reports_SendPlayerBehaviorReportOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Reports_SendPlayerBehaviorReportOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReporterUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Reports_SendPlayerBehaviorReportOptions),
            "::",
            stringify!(ReporterUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReportedUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Reports_SendPlayerBehaviorReportOptions),
            "::",
            stringify!(ReportedUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Category) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Reports_SendPlayerBehaviorReportOptions),
            "::",
            stringify!(Category)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Message) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Reports_SendPlayerBehaviorReportOptions),
            "::",
            stringify!(Message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Context) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Reports_SendPlayerBehaviorReportOptions),
            "::",
            stringify!(Context)
        )
    );
}
pub type EOS_Reports_SendPlayerBehaviorReportOptions =
    _tagEOS_Reports_SendPlayerBehaviorReportOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Reports_SendPlayerBehaviorReportCompleteCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Reports_SendPlayerBehaviorReport."]
    pub ClientData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_Reports_SendPlayerBehaviorReportCompleteCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Reports_SendPlayerBehaviorReportCompleteCallbackInfo,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Reports_SendPlayerBehaviorReportCompleteCallbackInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Reports_SendPlayerBehaviorReportCompleteCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Reports_SendPlayerBehaviorReportCompleteCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Reports_SendPlayerBehaviorReportCompleteCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Reports_SendPlayerBehaviorReportCompleteCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Reports_SendPlayerBehaviorReportCompleteCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
}
pub type EOS_Reports_SendPlayerBehaviorReportCompleteCallbackInfo =
    _tagEOS_Reports_SendPlayerBehaviorReportCompleteCallbackInfo;
pub type EOS_Reports_OnSendPlayerBehaviorReportCompleteCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Reports_SendPlayerBehaviorReportCompleteCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_SanctionsHandle {
    _unused: [u8; 0],
}
pub type EOS_HSanctions = *mut EOS_SanctionsHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sanctions_PlayerSanction {
    #[doc = " API Version: This will be set to EOS_SANCTIONS_PLAYERSANCTION_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The POSIX timestamp when the sanction was placed"]
    pub TimePlaced: i64,
    #[doc = " The action associated with this sanction"]
    pub Action: *const ::std::os::raw::c_char,
    #[doc = " The POSIX timestamp when the sanction will expire. If the sanction is permanent, this will be 0."]
    pub TimeExpires: i64,
    #[doc = " A unique identifier for this specific sanction"]
    pub ReferenceId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_Sanctions_PlayerSanction() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sanctions_PlayerSanction> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sanctions_PlayerSanction>(),
        40usize,
        concat!("Size of: ", stringify!(_tagEOS_Sanctions_PlayerSanction))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sanctions_PlayerSanction>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sanctions_PlayerSanction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sanctions_PlayerSanction),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimePlaced) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sanctions_PlayerSanction),
            "::",
            stringify!(TimePlaced)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Action) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sanctions_PlayerSanction),
            "::",
            stringify!(Action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeExpires) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sanctions_PlayerSanction),
            "::",
            stringify!(TimeExpires)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReferenceId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sanctions_PlayerSanction),
            "::",
            stringify!(ReferenceId)
        )
    );
}
pub type EOS_Sanctions_PlayerSanction = _tagEOS_Sanctions_PlayerSanction;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sanctions_QueryActivePlayerSanctionsOptions {
    #[doc = " API Version: Set this to EOS_SANCTIONS_QUERYACTIVEPLAYERSANCTIONS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Product User ID of the user whose active sanctions are to be retrieved."]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " The Product User ID of the local user who initiated this request. Dedicated servers should set this to null."]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Sanctions_QueryActivePlayerSanctionsOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sanctions_QueryActivePlayerSanctionsOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sanctions_QueryActivePlayerSanctionsOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sanctions_QueryActivePlayerSanctionsOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sanctions_QueryActivePlayerSanctionsOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sanctions_QueryActivePlayerSanctionsOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sanctions_QueryActivePlayerSanctionsOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sanctions_QueryActivePlayerSanctionsOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sanctions_QueryActivePlayerSanctionsOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Sanctions_QueryActivePlayerSanctionsOptions =
    _tagEOS_Sanctions_QueryActivePlayerSanctionsOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sanctions_QueryActivePlayerSanctionsCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_Sanctions_QueryActivePlayerSanctions."]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Target Product User ID that was passed to EOS_Sanctions_QueryActivePlayerSanctions."]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " The Product User ID of the local user who initiated this request, if applicable."]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Sanctions_QueryActivePlayerSanctionsCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_Sanctions_QueryActivePlayerSanctionsCallbackInfo,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sanctions_QueryActivePlayerSanctionsCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sanctions_QueryActivePlayerSanctionsCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sanctions_QueryActivePlayerSanctionsCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sanctions_QueryActivePlayerSanctionsCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sanctions_QueryActivePlayerSanctionsCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sanctions_QueryActivePlayerSanctionsCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sanctions_QueryActivePlayerSanctionsCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sanctions_QueryActivePlayerSanctionsCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_Sanctions_QueryActivePlayerSanctionsCallbackInfo =
    _tagEOS_Sanctions_QueryActivePlayerSanctionsCallbackInfo;
pub type EOS_Sanctions_OnQueryActivePlayerSanctionsCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_Sanctions_QueryActivePlayerSanctionsCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sanctions_GetPlayerSanctionCountOptions {
    #[doc = " API Version: Set this to EOS_SANCTIONS_GETPLAYERSANCTIONCOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Product User ID of the user whose sanction count should be returned"]
    pub TargetUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_Sanctions_GetPlayerSanctionCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sanctions_GetPlayerSanctionCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sanctions_GetPlayerSanctionCountOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sanctions_GetPlayerSanctionCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sanctions_GetPlayerSanctionCountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sanctions_GetPlayerSanctionCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sanctions_GetPlayerSanctionCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sanctions_GetPlayerSanctionCountOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_Sanctions_GetPlayerSanctionCountOptions =
    _tagEOS_Sanctions_GetPlayerSanctionCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_Sanctions_CopyPlayerSanctionByIndexOptions {
    #[doc = " API Version: Set this to EOS_SANCTIONS_COPYPLAYERSANCTIONBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Product User ID of the user whose active sanctions are to be copied"]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " Index of the sanction to retrieve from the cache"]
    pub SanctionIndex: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_Sanctions_CopyPlayerSanctionByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_Sanctions_CopyPlayerSanctionByIndexOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_Sanctions_CopyPlayerSanctionByIndexOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_Sanctions_CopyPlayerSanctionByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_Sanctions_CopyPlayerSanctionByIndexOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_Sanctions_CopyPlayerSanctionByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sanctions_CopyPlayerSanctionByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sanctions_CopyPlayerSanctionByIndexOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SanctionIndex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_Sanctions_CopyPlayerSanctionByIndexOptions),
            "::",
            stringify!(SanctionIndex)
        )
    );
}
pub type EOS_Sanctions_CopyPlayerSanctionByIndexOptions =
    _tagEOS_Sanctions_CopyPlayerSanctionByIndexOptions;
extern "C" {
    #[doc = " Release the memory associated with a player sanction.\n This must be called on data retrieved from EOS_Sanctions_CopyPlayerSanctionByIndex.\n\n @param Sanction - The sanction data to release.\n\n @see EOS_Sanctions_PlayerSanction\n @see EOS_Sanctions_CopyPlayerSanctionByIndex"]
    pub fn EOS_Sanctions_PlayerSanction_Release(Sanction: *mut EOS_Sanctions_PlayerSanction);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_KWSHandle {
    _unused: [u8; 0],
}
pub type EOS_HKWS = *mut EOS_KWSHandle;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_EKWSPermissionStatus {
    #[doc = " Permission has been granted"]
    EOS_KPS_GRANTED = 0,
    #[doc = " Permission has been rejected"]
    EOS_KPS_REJECTED = 1,
    #[doc = " Permission is still pending approval"]
    EOS_KPS_PENDING = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_KWS_PermissionStatus {
    #[doc = " API Version: Set this to EOS_KWS_PERMISSIONSTATUS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Name of the permission"]
    pub Name: *const ::std::os::raw::c_char,
    #[doc = " Status of the permission"]
    pub Status: EOS_EKWSPermissionStatus,
}
#[test]
fn bindgen_test_layout__tagEOS_KWS_PermissionStatus() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_KWS_PermissionStatus> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_KWS_PermissionStatus>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_KWS_PermissionStatus))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_KWS_PermissionStatus>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_KWS_PermissionStatus))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_PermissionStatus),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_PermissionStatus),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Status) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_PermissionStatus),
            "::",
            stringify!(Status)
        )
    );
}
pub type EOS_KWS_PermissionStatus = _tagEOS_KWS_PermissionStatus;
extern "C" {
    pub fn EOS_KWS_PermissionStatus_Release(PermissionStatus: *mut EOS_KWS_PermissionStatus);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_KWS_QueryAgeGateOptions {
    #[doc = " API Version: Set this to EOS_KWS_QUERYAGEGATE_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_KWS_QueryAgeGateOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_KWS_QueryAgeGateOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_KWS_QueryAgeGateOptions>(),
        4usize,
        concat!("Size of: ", stringify!(_tagEOS_KWS_QueryAgeGateOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_KWS_QueryAgeGateOptions>(),
        4usize,
        concat!("Alignment of ", stringify!(_tagEOS_KWS_QueryAgeGateOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_QueryAgeGateOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_KWS_QueryAgeGateOptions = _tagEOS_KWS_QueryAgeGateOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_KWS_QueryAgeGateCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_KWS_QueryAgeGate"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Country code determined for this request based on the local client's ip address that the backend resolves"]
    pub CountryCode: *const ::std::os::raw::c_char,
    #[doc = " Age of consent in the given country"]
    pub AgeOfConsent: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_KWS_QueryAgeGateCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_KWS_QueryAgeGateCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_KWS_QueryAgeGateCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_KWS_QueryAgeGateCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_KWS_QueryAgeGateCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_KWS_QueryAgeGateCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_QueryAgeGateCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_QueryAgeGateCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CountryCode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_QueryAgeGateCallbackInfo),
            "::",
            stringify!(CountryCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AgeOfConsent) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_QueryAgeGateCallbackInfo),
            "::",
            stringify!(AgeOfConsent)
        )
    );
}
pub type EOS_KWS_QueryAgeGateCallbackInfo = _tagEOS_KWS_QueryAgeGateCallbackInfo;
pub type EOS_KWS_OnQueryAgeGateCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_KWS_QueryAgeGateCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_KWS_CreateUserOptions {
    #[doc = " API Version: Set this to EOS_KWS_CREATEUSER_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Local user creating a KWS entry"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Date of birth in ISO8601 form (YYYY-MM-DD)"]
    pub DateOfBirth: *const ::std::os::raw::c_char,
    #[doc = " Parent email"]
    pub ParentEmail: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_KWS_CreateUserOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_KWS_CreateUserOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_KWS_CreateUserOptions>(),
        32usize,
        concat!("Size of: ", stringify!(_tagEOS_KWS_CreateUserOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_KWS_CreateUserOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_KWS_CreateUserOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_CreateUserOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_CreateUserOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DateOfBirth) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_CreateUserOptions),
            "::",
            stringify!(DateOfBirth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ParentEmail) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_CreateUserOptions),
            "::",
            stringify!(ParentEmail)
        )
    );
}
pub type EOS_KWS_CreateUserOptions = _tagEOS_KWS_CreateUserOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_KWS_CreateUserCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_KWS_CreateUser"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Local user that created a KWS entry"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " KWS UserId created"]
    pub KWSUserId: *const ::std::os::raw::c_char,
    #[doc = " Is this user a minor"]
    pub bIsMinor: EOS_Bool,
}
#[test]
fn bindgen_test_layout__tagEOS_KWS_CreateUserCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_KWS_CreateUserCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_KWS_CreateUserCallbackInfo>(),
        40usize,
        concat!("Size of: ", stringify!(_tagEOS_KWS_CreateUserCallbackInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_KWS_CreateUserCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_KWS_CreateUserCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_CreateUserCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_CreateUserCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_CreateUserCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).KWSUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_CreateUserCallbackInfo),
            "::",
            stringify!(KWSUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsMinor) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_CreateUserCallbackInfo),
            "::",
            stringify!(bIsMinor)
        )
    );
}
pub type EOS_KWS_CreateUserCallbackInfo = _tagEOS_KWS_CreateUserCallbackInfo;
pub type EOS_KWS_OnCreateUserCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_KWS_CreateUserCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_KWS_QueryPermissionsOptions {
    #[doc = " API Version: Set this to EOS_KWS_QUERYPERMISSIONS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Local user querying their permissions"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_KWS_QueryPermissionsOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_KWS_QueryPermissionsOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_KWS_QueryPermissionsOptions>(),
        16usize,
        concat!("Size of: ", stringify!(_tagEOS_KWS_QueryPermissionsOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_KWS_QueryPermissionsOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_KWS_QueryPermissionsOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_QueryPermissionsOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_QueryPermissionsOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_KWS_QueryPermissionsOptions = _tagEOS_KWS_QueryPermissionsOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_KWS_QueryPermissionsCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_KWS_QueryPermissions"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Local user querying their permissions"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " KWS UserId created"]
    pub KWSUserId: *const ::std::os::raw::c_char,
    #[doc = " Date of birth in ISO8601 form (YYYY-MM-DD)"]
    pub DateOfBirth: *const ::std::os::raw::c_char,
    #[doc = " Is this user a minor"]
    pub bIsMinor: EOS_Bool,
    #[doc = " Parent email. This value may be set to an empty string if the originally registered email recipient declined to be the right person to give consent."]
    pub ParentEmail: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_KWS_QueryPermissionsCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_KWS_QueryPermissionsCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_KWS_QueryPermissionsCallbackInfo>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_KWS_QueryPermissionsCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_KWS_QueryPermissionsCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_KWS_QueryPermissionsCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_QueryPermissionsCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_QueryPermissionsCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_QueryPermissionsCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).KWSUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_QueryPermissionsCallbackInfo),
            "::",
            stringify!(KWSUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DateOfBirth) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_QueryPermissionsCallbackInfo),
            "::",
            stringify!(DateOfBirth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsMinor) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_QueryPermissionsCallbackInfo),
            "::",
            stringify!(bIsMinor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ParentEmail) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_QueryPermissionsCallbackInfo),
            "::",
            stringify!(ParentEmail)
        )
    );
}
pub type EOS_KWS_QueryPermissionsCallbackInfo = _tagEOS_KWS_QueryPermissionsCallbackInfo;
pub type EOS_KWS_OnQueryPermissionsCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_KWS_QueryPermissionsCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_KWS_UpdateParentEmailOptions {
    #[doc = " API Version: Set this to EOS_KWS_UPDATEPARENTEMAIL_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Local user updating parental information"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " New parent email"]
    pub ParentEmail: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_KWS_UpdateParentEmailOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_KWS_UpdateParentEmailOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_KWS_UpdateParentEmailOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_KWS_UpdateParentEmailOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_KWS_UpdateParentEmailOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_KWS_UpdateParentEmailOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_UpdateParentEmailOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_UpdateParentEmailOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ParentEmail) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_UpdateParentEmailOptions),
            "::",
            stringify!(ParentEmail)
        )
    );
}
pub type EOS_KWS_UpdateParentEmailOptions = _tagEOS_KWS_UpdateParentEmailOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_KWS_UpdateParentEmailCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_KWS_UpdateParentEmail"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Local user updating their parental email"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_KWS_UpdateParentEmailCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_KWS_UpdateParentEmailCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_KWS_UpdateParentEmailCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_KWS_UpdateParentEmailCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_KWS_UpdateParentEmailCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_KWS_UpdateParentEmailCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_UpdateParentEmailCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_UpdateParentEmailCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_UpdateParentEmailCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_KWS_UpdateParentEmailCallbackInfo = _tagEOS_KWS_UpdateParentEmailCallbackInfo;
pub type EOS_KWS_OnUpdateParentEmailCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_KWS_UpdateParentEmailCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_KWS_RequestPermissionsOptions {
    #[doc = " API Version: Set this to EOS_KWS_REQUESTPERMISSIONS_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Local user requesting new permissions"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The number of permissions to request, may not exceed EOS_KWS_MAX_PERMISSIONS. Only new permissions need be included."]
    pub PermissionKeyCount: u32,
    #[doc = " Names of the permissions to request (Setup with KWS)"]
    pub PermissionKeys: *mut *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_KWS_RequestPermissionsOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_KWS_RequestPermissionsOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_KWS_RequestPermissionsOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_KWS_RequestPermissionsOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_KWS_RequestPermissionsOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_KWS_RequestPermissionsOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_RequestPermissionsOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_RequestPermissionsOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PermissionKeyCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_RequestPermissionsOptions),
            "::",
            stringify!(PermissionKeyCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PermissionKeys) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_RequestPermissionsOptions),
            "::",
            stringify!(PermissionKeys)
        )
    );
}
pub type EOS_KWS_RequestPermissionsOptions = _tagEOS_KWS_RequestPermissionsOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_KWS_RequestPermissionsCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_KWS_RequestPermissions"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Local user requesting new permissions"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_KWS_RequestPermissionsCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_KWS_RequestPermissionsCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_KWS_RequestPermissionsCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_KWS_RequestPermissionsCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_KWS_RequestPermissionsCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_KWS_RequestPermissionsCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_RequestPermissionsCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_RequestPermissionsCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_RequestPermissionsCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_KWS_RequestPermissionsCallbackInfo = _tagEOS_KWS_RequestPermissionsCallbackInfo;
pub type EOS_KWS_OnRequestPermissionsCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_KWS_RequestPermissionsCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_KWS_GetPermissionsCountOptions {
    #[doc = " API Version: Set this to EOS_KWS_GETPERMISSIONSCOUNT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user whose permissions are being accessed"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_KWS_GetPermissionsCountOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_KWS_GetPermissionsCountOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_KWS_GetPermissionsCountOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_KWS_GetPermissionsCountOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_KWS_GetPermissionsCountOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_KWS_GetPermissionsCountOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_GetPermissionsCountOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_GetPermissionsCountOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_KWS_GetPermissionsCountOptions = _tagEOS_KWS_GetPermissionsCountOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_KWS_CopyPermissionByIndexOptions {
    #[doc = " API Version: Set this to EOS_KWS_COPYPERMISSIONBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user whose permissions are being accessed"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The index of the permission to get."]
    pub Index: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_KWS_CopyPermissionByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_KWS_CopyPermissionByIndexOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_KWS_CopyPermissionByIndexOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_KWS_CopyPermissionByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_KWS_CopyPermissionByIndexOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_KWS_CopyPermissionByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_CopyPermissionByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_CopyPermissionByIndexOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Index) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_CopyPermissionByIndexOptions),
            "::",
            stringify!(Index)
        )
    );
}
pub type EOS_KWS_CopyPermissionByIndexOptions = _tagEOS_KWS_CopyPermissionByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_KWS_GetPermissionByKeyOptions {
    #[doc = " API Version: Set this to EOS_KWS_GETPERMISSIONBYKEY_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user getting permissions"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Permission name to query"]
    pub Key: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_KWS_GetPermissionByKeyOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_KWS_GetPermissionByKeyOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_KWS_GetPermissionByKeyOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_KWS_GetPermissionByKeyOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_KWS_GetPermissionByKeyOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_KWS_GetPermissionByKeyOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_GetPermissionByKeyOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_GetPermissionByKeyOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_GetPermissionByKeyOptions),
            "::",
            stringify!(Key)
        )
    );
}
pub type EOS_KWS_GetPermissionByKeyOptions = _tagEOS_KWS_GetPermissionByKeyOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_KWS_AddNotifyPermissionsUpdateReceivedOptions {
    #[doc = " API Version: Set this to EOS_KWS_ADDNOTIFYPERMISSIONSUPDATERECEIVED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_KWS_AddNotifyPermissionsUpdateReceivedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_KWS_AddNotifyPermissionsUpdateReceivedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_KWS_AddNotifyPermissionsUpdateReceivedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_KWS_AddNotifyPermissionsUpdateReceivedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_KWS_AddNotifyPermissionsUpdateReceivedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_KWS_AddNotifyPermissionsUpdateReceivedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_AddNotifyPermissionsUpdateReceivedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_KWS_AddNotifyPermissionsUpdateReceivedOptions =
    _tagEOS_KWS_AddNotifyPermissionsUpdateReceivedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_KWS_PermissionsUpdateReceivedCallbackInfo {
    #[doc = " Context that was passed into EOS_KWS_AddNotifyPermissionsUpdateReceived"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Recipient Local user id"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Recipient's associated KWS UserId"]
    pub KWSUserId: *const ::std::os::raw::c_char,
    #[doc = " Date of birth in ISO8601 form (YYYY-MM-DD)"]
    pub DateOfBirth: *const ::std::os::raw::c_char,
    #[doc = " Is this user a minor"]
    pub bIsMinor: EOS_Bool,
    #[doc = " Parent email. This value may be set to an empty string if the originally registered email recipient declined to be the right person to give consent."]
    pub ParentEmail: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_KWS_PermissionsUpdateReceivedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_KWS_PermissionsUpdateReceivedCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_KWS_PermissionsUpdateReceivedCallbackInfo>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_KWS_PermissionsUpdateReceivedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_KWS_PermissionsUpdateReceivedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_KWS_PermissionsUpdateReceivedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_PermissionsUpdateReceivedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_PermissionsUpdateReceivedCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).KWSUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_PermissionsUpdateReceivedCallbackInfo),
            "::",
            stringify!(KWSUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DateOfBirth) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_PermissionsUpdateReceivedCallbackInfo),
            "::",
            stringify!(DateOfBirth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIsMinor) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_PermissionsUpdateReceivedCallbackInfo),
            "::",
            stringify!(bIsMinor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ParentEmail) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_KWS_PermissionsUpdateReceivedCallbackInfo),
            "::",
            stringify!(ParentEmail)
        )
    );
}
pub type EOS_KWS_PermissionsUpdateReceivedCallbackInfo =
    _tagEOS_KWS_PermissionsUpdateReceivedCallbackInfo;
pub type EOS_KWS_OnPermissionsUpdateReceivedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_KWS_PermissionsUpdateReceivedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_RTCHandle {
    _unused: [u8; 0],
}
pub type EOS_HRTC = *mut EOS_RTCHandle;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_ERTCParticipantStatus {
    #[doc = " Participant joined the room"]
    EOS_RTCPS_Joined = 0,
    #[doc = " Participant left the room"]
    EOS_RTCPS_Left = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_RTC_JoinRoomOptions {
    #[doc = " API Version: Set this to EOS_RTC_JOINROOM_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The product user id of the user trying to request this operation."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The room the user would like to join."]
    pub RoomName: *const ::std::os::raw::c_char,
    #[doc = " The room the user would like to join."]
    pub ClientBaseUrl: *const ::std::os::raw::c_char,
    #[doc = " Authorization credential token to join the room."]
    pub ParticipantToken: *const ::std::os::raw::c_char,
    #[doc = " The participant id used to join the room. If set to NULL the LocalUserId will be used instead."]
    pub ParticipantId: EOS_ProductUserId,
    #[doc = " Join room flags, e.g. EOS_RTC_JOINROOMFLAGS_ENABLE_ECHO. This is a bitwise-or union of the defined flags."]
    pub Flags: u32,
    #[doc = " Enable or disable Manual Audio Input. If manual audio input is enabled audio recording is not started and the audio\n buffers must be passed manually using EOS_RTCAudio_SendAudio."]
    pub bManualAudioInputEnabled: EOS_Bool,
    #[doc = " Enable or disable Manual Audio Output. If manual audio output is enabled audio rendering is not started and the audio\n buffers must be received with EOS_RTCAudio_AddNotifyAudioBeforeRender and rendered manually."]
    pub bManualAudioOutputEnabled: EOS_Bool,
}
#[test]
fn bindgen_test_layout__tagEOS_RTC_JoinRoomOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_RTC_JoinRoomOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_RTC_JoinRoomOptions>(),
        64usize,
        concat!("Size of: ", stringify!(_tagEOS_RTC_JoinRoomOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_RTC_JoinRoomOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_RTC_JoinRoomOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_JoinRoomOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_JoinRoomOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RoomName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_JoinRoomOptions),
            "::",
            stringify!(RoomName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientBaseUrl) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_JoinRoomOptions),
            "::",
            stringify!(ClientBaseUrl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ParticipantToken) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_JoinRoomOptions),
            "::",
            stringify!(ParticipantToken)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ParticipantId) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_JoinRoomOptions),
            "::",
            stringify!(ParticipantId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_JoinRoomOptions),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bManualAudioInputEnabled) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_JoinRoomOptions),
            "::",
            stringify!(bManualAudioInputEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bManualAudioOutputEnabled) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_JoinRoomOptions),
            "::",
            stringify!(bManualAudioOutputEnabled)
        )
    );
}
pub type EOS_RTC_JoinRoomOptions = _tagEOS_RTC_JoinRoomOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_RTC_Option {
    #[doc = " API Version: Set this to EOS_RTC_OPTION_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The unique key of the option. The max size of the string is EOS_RTC_OPTION_KEY_MAXCHARCOUNT."]
    pub Key: *const ::std::os::raw::c_char,
    #[doc = " The value of the option. The max size of the string is EOS_RTC_OPTION_VALUE_MAXCHARCOUNT."]
    pub Value: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_RTC_Option() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_RTC_Option> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_RTC_Option>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_RTC_Option))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_RTC_Option>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_RTC_Option))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_Option),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_Option),
            "::",
            stringify!(Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_Option),
            "::",
            stringify!(Value)
        )
    );
}
pub type EOS_RTC_Option = _tagEOS_RTC_Option;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_RTC_JoinRoomCallbackInfo {
    #[doc = " This returns:\n EOS_Success if the channel was successfully joined.\n EOS_NoConnection: unable to connect to RTC servers (retryable).\n EOS_InvalidAuth: if the token is invalid (not retryable).\n EOS_RTC_TooManyParticipants: if the room cannot accept more participants (not retryable).\n EOS_AccessDenied: if the room name belongs to the Lobby voice system (not retryable).\n EOS_UnexpectedError otherwise (retryable)."]
    pub ResultCode: EOS_EResult,
    #[doc = " Client-specified data passed into EOS_RTC_JoinRoom."]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the user who initiated this request."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The room the user was trying to join."]
    pub RoomName: *const ::std::os::raw::c_char,
    #[doc = " The room option items count."]
    pub RoomOptionsCount: u32,
    #[doc = " The room option items."]
    pub RoomOptions: *const EOS_RTC_Option,
}
#[test]
fn bindgen_test_layout__tagEOS_RTC_JoinRoomCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_RTC_JoinRoomCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_RTC_JoinRoomCallbackInfo>(),
        48usize,
        concat!("Size of: ", stringify!(_tagEOS_RTC_JoinRoomCallbackInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_RTC_JoinRoomCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_RTC_JoinRoomCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_JoinRoomCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_JoinRoomCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_JoinRoomCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RoomName) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_JoinRoomCallbackInfo),
            "::",
            stringify!(RoomName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RoomOptionsCount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_JoinRoomCallbackInfo),
            "::",
            stringify!(RoomOptionsCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RoomOptions) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_JoinRoomCallbackInfo),
            "::",
            stringify!(RoomOptions)
        )
    );
}
pub type EOS_RTC_JoinRoomCallbackInfo = _tagEOS_RTC_JoinRoomCallbackInfo;
pub type EOS_RTC_OnJoinRoomCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_RTC_JoinRoomCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_RTC_LeaveRoomOptions {
    #[doc = " API Version: Set this to EOS_RTC_LEAVEROOM_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Product User ID of the user requesting to leave the room"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The room to leave."]
    pub RoomName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_RTC_LeaveRoomOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_RTC_LeaveRoomOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_RTC_LeaveRoomOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_RTC_LeaveRoomOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_RTC_LeaveRoomOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_RTC_LeaveRoomOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_LeaveRoomOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_LeaveRoomOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RoomName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_LeaveRoomOptions),
            "::",
            stringify!(RoomName)
        )
    );
}
pub type EOS_RTC_LeaveRoomOptions = _tagEOS_RTC_LeaveRoomOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_RTC_LeaveRoomCallbackInfo {
    #[doc = " This returns:\n EOS_Success if the channel was successfully left.\n EOS_AccessDenied if the room name belongs to the Lobby voice system.\n EOS_UnexpectedError otherwise."]
    pub ResultCode: EOS_EResult,
    #[doc = " Client-specified data passed into EOS_RTC_LeaveRoomOptions."]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the user who initiated this request."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The room the user was trying to leave."]
    pub RoomName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_RTC_LeaveRoomCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_RTC_LeaveRoomCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_RTC_LeaveRoomCallbackInfo>(),
        32usize,
        concat!("Size of: ", stringify!(_tagEOS_RTC_LeaveRoomCallbackInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_RTC_LeaveRoomCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_RTC_LeaveRoomCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_LeaveRoomCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_LeaveRoomCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_LeaveRoomCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RoomName) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_LeaveRoomCallbackInfo),
            "::",
            stringify!(RoomName)
        )
    );
}
pub type EOS_RTC_LeaveRoomCallbackInfo = _tagEOS_RTC_LeaveRoomCallbackInfo;
pub type EOS_RTC_OnLeaveRoomCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_RTC_LeaveRoomCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_RTC_BlockParticipantOptions {
    #[doc = " API Version: Set this to EOS_RTC_BLOCKPARTICIPANT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Product User ID of the user trying to request this operation."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The room the users should be blocked on."]
    pub RoomName: *const ::std::os::raw::c_char,
    #[doc = " Product User ID of the participant to block"]
    pub ParticipantId: EOS_ProductUserId,
    #[doc = " Block or unblock the participant"]
    pub bBlocked: EOS_Bool,
}
#[test]
fn bindgen_test_layout__tagEOS_RTC_BlockParticipantOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_RTC_BlockParticipantOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_RTC_BlockParticipantOptions>(),
        40usize,
        concat!("Size of: ", stringify!(_tagEOS_RTC_BlockParticipantOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_RTC_BlockParticipantOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_RTC_BlockParticipantOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_BlockParticipantOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_BlockParticipantOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RoomName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_BlockParticipantOptions),
            "::",
            stringify!(RoomName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ParticipantId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_BlockParticipantOptions),
            "::",
            stringify!(ParticipantId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bBlocked) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_BlockParticipantOptions),
            "::",
            stringify!(bBlocked)
        )
    );
}
pub type EOS_RTC_BlockParticipantOptions = _tagEOS_RTC_BlockParticipantOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_RTC_BlockParticipantCallbackInfo {
    #[doc = " This returns:\n EOS_Success if the channel was successfully blocked.\n EOS_UnexpectedError otherwise."]
    pub ResultCode: EOS_EResult,
    #[doc = " Client-specified data passed into EOS_RTC_BlockParticipant."]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the user who initiated this request."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The room the users should be blocked on."]
    pub RoomName: *const ::std::os::raw::c_char,
    #[doc = " The Product User ID of the participant being blocked"]
    pub ParticipantId: EOS_ProductUserId,
    #[doc = " The block state that should have been set"]
    pub bBlocked: EOS_Bool,
}
#[test]
fn bindgen_test_layout__tagEOS_RTC_BlockParticipantCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_RTC_BlockParticipantCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_RTC_BlockParticipantCallbackInfo>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_RTC_BlockParticipantCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_RTC_BlockParticipantCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_RTC_BlockParticipantCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_BlockParticipantCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_BlockParticipantCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_BlockParticipantCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RoomName) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_BlockParticipantCallbackInfo),
            "::",
            stringify!(RoomName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ParticipantId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_BlockParticipantCallbackInfo),
            "::",
            stringify!(ParticipantId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bBlocked) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_BlockParticipantCallbackInfo),
            "::",
            stringify!(bBlocked)
        )
    );
}
pub type EOS_RTC_BlockParticipantCallbackInfo = _tagEOS_RTC_BlockParticipantCallbackInfo;
pub type EOS_RTC_OnBlockParticipantCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_RTC_BlockParticipantCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_RTC_AddNotifyDisconnectedOptions {
    #[doc = " API Version: Set this to EOS_RTC_ADDNOTIFYDISCONNECTED_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the user trying to request this operation."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The room this event is registered on."]
    pub RoomName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_RTC_AddNotifyDisconnectedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_RTC_AddNotifyDisconnectedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_RTC_AddNotifyDisconnectedOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_RTC_AddNotifyDisconnectedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_RTC_AddNotifyDisconnectedOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_RTC_AddNotifyDisconnectedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_AddNotifyDisconnectedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_AddNotifyDisconnectedOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RoomName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_AddNotifyDisconnectedOptions),
            "::",
            stringify!(RoomName)
        )
    );
}
pub type EOS_RTC_AddNotifyDisconnectedOptions = _tagEOS_RTC_AddNotifyDisconnectedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_RTC_DisconnectedCallbackInfo {
    #[doc = " This returns:\n EOS_Success The room was left cleanly.\n EOS_NoConnection: There was a network issue connecting to the server (retryable).\n EOS_RTC_UserKicked: The user has been kicked by the server (retryable).\n EOS_ServiceFailure: A known error occurred during interaction with the server (retryable).\n EOS_UnexpectedError Unexpected error (retryable)."]
    pub ResultCode: EOS_EResult,
    #[doc = " Client-specified data passed into EOS_RTC_AddNotifyDisconnected."]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the user who initiated this request."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The room associated with this event."]
    pub RoomName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_RTC_DisconnectedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_RTC_DisconnectedCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_RTC_DisconnectedCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_RTC_DisconnectedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_RTC_DisconnectedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_RTC_DisconnectedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_DisconnectedCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_DisconnectedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_DisconnectedCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RoomName) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_DisconnectedCallbackInfo),
            "::",
            stringify!(RoomName)
        )
    );
}
pub type EOS_RTC_DisconnectedCallbackInfo = _tagEOS_RTC_DisconnectedCallbackInfo;
pub type EOS_RTC_OnDisconnectedCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_RTC_DisconnectedCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_RTC_ParticipantMetadata {
    #[doc = " API Version: Set this to EOS_RTC_PARTICIPANTMETADATA_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The unique key of this metadata item. The max size of the string is EOS_RTC_PARTICIPANTMETADATA_KEY_MAXCHARCOUNT."]
    pub Key: *const ::std::os::raw::c_char,
    #[doc = " The value of this metadata item. The max size of the string is EOS_RTC_PARTICIPANTMETADATA_VALUE_MAXCHARCOUNT."]
    pub Value: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_RTC_ParticipantMetadata() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_RTC_ParticipantMetadata> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_RTC_ParticipantMetadata>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_RTC_ParticipantMetadata))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_RTC_ParticipantMetadata>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_RTC_ParticipantMetadata))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_ParticipantMetadata),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_ParticipantMetadata),
            "::",
            stringify!(Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_ParticipantMetadata),
            "::",
            stringify!(Value)
        )
    );
}
pub type EOS_RTC_ParticipantMetadata = _tagEOS_RTC_ParticipantMetadata;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_RTC_AddNotifyParticipantStatusChangedOptions {
    #[doc = " API Version: Set this to EOS_RTC_ADDNOTIFYPARTICIPANTSTATUSCHANGED_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the user trying to request this operation."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The room this event is registered on."]
    pub RoomName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_RTC_AddNotifyParticipantStatusChangedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_RTC_AddNotifyParticipantStatusChangedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_RTC_AddNotifyParticipantStatusChangedOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_RTC_AddNotifyParticipantStatusChangedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_RTC_AddNotifyParticipantStatusChangedOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_RTC_AddNotifyParticipantStatusChangedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_AddNotifyParticipantStatusChangedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_AddNotifyParticipantStatusChangedOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RoomName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_AddNotifyParticipantStatusChangedOptions),
            "::",
            stringify!(RoomName)
        )
    );
}
pub type EOS_RTC_AddNotifyParticipantStatusChangedOptions =
    _tagEOS_RTC_AddNotifyParticipantStatusChangedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_RTC_ParticipantStatusChangedCallbackInfo {
    #[doc = " Client-specified data passed into EOS_RTC_AddNotifyParticipantStatusChanged."]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the user who initiated this request."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The room associated with this event."]
    pub RoomName: *const ::std::os::raw::c_char,
    #[doc = " The participant whose status changed."]
    pub ParticipantId: EOS_ProductUserId,
    #[doc = " What status change occurred"]
    pub ParticipantStatus: EOS_ERTCParticipantStatus,
    #[doc = " The participant metadata items count.\n This is only set for the first notification where ParticipantStatus is EOS_RTCPS_Joined. Subsequent notifications\n such as when bParticipantInBlocklist changes will not contain any metadata."]
    pub ParticipantMetadataCount: u32,
    #[doc = " The participant metadata items.\n This is only set for the first notification where ParticipantStatus is EOS_RTCPS_Joined. Subsequent notifications\n such as when bParticipantInBlocklist changes will not contain any metadata."]
    pub ParticipantMetadata: *const EOS_RTC_ParticipantMetadata,
    #[doc = " The participant's block list status, if ParticipantStatus is EOS_RTCPS_Joined.\n This is set to true if the participant is in any of the local user's applicable block lists,\n such Epic block list or any of the current platform's block lists.\n It can be used to detect when an internal automatic RTC block is applied because of trust and safety restrictions."]
    pub bParticipantInBlocklist: EOS_Bool,
}
#[test]
fn bindgen_test_layout__tagEOS_RTC_ParticipantStatusChangedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_RTC_ParticipantStatusChangedCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_RTC_ParticipantStatusChangedCallbackInfo>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_RTC_ParticipantStatusChangedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_RTC_ParticipantStatusChangedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_RTC_ParticipantStatusChangedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_ParticipantStatusChangedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_ParticipantStatusChangedCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RoomName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_ParticipantStatusChangedCallbackInfo),
            "::",
            stringify!(RoomName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ParticipantId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_ParticipantStatusChangedCallbackInfo),
            "::",
            stringify!(ParticipantId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ParticipantStatus) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_ParticipantStatusChangedCallbackInfo),
            "::",
            stringify!(ParticipantStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ParticipantMetadataCount) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_ParticipantStatusChangedCallbackInfo),
            "::",
            stringify!(ParticipantMetadataCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ParticipantMetadata) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_ParticipantStatusChangedCallbackInfo),
            "::",
            stringify!(ParticipantMetadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bParticipantInBlocklist) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_ParticipantStatusChangedCallbackInfo),
            "::",
            stringify!(bParticipantInBlocklist)
        )
    );
}
pub type EOS_RTC_ParticipantStatusChangedCallbackInfo =
    _tagEOS_RTC_ParticipantStatusChangedCallbackInfo;
pub type EOS_RTC_OnParticipantStatusChangedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_RTC_ParticipantStatusChangedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_RTC_SetSettingOptions {
    #[doc = " API Version: Set this to EOS_RTC_SETSETTING_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Setting that should be set."]
    pub SettingName: *const ::std::os::raw::c_char,
    #[doc = " Value to set the setting to."]
    pub SettingValue: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_RTC_SetSettingOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_RTC_SetSettingOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_RTC_SetSettingOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_RTC_SetSettingOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_RTC_SetSettingOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_RTC_SetSettingOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_SetSettingOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SettingName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_SetSettingOptions),
            "::",
            stringify!(SettingName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SettingValue) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_SetSettingOptions),
            "::",
            stringify!(SettingValue)
        )
    );
}
pub type EOS_RTC_SetSettingOptions = _tagEOS_RTC_SetSettingOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_RTC_SetRoomSettingOptions {
    #[doc = " API Version: Set this to EOS_RTC_SETROOMSETTING_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the user trying to request this operation."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The room the setting will be applied to."]
    pub RoomName: *const ::std::os::raw::c_char,
    #[doc = " Setting that should be set."]
    pub SettingName: *const ::std::os::raw::c_char,
    #[doc = " Value to set the setting to."]
    pub SettingValue: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_RTC_SetRoomSettingOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_RTC_SetRoomSettingOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_RTC_SetRoomSettingOptions>(),
        40usize,
        concat!("Size of: ", stringify!(_tagEOS_RTC_SetRoomSettingOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_RTC_SetRoomSettingOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_RTC_SetRoomSettingOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_SetRoomSettingOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_SetRoomSettingOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RoomName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_SetRoomSettingOptions),
            "::",
            stringify!(RoomName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SettingName) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_SetRoomSettingOptions),
            "::",
            stringify!(SettingName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SettingValue) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_SetRoomSettingOptions),
            "::",
            stringify!(SettingValue)
        )
    );
}
pub type EOS_RTC_SetRoomSettingOptions = _tagEOS_RTC_SetRoomSettingOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_RTC_AddNotifyRoomStatisticsUpdatedOptions {
    #[doc = " API Version: Set this to EOS_RTC_ADDNOTIFYROOMSTATISTICSUPDATED_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the user trying to request this operation."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The room this event is registered on."]
    pub RoomName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_RTC_AddNotifyRoomStatisticsUpdatedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_RTC_AddNotifyRoomStatisticsUpdatedOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_RTC_AddNotifyRoomStatisticsUpdatedOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_RTC_AddNotifyRoomStatisticsUpdatedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_RTC_AddNotifyRoomStatisticsUpdatedOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_RTC_AddNotifyRoomStatisticsUpdatedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_AddNotifyRoomStatisticsUpdatedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_AddNotifyRoomStatisticsUpdatedOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RoomName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_AddNotifyRoomStatisticsUpdatedOptions),
            "::",
            stringify!(RoomName)
        )
    );
}
pub type EOS_RTC_AddNotifyRoomStatisticsUpdatedOptions =
    _tagEOS_RTC_AddNotifyRoomStatisticsUpdatedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_RTC_RoomStatisticsUpdatedInfo {
    #[doc = " Client-specified data passed into EOS_RTC_AddNotifyRoomStatisticsUpdated."]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " The Product User ID of the user who initiated this request."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The room associated with this event."]
    pub RoomName: *const ::std::os::raw::c_char,
    #[doc = " Statistics in JSON format"]
    pub Statistic: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_RTC_RoomStatisticsUpdatedInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_RTC_RoomStatisticsUpdatedInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_RTC_RoomStatisticsUpdatedInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_RTC_RoomStatisticsUpdatedInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_RTC_RoomStatisticsUpdatedInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_RTC_RoomStatisticsUpdatedInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_RoomStatisticsUpdatedInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_RoomStatisticsUpdatedInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RoomName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_RoomStatisticsUpdatedInfo),
            "::",
            stringify!(RoomName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Statistic) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTC_RoomStatisticsUpdatedInfo),
            "::",
            stringify!(Statistic)
        )
    );
}
pub type EOS_RTC_RoomStatisticsUpdatedInfo = _tagEOS_RTC_RoomStatisticsUpdatedInfo;
pub type EOS_RTC_OnRoomStatisticsUpdatedCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_RTC_RoomStatisticsUpdatedInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_RTCAdminHandle {
    _unused: [u8; 0],
}
pub type EOS_HRTCAdmin = *mut EOS_RTCAdminHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_RTCAdmin_QueryJoinRoomTokenOptions {
    #[doc = " API Version: Set this to EOS_RTCADMIN_QUERYJOINROOMTOKEN_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Product User ID for local user who is querying join room tokens."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Room name to request a token for."]
    pub RoomName: *const ::std::os::raw::c_char,
    #[doc = " An array of Product User IDs indicating the users to retrieve a token for."]
    pub TargetUserIds: *mut EOS_ProductUserId,
    #[doc = " The number of users included in the query."]
    pub TargetUserIdsCount: u32,
    #[doc = " Array of IP Addresses, one for each of the users we're querying tokens for.\n There should be TargetUserIdsCount Ip Addresses, you can set an entry to NULL if not known.\n If TargetUserIpAddresses is set to NULL IP Addresses will be ignored.\n IPv4 format: \"0.0.0.0\"\n IPv6 format: \"0:0:0:0:0:0:0:0\""]
    pub TargetUserIpAddresses: *mut *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_RTCAdmin_QueryJoinRoomTokenOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_RTCAdmin_QueryJoinRoomTokenOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_RTCAdmin_QueryJoinRoomTokenOptions>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_RTCAdmin_QueryJoinRoomTokenOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_RTCAdmin_QueryJoinRoomTokenOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_RTCAdmin_QueryJoinRoomTokenOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_QueryJoinRoomTokenOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_QueryJoinRoomTokenOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RoomName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_QueryJoinRoomTokenOptions),
            "::",
            stringify!(RoomName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserIds) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_QueryJoinRoomTokenOptions),
            "::",
            stringify!(TargetUserIds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserIdsCount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_QueryJoinRoomTokenOptions),
            "::",
            stringify!(TargetUserIdsCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserIpAddresses) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_QueryJoinRoomTokenOptions),
            "::",
            stringify!(TargetUserIpAddresses)
        )
    );
}
pub type EOS_RTCAdmin_QueryJoinRoomTokenOptions = _tagEOS_RTCAdmin_QueryJoinRoomTokenOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_RTCAdmin_QueryJoinRoomToken."]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Room the request was made for."]
    pub RoomName: *const ::std::os::raw::c_char,
    #[doc = " URL passed to backend to join room."]
    pub ClientBaseUrl: *const ::std::os::raw::c_char,
    #[doc = " If the query completed successfully, this contains an identifier that should be used to retrieve the tokens.\n This identifier is only valid for the duration of the callback.\n\n @see EOS_RTCAdmin_CopyUserTokenByIndex\n @see EOS_RTCAdmin_CopyUserTokenByUserId"]
    pub QueryId: u32,
    #[doc = " How many token received as result of the query"]
    pub TokenCount: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RoomName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo),
            "::",
            stringify!(RoomName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientBaseUrl) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo),
            "::",
            stringify!(ClientBaseUrl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).QueryId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo),
            "::",
            stringify!(QueryId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TokenCount) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo),
            "::",
            stringify!(TokenCount)
        )
    );
}
pub type EOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo =
    _tagEOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo;
pub type EOS_RTCAdmin_OnQueryJoinRoomTokenCompleteCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_RTCAdmin_UserToken {
    #[doc = " API Version: Set this to EOS_RTCADMIN_USERTOKEN_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID for the user who owns this user token."]
    pub ProductUserId: EOS_ProductUserId,
    #[doc = " Access token to enable a user to join a room"]
    pub Token: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_RTCAdmin_UserToken() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_RTCAdmin_UserToken> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_RTCAdmin_UserToken>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_RTCAdmin_UserToken))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_RTCAdmin_UserToken>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_RTCAdmin_UserToken))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_UserToken),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProductUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_UserToken),
            "::",
            stringify!(ProductUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Token) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_UserToken),
            "::",
            stringify!(Token)
        )
    );
}
pub type EOS_RTCAdmin_UserToken = _tagEOS_RTCAdmin_UserToken;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_RTCAdmin_CopyUserTokenByIndexOptions {
    #[doc = " API Version: Set this to EOS_RTCADMIN_COPYUSERTOKENBYINDEX_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Index of the user token to retrieve from the cache."]
    pub UserTokenIndex: u32,
    #[doc = " Query identifier received as part of a previous query.\n @see EOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo"]
    pub QueryId: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_RTCAdmin_CopyUserTokenByIndexOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_RTCAdmin_CopyUserTokenByIndexOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_RTCAdmin_CopyUserTokenByIndexOptions>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_RTCAdmin_CopyUserTokenByIndexOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_RTCAdmin_CopyUserTokenByIndexOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_RTCAdmin_CopyUserTokenByIndexOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_CopyUserTokenByIndexOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserTokenIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_CopyUserTokenByIndexOptions),
            "::",
            stringify!(UserTokenIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).QueryId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_CopyUserTokenByIndexOptions),
            "::",
            stringify!(QueryId)
        )
    );
}
pub type EOS_RTCAdmin_CopyUserTokenByIndexOptions = _tagEOS_RTCAdmin_CopyUserTokenByIndexOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_RTCAdmin_CopyUserTokenByUserIdOptions {
    #[doc = " API Version: Set this to EOS_RTCADMIN_COPYUSERTOKENBYUSERID_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID for the user whose user token we're copying."]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " Query identifier received as part of a previous query.\n @see EOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo"]
    pub QueryId: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_RTCAdmin_CopyUserTokenByUserIdOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_RTCAdmin_CopyUserTokenByUserIdOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_RTCAdmin_CopyUserTokenByUserIdOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_RTCAdmin_CopyUserTokenByUserIdOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_RTCAdmin_CopyUserTokenByUserIdOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_RTCAdmin_CopyUserTokenByUserIdOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_CopyUserTokenByUserIdOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_CopyUserTokenByUserIdOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).QueryId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_CopyUserTokenByUserIdOptions),
            "::",
            stringify!(QueryId)
        )
    );
}
pub type EOS_RTCAdmin_CopyUserTokenByUserIdOptions = _tagEOS_RTCAdmin_CopyUserTokenByUserIdOptions;
extern "C" {
    #[doc = " Release the memory associated with EOS_RTCAdmin_UserToken. This must be called on data retrieved from\n EOS_RTCAdmin_CopyUserTokenByIndex or EOS_RTCAdmin_CopyUserTokenByUserId.\n\n @param UserToken - The user token to release.\n\n @see EOS_RTCAdmin_UserToken\n @see EOS_RTCAdmin_CopyUserTokenByIndex\n @see EOS_RTCAdmin_CopyUserTokenByUserId"]
    pub fn EOS_RTCAdmin_UserToken_Release(UserToken: *mut EOS_RTCAdmin_UserToken);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_RTCAdmin_KickOptions {
    #[doc = " API Version: Set this to EOS_RTCADMIN_KICK_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Room name to kick the participant from"]
    pub RoomName: *const ::std::os::raw::c_char,
    #[doc = " Product User ID of the participant to kick from the room"]
    pub TargetUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_RTCAdmin_KickOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_RTCAdmin_KickOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_RTCAdmin_KickOptions>(),
        24usize,
        concat!("Size of: ", stringify!(_tagEOS_RTCAdmin_KickOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_RTCAdmin_KickOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(_tagEOS_RTCAdmin_KickOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_KickOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RoomName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_KickOptions),
            "::",
            stringify!(RoomName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_KickOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_RTCAdmin_KickOptions = _tagEOS_RTCAdmin_KickOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_RTCAdmin_KickCompleteCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Client-specified data passed into the kick request"]
    pub ClientData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_RTCAdmin_KickCompleteCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_RTCAdmin_KickCompleteCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_RTCAdmin_KickCompleteCallbackInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_RTCAdmin_KickCompleteCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_RTCAdmin_KickCompleteCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_RTCAdmin_KickCompleteCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_KickCompleteCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_KickCompleteCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
}
pub type EOS_RTCAdmin_KickCompleteCallbackInfo = _tagEOS_RTCAdmin_KickCompleteCallbackInfo;
pub type EOS_RTCAdmin_OnKickCompleteCallback =
    ::std::option::Option<unsafe extern "C" fn(Data: *const EOS_RTCAdmin_KickCompleteCallbackInfo)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_RTCAdmin_SetParticipantHardMuteOptions {
    #[doc = " API Version: Set this to EOS_RTCADMIN_SETPARTICIPANTHARDMUTE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Room to kick the participant from"]
    pub RoomName: *const ::std::os::raw::c_char,
    #[doc = " Product User ID of the participant to hard mute for every participant in the room."]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " Hard mute status (Mute on or off)"]
    pub bMute: EOS_Bool,
}
#[test]
fn bindgen_test_layout__tagEOS_RTCAdmin_SetParticipantHardMuteOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_RTCAdmin_SetParticipantHardMuteOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_RTCAdmin_SetParticipantHardMuteOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_RTCAdmin_SetParticipantHardMuteOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_RTCAdmin_SetParticipantHardMuteOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_RTCAdmin_SetParticipantHardMuteOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_SetParticipantHardMuteOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RoomName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_SetParticipantHardMuteOptions),
            "::",
            stringify!(RoomName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_SetParticipantHardMuteOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bMute) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_SetParticipantHardMuteOptions),
            "::",
            stringify!(bMute)
        )
    );
}
pub type EOS_RTCAdmin_SetParticipantHardMuteOptions =
    _tagEOS_RTCAdmin_SetParticipantHardMuteOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_RTCAdmin_SetParticipantHardMuteCompleteCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Client-specified data passed into the hard mute request"]
    pub ClientData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_RTCAdmin_SetParticipantHardMuteCompleteCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_RTCAdmin_SetParticipantHardMuteCompleteCallbackInfo,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_RTCAdmin_SetParticipantHardMuteCompleteCallbackInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_RTCAdmin_SetParticipantHardMuteCompleteCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_RTCAdmin_SetParticipantHardMuteCompleteCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_RTCAdmin_SetParticipantHardMuteCompleteCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_SetParticipantHardMuteCompleteCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_RTCAdmin_SetParticipantHardMuteCompleteCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
}
pub type EOS_RTCAdmin_SetParticipantHardMuteCompleteCallbackInfo =
    _tagEOS_RTCAdmin_SetParticipantHardMuteCompleteCallbackInfo;
pub type EOS_RTCAdmin_OnSetParticipantHardMuteCompleteCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_RTCAdmin_SetParticipantHardMuteCompleteCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_ProgressionSnapshotHandle {
    _unused: [u8; 0],
}
#[doc = " Handle to the ProgressionSnapshot interface"]
pub type EOS_HProgressionSnapshot = *mut EOS_ProgressionSnapshotHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_ProgressionSnapshot_BeginSnapshotOptions {
    #[doc = " API Version: Set this to EOS_PROGRESSIONSNAPSHOT_BEGINSNAPSHOT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user to whom the key/value pair belong"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_ProgressionSnapshot_BeginSnapshotOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_ProgressionSnapshot_BeginSnapshotOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_ProgressionSnapshot_BeginSnapshotOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_ProgressionSnapshot_BeginSnapshotOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_ProgressionSnapshot_BeginSnapshotOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_ProgressionSnapshot_BeginSnapshotOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_ProgressionSnapshot_BeginSnapshotOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_ProgressionSnapshot_BeginSnapshotOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_ProgressionSnapshot_BeginSnapshotOptions =
    _tagEOS_ProgressionSnapshot_BeginSnapshotOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_ProgressionSnapshot_AddProgressionOptions {
    #[doc = " API Version: Set this to EOS_PROGRESSIONSNAPSHOT_ADDPROGRESSION_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Snapshot Id received via a EOS_ProgressionSnapshot_BeginSnapshot function."]
    pub SnapshotId: u32,
    #[doc = " The key in a key/value pair of progression entry"]
    pub Key: *const ::std::os::raw::c_char,
    #[doc = " The value in a key/value pair of progression entry"]
    pub Value: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_ProgressionSnapshot_AddProgressionOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_ProgressionSnapshot_AddProgressionOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_ProgressionSnapshot_AddProgressionOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_ProgressionSnapshot_AddProgressionOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_ProgressionSnapshot_AddProgressionOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_ProgressionSnapshot_AddProgressionOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_ProgressionSnapshot_AddProgressionOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SnapshotId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_ProgressionSnapshot_AddProgressionOptions),
            "::",
            stringify!(SnapshotId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_ProgressionSnapshot_AddProgressionOptions),
            "::",
            stringify!(Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_ProgressionSnapshot_AddProgressionOptions),
            "::",
            stringify!(Value)
        )
    );
}
pub type EOS_ProgressionSnapshot_AddProgressionOptions =
    _tagEOS_ProgressionSnapshot_AddProgressionOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_ProgressionSnapshot_SubmitSnapshotOptions {
    #[doc = " API Version: Set this to EOS_PROGRESSIONSNAPSHOT_SUBMITSNAPSHOT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Snapshot Id received via a EOS_ProgressionSnapshot_BeginSnapshot function."]
    pub SnapshotId: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_ProgressionSnapshot_SubmitSnapshotOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_ProgressionSnapshot_SubmitSnapshotOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_ProgressionSnapshot_SubmitSnapshotOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_ProgressionSnapshot_SubmitSnapshotOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_ProgressionSnapshot_SubmitSnapshotOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_ProgressionSnapshot_SubmitSnapshotOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_ProgressionSnapshot_SubmitSnapshotOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SnapshotId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_ProgressionSnapshot_SubmitSnapshotOptions),
            "::",
            stringify!(SnapshotId)
        )
    );
}
pub type EOS_ProgressionSnapshot_SubmitSnapshotOptions =
    _tagEOS_ProgressionSnapshot_SubmitSnapshotOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_ProgressionSnapshot_EndSnapshotOptions {
    #[doc = " API Version: Set this to EOS_PROGRESSIONSNAPSHOT_ENDSNAPSHOT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Snapshot Id received via a EOS_ProgressionSnapshot_BeginSnapshot function."]
    pub SnapshotId: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_ProgressionSnapshot_EndSnapshotOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_ProgressionSnapshot_EndSnapshotOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_ProgressionSnapshot_EndSnapshotOptions>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_ProgressionSnapshot_EndSnapshotOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_ProgressionSnapshot_EndSnapshotOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_ProgressionSnapshot_EndSnapshotOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_ProgressionSnapshot_EndSnapshotOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SnapshotId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_ProgressionSnapshot_EndSnapshotOptions),
            "::",
            stringify!(SnapshotId)
        )
    );
}
pub type EOS_ProgressionSnapshot_EndSnapshotOptions =
    _tagEOS_ProgressionSnapshot_EndSnapshotOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_ProgressionSnapshot_SubmitSnapshotCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " The Snapshot Id used in the Submit function."]
    pub SnapshotId: u32,
    #[doc = " Context that was passed into EOS_ProgressionSnapshot_SubmitSnapshot."]
    pub ClientData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_ProgressionSnapshot_SubmitSnapshotCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_ProgressionSnapshot_SubmitSnapshotCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_ProgressionSnapshot_SubmitSnapshotCallbackInfo>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_ProgressionSnapshot_SubmitSnapshotCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_ProgressionSnapshot_SubmitSnapshotCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_ProgressionSnapshot_SubmitSnapshotCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_ProgressionSnapshot_SubmitSnapshotCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SnapshotId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_ProgressionSnapshot_SubmitSnapshotCallbackInfo),
            "::",
            stringify!(SnapshotId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_ProgressionSnapshot_SubmitSnapshotCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
}
pub type EOS_ProgressionSnapshot_SubmitSnapshotCallbackInfo =
    _tagEOS_ProgressionSnapshot_SubmitSnapshotCallbackInfo;
pub type EOS_ProgressionSnapshot_OnSubmitSnapshotCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_ProgressionSnapshot_SubmitSnapshotCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_ProgressionSnapshot_DeleteSnapshotOptions {
    #[doc = " API Version: Set this to EOS_PROGRESSIONSNAPSHOT_DELETESNAPSHOT_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " The Product User ID of the local user to whom the key/value pair belong"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_ProgressionSnapshot_DeleteSnapshotOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_ProgressionSnapshot_DeleteSnapshotOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_ProgressionSnapshot_DeleteSnapshotOptions>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_ProgressionSnapshot_DeleteSnapshotOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_ProgressionSnapshot_DeleteSnapshotOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_ProgressionSnapshot_DeleteSnapshotOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_ProgressionSnapshot_DeleteSnapshotOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_ProgressionSnapshot_DeleteSnapshotOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_ProgressionSnapshot_DeleteSnapshotOptions =
    _tagEOS_ProgressionSnapshot_DeleteSnapshotOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_ProgressionSnapshot_DeleteSnapshotCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " The Product User ID of the local user to whom the key/value pair belong"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Context that was passed into EOS_ProgressionSnapshot_SubmitSnapshot."]
    pub ClientData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__tagEOS_ProgressionSnapshot_DeleteSnapshotCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_ProgressionSnapshot_DeleteSnapshotCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_ProgressionSnapshot_DeleteSnapshotCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_ProgressionSnapshot_DeleteSnapshotCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_ProgressionSnapshot_DeleteSnapshotCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_ProgressionSnapshot_DeleteSnapshotCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_ProgressionSnapshot_DeleteSnapshotCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_ProgressionSnapshot_DeleteSnapshotCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_ProgressionSnapshot_DeleteSnapshotCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
}
pub type EOS_ProgressionSnapshot_DeleteSnapshotCallbackInfo =
    _tagEOS_ProgressionSnapshot_DeleteSnapshotCallbackInfo;
pub type EOS_ProgressionSnapshot_OnDeleteSnapshotCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_ProgressionSnapshot_DeleteSnapshotCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EOS_CustomInvitesHandle {
    _unused: [u8; 0],
}
#[doc = " Handle to the custom invites interface"]
pub type EOS_HCustomInvites = *mut EOS_CustomInvitesHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_CustomInvites_SetCustomInviteOptions {
    #[doc = " API Version: Set this to EOS_CUSTOMINVITES_SETCUSTOMINVITE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Local user creating / sending a Custom Invite"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " String payload for the Custom Invite (must be less than EOS_CUSTOMINVITES_MAX_PAYLOAD_LENGTH)"]
    pub Payload: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_CustomInvites_SetCustomInviteOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_CustomInvites_SetCustomInviteOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_CustomInvites_SetCustomInviteOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_CustomInvites_SetCustomInviteOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_CustomInvites_SetCustomInviteOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_CustomInvites_SetCustomInviteOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_SetCustomInviteOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_SetCustomInviteOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Payload) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_SetCustomInviteOptions),
            "::",
            stringify!(Payload)
        )
    );
}
pub type EOS_CustomInvites_SetCustomInviteOptions = _tagEOS_CustomInvites_SetCustomInviteOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_CustomInvites_SendCustomInviteOptions {
    #[doc = " API Version: Set this to EOS_CUSTOMINVITES_SENDCUSTOMINVITE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Local user sending a CustomInvite"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Users to whom the invites should be sent"]
    pub TargetUserIds: *mut EOS_ProductUserId,
    #[doc = " The number of users we are sending to"]
    pub TargetUserIdsCount: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_CustomInvites_SendCustomInviteOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_CustomInvites_SendCustomInviteOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_CustomInvites_SendCustomInviteOptions>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_CustomInvites_SendCustomInviteOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_CustomInvites_SendCustomInviteOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_CustomInvites_SendCustomInviteOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_SendCustomInviteOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_SendCustomInviteOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserIds) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_SendCustomInviteOptions),
            "::",
            stringify!(TargetUserIds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserIdsCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_SendCustomInviteOptions),
            "::",
            stringify!(TargetUserIdsCount)
        )
    );
}
pub type EOS_CustomInvites_SendCustomInviteOptions = _tagEOS_CustomInvites_SendCustomInviteOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_CustomInvites_SendCustomInviteCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_CustomInvites_SendCustomInvite"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Local user sending a CustomInvite"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Users to whom the invites were successfully sent (can be different than original call if an invite for same Payload was previously sent)"]
    pub TargetUserIds: *mut EOS_ProductUserId,
    #[doc = " The number of users we are sending to"]
    pub TargetUserIdsCount: u32,
}
#[test]
fn bindgen_test_layout__tagEOS_CustomInvites_SendCustomInviteCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_CustomInvites_SendCustomInviteCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_CustomInvites_SendCustomInviteCallbackInfo>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_CustomInvites_SendCustomInviteCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_CustomInvites_SendCustomInviteCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_CustomInvites_SendCustomInviteCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_SendCustomInviteCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_SendCustomInviteCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_SendCustomInviteCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserIds) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_SendCustomInviteCallbackInfo),
            "::",
            stringify!(TargetUserIds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserIdsCount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_SendCustomInviteCallbackInfo),
            "::",
            stringify!(TargetUserIdsCount)
        )
    );
}
pub type EOS_CustomInvites_SendCustomInviteCallbackInfo =
    _tagEOS_CustomInvites_SendCustomInviteCallbackInfo;
pub type EOS_CustomInvites_OnSendCustomInviteCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_CustomInvites_SendCustomInviteCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_CustomInvites_AddNotifyCustomInviteReceivedOptions {
    #[doc = " API Version: Set this to EOS_CUSTOMINVITES_ADDNOTIFYCUSTOMINVITERECEIVED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_CustomInvites_AddNotifyCustomInviteReceivedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_CustomInvites_AddNotifyCustomInviteReceivedOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_CustomInvites_AddNotifyCustomInviteReceivedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_CustomInvites_AddNotifyCustomInviteReceivedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_CustomInvites_AddNotifyCustomInviteReceivedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_CustomInvites_AddNotifyCustomInviteReceivedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_AddNotifyCustomInviteReceivedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_CustomInvites_AddNotifyCustomInviteReceivedOptions =
    _tagEOS_CustomInvites_AddNotifyCustomInviteReceivedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_CustomInvites_OnCustomInviteReceivedCallbackInfo {
    #[doc = " Context that was passed into EOS_CustomInvites_AddNotifyCustomInviteReceived"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " User that sent this custom invite"]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " Recipient Local user id"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Id of the received Custom Invite"]
    pub CustomInviteId: *const ::std::os::raw::c_char,
    #[doc = " Payload of the received Custom Invite"]
    pub Payload: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_CustomInvites_OnCustomInviteReceivedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_CustomInvites_OnCustomInviteReceivedCallbackInfo,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_CustomInvites_OnCustomInviteReceivedCallbackInfo>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_CustomInvites_OnCustomInviteReceivedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_CustomInvites_OnCustomInviteReceivedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_CustomInvites_OnCustomInviteReceivedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_OnCustomInviteReceivedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_OnCustomInviteReceivedCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_OnCustomInviteReceivedCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CustomInviteId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_OnCustomInviteReceivedCallbackInfo),
            "::",
            stringify!(CustomInviteId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Payload) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_OnCustomInviteReceivedCallbackInfo),
            "::",
            stringify!(Payload)
        )
    );
}
pub type EOS_CustomInvites_OnCustomInviteReceivedCallbackInfo =
    _tagEOS_CustomInvites_OnCustomInviteReceivedCallbackInfo;
pub type EOS_CustomInvites_OnCustomInviteReceivedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_CustomInvites_OnCustomInviteReceivedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_CustomInvites_AddNotifyCustomInviteAcceptedOptions {
    #[doc = " API Version: Set this to EOS_CUSTOMINVITES_ADDNOTIFYCUSTOMINVITEACCEPTED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_CustomInvites_AddNotifyCustomInviteAcceptedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_CustomInvites_AddNotifyCustomInviteAcceptedOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_CustomInvites_AddNotifyCustomInviteAcceptedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_CustomInvites_AddNotifyCustomInviteAcceptedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_CustomInvites_AddNotifyCustomInviteAcceptedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_CustomInvites_AddNotifyCustomInviteAcceptedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_AddNotifyCustomInviteAcceptedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_CustomInvites_AddNotifyCustomInviteAcceptedOptions =
    _tagEOS_CustomInvites_AddNotifyCustomInviteAcceptedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_CustomInvites_OnCustomInviteAcceptedCallbackInfo {
    #[doc = " Context that was passed into EOS_CustomInvites_AddNotifyCustomInviteAccepted"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " User that sent the custom invite"]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " Recipient Local user id"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Id of the accepted Custom Invite"]
    pub CustomInviteId: *const ::std::os::raw::c_char,
    #[doc = " Payload of the accepted Custom Invite"]
    pub Payload: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_CustomInvites_OnCustomInviteAcceptedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_CustomInvites_OnCustomInviteAcceptedCallbackInfo,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_CustomInvites_OnCustomInviteAcceptedCallbackInfo>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_CustomInvites_OnCustomInviteAcceptedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_CustomInvites_OnCustomInviteAcceptedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_CustomInvites_OnCustomInviteAcceptedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_OnCustomInviteAcceptedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_OnCustomInviteAcceptedCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_OnCustomInviteAcceptedCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CustomInviteId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_OnCustomInviteAcceptedCallbackInfo),
            "::",
            stringify!(CustomInviteId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Payload) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_OnCustomInviteAcceptedCallbackInfo),
            "::",
            stringify!(Payload)
        )
    );
}
pub type EOS_CustomInvites_OnCustomInviteAcceptedCallbackInfo =
    _tagEOS_CustomInvites_OnCustomInviteAcceptedCallbackInfo;
pub type EOS_CustomInvites_OnCustomInviteAcceptedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_CustomInvites_OnCustomInviteAcceptedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_CustomInvites_AddNotifyCustomInviteRejectedOptions {
    #[doc = " API Version: Set this to EOS_CUSTOMINVITES_ADDNOTIFYCUSTOMINVITEREJECTED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_CustomInvites_AddNotifyCustomInviteRejectedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_CustomInvites_AddNotifyCustomInviteRejectedOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_CustomInvites_AddNotifyCustomInviteRejectedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_CustomInvites_AddNotifyCustomInviteRejectedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_CustomInvites_AddNotifyCustomInviteRejectedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_CustomInvites_AddNotifyCustomInviteRejectedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_AddNotifyCustomInviteRejectedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_CustomInvites_AddNotifyCustomInviteRejectedOptions =
    _tagEOS_CustomInvites_AddNotifyCustomInviteRejectedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_CustomInvites_CustomInviteRejectedCallbackInfo {
    #[doc = " Context that was passed into EOS_CustomInvites_AddNotifyCustomInviteRejected"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " User that sent the custom invite"]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " Recipient Local user id"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Id of the rejected Custom Invite"]
    pub CustomInviteId: *const ::std::os::raw::c_char,
    #[doc = " Payload of the rejected Custom Invite"]
    pub Payload: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_CustomInvites_CustomInviteRejectedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_CustomInvites_CustomInviteRejectedCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_CustomInvites_CustomInviteRejectedCallbackInfo>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_CustomInvites_CustomInviteRejectedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_CustomInvites_CustomInviteRejectedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_CustomInvites_CustomInviteRejectedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_CustomInviteRejectedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_CustomInviteRejectedCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_CustomInviteRejectedCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CustomInviteId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_CustomInviteRejectedCallbackInfo),
            "::",
            stringify!(CustomInviteId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Payload) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_CustomInviteRejectedCallbackInfo),
            "::",
            stringify!(Payload)
        )
    );
}
pub type EOS_CustomInvites_CustomInviteRejectedCallbackInfo =
    _tagEOS_CustomInvites_CustomInviteRejectedCallbackInfo;
pub type EOS_CustomInvites_OnCustomInviteRejectedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_CustomInvites_CustomInviteRejectedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_CustomInvites_FinalizeInviteOptions {
    #[doc = " API Version: Set this to EOS_CUSTOMINVITES_FINALIZEINVITE_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " User that sent the custom invite"]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " Recipient Local user id"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Id of the Custom Invite accepted"]
    pub CustomInviteId: *const ::std::os::raw::c_char,
    #[doc = " Result of the Processing operation, transmitted to Social Overlay if applicable"]
    pub ProcessingResult: EOS_EResult,
}
#[test]
fn bindgen_test_layout__tagEOS_CustomInvites_FinalizeInviteOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_CustomInvites_FinalizeInviteOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_CustomInvites_FinalizeInviteOptions>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_CustomInvites_FinalizeInviteOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_CustomInvites_FinalizeInviteOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_CustomInvites_FinalizeInviteOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_FinalizeInviteOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_FinalizeInviteOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_FinalizeInviteOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CustomInviteId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_FinalizeInviteOptions),
            "::",
            stringify!(CustomInviteId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProcessingResult) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_FinalizeInviteOptions),
            "::",
            stringify!(ProcessingResult)
        )
    );
}
pub type EOS_CustomInvites_FinalizeInviteOptions = _tagEOS_CustomInvites_FinalizeInviteOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_CustomInvites_SendRequestToJoinOptions {
    #[doc = " API Version: Set this to EOS_CUSTOMINVITES_SENDREQUESTTOJOIN_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Local user Requesting an Invite"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Recipient of Request Invite"]
    pub TargetUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_CustomInvites_SendRequestToJoinOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_CustomInvites_SendRequestToJoinOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_CustomInvites_SendRequestToJoinOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_CustomInvites_SendRequestToJoinOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_CustomInvites_SendRequestToJoinOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_CustomInvites_SendRequestToJoinOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_SendRequestToJoinOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_SendRequestToJoinOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_SendRequestToJoinOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_CustomInvites_SendRequestToJoinOptions =
    _tagEOS_CustomInvites_SendRequestToJoinOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_CustomInvites_SendRequestToJoinCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_CustomInvites_SendRequestToJoin"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Local user requesting an invite"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Recipient of Request Invite"]
    pub TargetUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_CustomInvites_SendRequestToJoinCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_CustomInvites_SendRequestToJoinCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_CustomInvites_SendRequestToJoinCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_CustomInvites_SendRequestToJoinCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_CustomInvites_SendRequestToJoinCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_CustomInvites_SendRequestToJoinCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_SendRequestToJoinCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_SendRequestToJoinCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_SendRequestToJoinCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_SendRequestToJoinCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_CustomInvites_SendRequestToJoinCallbackInfo =
    _tagEOS_CustomInvites_SendRequestToJoinCallbackInfo;
pub type EOS_CustomInvites_OnSendRequestToJoinCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_CustomInvites_SendRequestToJoinCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_CustomInvites_AddNotifyRequestToJoinResponseReceivedOptions {
    #[doc = " API Version: Set this to EOS_CUSTOMINVITES_ADDNOTIFYREQUESTTOJOINRESPONSERECEIVED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_CustomInvites_AddNotifyRequestToJoinResponseReceivedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_CustomInvites_AddNotifyRequestToJoinResponseReceivedOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_CustomInvites_AddNotifyRequestToJoinResponseReceivedOptions>(
        ),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_CustomInvites_AddNotifyRequestToJoinResponseReceivedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_CustomInvites_AddNotifyRequestToJoinResponseReceivedOptions>(
        ),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_CustomInvites_AddNotifyRequestToJoinResponseReceivedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_AddNotifyRequestToJoinResponseReceivedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_CustomInvites_AddNotifyRequestToJoinResponseReceivedOptions =
    _tagEOS_CustomInvites_AddNotifyRequestToJoinResponseReceivedOptions;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EOS_ERequestToJoinResponse {
    #[doc = " The target of the invite request has accepted."]
    EOS_RTJR_ACCEPTED = 0,
    #[doc = " The target of the invite request has rejected."]
    EOS_RTJR_REJECTED = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_CustomInvites_RequestToJoinResponseReceivedCallbackInfo {
    #[doc = " Context that was passed into EOS_CustomInvites_AddNotifyRequestToJoinResponseReceived"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " User that sent this response"]
    pub FromUserId: EOS_ProductUserId,
    #[doc = " Recipient Local user id"]
    pub ToUserId: EOS_ProductUserId,
    #[doc = " The Intent associated with this response"]
    pub Response: EOS_ERequestToJoinResponse,
}
#[test]
fn bindgen_test_layout__tagEOS_CustomInvites_RequestToJoinResponseReceivedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_CustomInvites_RequestToJoinResponseReceivedCallbackInfo,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_CustomInvites_RequestToJoinResponseReceivedCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_CustomInvites_RequestToJoinResponseReceivedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_CustomInvites_RequestToJoinResponseReceivedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_CustomInvites_RequestToJoinResponseReceivedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_RequestToJoinResponseReceivedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FromUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_RequestToJoinResponseReceivedCallbackInfo),
            "::",
            stringify!(FromUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ToUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_RequestToJoinResponseReceivedCallbackInfo),
            "::",
            stringify!(ToUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Response) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_RequestToJoinResponseReceivedCallbackInfo),
            "::",
            stringify!(Response)
        )
    );
}
pub type EOS_CustomInvites_RequestToJoinResponseReceivedCallbackInfo =
    _tagEOS_CustomInvites_RequestToJoinResponseReceivedCallbackInfo;
pub type EOS_CustomInvites_OnRequestToJoinResponseReceivedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_CustomInvites_RequestToJoinResponseReceivedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_CustomInvites_AddNotifyRequestToJoinReceivedOptions {
    #[doc = " API Version: Set this to EOS_CUSTOMINVITES_ADDNOTIFYREQUESTTOJOINRECEIVED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_CustomInvites_AddNotifyRequestToJoinReceivedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_CustomInvites_AddNotifyRequestToJoinReceivedOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_CustomInvites_AddNotifyRequestToJoinReceivedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_CustomInvites_AddNotifyRequestToJoinReceivedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_CustomInvites_AddNotifyRequestToJoinReceivedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_CustomInvites_AddNotifyRequestToJoinReceivedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_AddNotifyRequestToJoinReceivedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_CustomInvites_AddNotifyRequestToJoinReceivedOptions =
    _tagEOS_CustomInvites_AddNotifyRequestToJoinReceivedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_CustomInvites_RequestToJoinReceivedCallbackInfo {
    #[doc = " Context that was passed into EOS_CustomInvites_AddNotifyRequestToJoinReceived"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " User that sent this response"]
    pub FromUserId: EOS_ProductUserId,
    #[doc = " Recipient Local user id"]
    pub ToUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_CustomInvites_RequestToJoinReceivedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_CustomInvites_RequestToJoinReceivedCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_CustomInvites_RequestToJoinReceivedCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_CustomInvites_RequestToJoinReceivedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_CustomInvites_RequestToJoinReceivedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_CustomInvites_RequestToJoinReceivedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_RequestToJoinReceivedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FromUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_RequestToJoinReceivedCallbackInfo),
            "::",
            stringify!(FromUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ToUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_RequestToJoinReceivedCallbackInfo),
            "::",
            stringify!(ToUserId)
        )
    );
}
pub type EOS_CustomInvites_RequestToJoinReceivedCallbackInfo =
    _tagEOS_CustomInvites_RequestToJoinReceivedCallbackInfo;
pub type EOS_CustomInvites_OnRequestToJoinReceivedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_CustomInvites_RequestToJoinReceivedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_CustomInvites_AcceptRequestToJoinOptions {
    #[doc = " API Version: Set this to EOS_CUSTOMINVITES_ACCEPTREQUESTTOJOIN_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Local user accepting a request to join"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Target user that sent original request to join"]
    pub TargetUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_CustomInvites_AcceptRequestToJoinOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_CustomInvites_AcceptRequestToJoinOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_CustomInvites_AcceptRequestToJoinOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_CustomInvites_AcceptRequestToJoinOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_CustomInvites_AcceptRequestToJoinOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_CustomInvites_AcceptRequestToJoinOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_AcceptRequestToJoinOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_AcceptRequestToJoinOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_AcceptRequestToJoinOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_CustomInvites_AcceptRequestToJoinOptions =
    _tagEOS_CustomInvites_AcceptRequestToJoinOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_CustomInvites_AcceptRequestToJoinCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_CustomInvites_AcceptRequestToJoin"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Local user accepting an invite request"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Target user that sent original invite request"]
    pub TargetUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_CustomInvites_AcceptRequestToJoinCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_CustomInvites_AcceptRequestToJoinCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_CustomInvites_AcceptRequestToJoinCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_CustomInvites_AcceptRequestToJoinCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_CustomInvites_AcceptRequestToJoinCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_CustomInvites_AcceptRequestToJoinCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_AcceptRequestToJoinCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_AcceptRequestToJoinCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_AcceptRequestToJoinCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_AcceptRequestToJoinCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_CustomInvites_AcceptRequestToJoinCallbackInfo =
    _tagEOS_CustomInvites_AcceptRequestToJoinCallbackInfo;
pub type EOS_CustomInvites_OnAcceptRequestToJoinCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_CustomInvites_AcceptRequestToJoinCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_CustomInvites_RejectRequestToJoinOptions {
    #[doc = " API Version: Set this to EOS_CUSTOMINVITES_REJECTREQUESTTOJOIN_API_LATEST."]
    pub ApiVersion: i32,
    #[doc = " Local user declining an invite request"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Target user that sent original invite request"]
    pub TargetUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_CustomInvites_RejectRequestToJoinOptions() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_CustomInvites_RejectRequestToJoinOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_CustomInvites_RejectRequestToJoinOptions>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_CustomInvites_RejectRequestToJoinOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_CustomInvites_RejectRequestToJoinOptions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_CustomInvites_RejectRequestToJoinOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_RejectRequestToJoinOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_RejectRequestToJoinOptions),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_RejectRequestToJoinOptions),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_CustomInvites_RejectRequestToJoinOptions =
    _tagEOS_CustomInvites_RejectRequestToJoinOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_CustomInvites_RejectRequestToJoinCallbackInfo {
    #[doc = " The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors."]
    pub ResultCode: EOS_EResult,
    #[doc = " Context that was passed into EOS_CustomInvites_RejectRequestToJoin"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Local user declining a request to join"]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " Target user that sent original request to join"]
    pub TargetUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_CustomInvites_RejectRequestToJoinCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_tagEOS_CustomInvites_RejectRequestToJoinCallbackInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_CustomInvites_RejectRequestToJoinCallbackInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_CustomInvites_RejectRequestToJoinCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_CustomInvites_RejectRequestToJoinCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_CustomInvites_RejectRequestToJoinCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_RejectRequestToJoinCallbackInfo),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_RejectRequestToJoinCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_RejectRequestToJoinCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_RejectRequestToJoinCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
}
pub type EOS_CustomInvites_RejectRequestToJoinCallbackInfo =
    _tagEOS_CustomInvites_RejectRequestToJoinCallbackInfo;
pub type EOS_CustomInvites_OnRejectRequestToJoinCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_CustomInvites_RejectRequestToJoinCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_CustomInvites_AddNotifySendCustomNativeInviteRequestedOptions {
    #[doc = " API Version: Set this to EOS_CUSTOMINVITES_ADDNOTIFYSENDCUSTOMNATIVEINVITEREQUESTED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_CustomInvites_AddNotifySendCustomNativeInviteRequestedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_CustomInvites_AddNotifySendCustomNativeInviteRequestedOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_CustomInvites_AddNotifySendCustomNativeInviteRequestedOptions>(
        ),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_CustomInvites_AddNotifySendCustomNativeInviteRequestedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_CustomInvites_AddNotifySendCustomNativeInviteRequestedOptions>(
        ),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_CustomInvites_AddNotifySendCustomNativeInviteRequestedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_AddNotifySendCustomNativeInviteRequestedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_CustomInvites_AddNotifySendCustomNativeInviteRequestedOptions =
    _tagEOS_CustomInvites_AddNotifySendCustomNativeInviteRequestedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_CustomInvites_SendCustomNativeInviteRequestedCallbackInfo {
    #[doc = " Context that was passed into EOS_CustomInvites_AddNotifySendCustomNativeInviteRequested"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " Identifies this event which will need to be acknowledged with EOS_UI_AcknowledgeEventId().\n @see EOS_UI_AcknowledgeEventId"]
    pub UiEventId: EOS_UI_EventId,
    #[doc = " The Product User ID of the local user who is inviting."]
    pub LocalUserId: EOS_ProductUserId,
    #[doc = " The Native Platform Account Type. If only a single integrated platform is configured then\n this will always reference that platform."]
    pub TargetNativeAccountType: EOS_IntegratedPlatformType,
    #[doc = " The Native Platform Account ID of the target user being invited."]
    pub TargetUserNativeAccountId: *const ::std::os::raw::c_char,
    #[doc = " Invite ID that the user is being invited to"]
    pub InviteId: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__tagEOS_CustomInvites_SendCustomNativeInviteRequestedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_CustomInvites_SendCustomNativeInviteRequestedCallbackInfo,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_CustomInvites_SendCustomNativeInviteRequestedCallbackInfo>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_CustomInvites_SendCustomNativeInviteRequestedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_CustomInvites_SendCustomNativeInviteRequestedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_CustomInvites_SendCustomNativeInviteRequestedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_SendCustomNativeInviteRequestedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UiEventId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_SendCustomNativeInviteRequestedCallbackInfo),
            "::",
            stringify!(UiEventId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_SendCustomNativeInviteRequestedCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetNativeAccountType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_SendCustomNativeInviteRequestedCallbackInfo),
            "::",
            stringify!(TargetNativeAccountType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserNativeAccountId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_SendCustomNativeInviteRequestedCallbackInfo),
            "::",
            stringify!(TargetUserNativeAccountId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InviteId) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_SendCustomNativeInviteRequestedCallbackInfo),
            "::",
            stringify!(InviteId)
        )
    );
}
pub type EOS_CustomInvites_SendCustomNativeInviteRequestedCallbackInfo =
    _tagEOS_CustomInvites_SendCustomNativeInviteRequestedCallbackInfo;
pub type EOS_CustomInvites_OnSendCustomNativeInviteRequestedCallback = ::std::option::Option<
    unsafe extern "C" fn(
        Data: *const EOS_CustomInvites_SendCustomNativeInviteRequestedCallbackInfo,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_CustomInvites_AddNotifyRequestToJoinAcceptedOptions {
    #[doc = " API Version: Set this to EOS_CUSTOMINVITES_ADDNOTIFYREQUESTTOJOINACCEPTED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_CustomInvites_AddNotifyRequestToJoinAcceptedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_CustomInvites_AddNotifyRequestToJoinAcceptedOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_CustomInvites_AddNotifyRequestToJoinAcceptedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_CustomInvites_AddNotifyRequestToJoinAcceptedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_CustomInvites_AddNotifyRequestToJoinAcceptedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_CustomInvites_AddNotifyRequestToJoinAcceptedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_AddNotifyRequestToJoinAcceptedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_CustomInvites_AddNotifyRequestToJoinAcceptedOptions =
    _tagEOS_CustomInvites_AddNotifyRequestToJoinAcceptedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_CustomInvites_OnRequestToJoinAcceptedCallbackInfo {
    #[doc = " Context that was passed into EOS_CustomInvites_AddNotifyRequestToJoinAccepted"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " User that sent the request to join"]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " Local user ID of the Request to Join recipient"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_CustomInvites_OnRequestToJoinAcceptedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_CustomInvites_OnRequestToJoinAcceptedCallbackInfo,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_CustomInvites_OnRequestToJoinAcceptedCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_CustomInvites_OnRequestToJoinAcceptedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_CustomInvites_OnRequestToJoinAcceptedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_CustomInvites_OnRequestToJoinAcceptedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_OnRequestToJoinAcceptedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_OnRequestToJoinAcceptedCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_OnRequestToJoinAcceptedCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_CustomInvites_OnRequestToJoinAcceptedCallbackInfo =
    _tagEOS_CustomInvites_OnRequestToJoinAcceptedCallbackInfo;
pub type EOS_CustomInvites_OnRequestToJoinAcceptedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_CustomInvites_OnRequestToJoinAcceptedCallbackInfo),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_CustomInvites_AddNotifyRequestToJoinRejectedOptions {
    #[doc = " API Version: Set this to EOS_CUSTOMINVITES_ADDNOTIFYREQUESTTOJOINREJECTED_API_LATEST."]
    pub ApiVersion: i32,
}
#[test]
fn bindgen_test_layout__tagEOS_CustomInvites_AddNotifyRequestToJoinRejectedOptions() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_CustomInvites_AddNotifyRequestToJoinRejectedOptions,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_CustomInvites_AddNotifyRequestToJoinRejectedOptions>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_CustomInvites_AddNotifyRequestToJoinRejectedOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_CustomInvites_AddNotifyRequestToJoinRejectedOptions>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_CustomInvites_AddNotifyRequestToJoinRejectedOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_AddNotifyRequestToJoinRejectedOptions),
            "::",
            stringify!(ApiVersion)
        )
    );
}
pub type EOS_CustomInvites_AddNotifyRequestToJoinRejectedOptions =
    _tagEOS_CustomInvites_AddNotifyRequestToJoinRejectedOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagEOS_CustomInvites_OnRequestToJoinRejectedCallbackInfo {
    #[doc = " Context that was passed into EOS_CustomInvites_AddNotifyCustomInviteRejected"]
    pub ClientData: *mut ::std::os::raw::c_void,
    #[doc = " User that sent the custom invite"]
    pub TargetUserId: EOS_ProductUserId,
    #[doc = " Recipient Local user id"]
    pub LocalUserId: EOS_ProductUserId,
}
#[test]
fn bindgen_test_layout__tagEOS_CustomInvites_OnRequestToJoinRejectedCallbackInfo() {
    const UNINIT: ::std::mem::MaybeUninit<
        _tagEOS_CustomInvites_OnRequestToJoinRejectedCallbackInfo,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_tagEOS_CustomInvites_OnRequestToJoinRejectedCallbackInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_tagEOS_CustomInvites_OnRequestToJoinRejectedCallbackInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_tagEOS_CustomInvites_OnRequestToJoinRejectedCallbackInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_tagEOS_CustomInvites_OnRequestToJoinRejectedCallbackInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_OnRequestToJoinRejectedCallbackInfo),
            "::",
            stringify!(ClientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetUserId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_OnRequestToJoinRejectedCallbackInfo),
            "::",
            stringify!(TargetUserId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalUserId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_tagEOS_CustomInvites_OnRequestToJoinRejectedCallbackInfo),
            "::",
            stringify!(LocalUserId)
        )
    );
}
pub type EOS_CustomInvites_OnRequestToJoinRejectedCallbackInfo =
    _tagEOS_CustomInvites_OnRequestToJoinRejectedCallbackInfo;
pub type EOS_CustomInvites_OnRequestToJoinRejectedCallback = ::std::option::Option<
    unsafe extern "C" fn(Data: *const EOS_CustomInvites_OnRequestToJoinRejectedCallbackInfo),
>;
extern "C" {
    #[doc = " Notify the platform instance to do work. This function must be called frequently in order for the services provided by the SDK to properly\n function. For tick-based applications, it is usually desirable to call this once per-tick."]
    pub fn EOS_Platform_Tick(Handle: EOS_HPlatform);
}
extern "C" {
    #[doc = " Get a handle to the Metrics Interface.\n @return EOS_HMetrics handle\n\n @see eos_metrics.h\n @see eos_metrics_types.h"]
    pub fn EOS_Platform_GetMetricsInterface(Handle: EOS_HPlatform) -> EOS_HMetrics;
}
extern "C" {
    #[doc = " Get a handle to the Auth Interface.\n @return EOS_HAuth handle\n\n @see eos_auth.h\n @see eos_auth_types.h"]
    pub fn EOS_Platform_GetAuthInterface(Handle: EOS_HPlatform) -> EOS_HAuth;
}
extern "C" {
    #[doc = " Get a handle to the Connect Interface.\n @return EOS_HConnect handle\n\n @see eos_connect.h\n @see eos_connect_types.h"]
    pub fn EOS_Platform_GetConnectInterface(Handle: EOS_HPlatform) -> EOS_HConnect;
}
extern "C" {
    #[doc = " Get a handle to the Ecom Interface.\n @return EOS_HEcom handle\n\n @see eos_ecom.h\n @see eos_ecom_types.h"]
    pub fn EOS_Platform_GetEcomInterface(Handle: EOS_HPlatform) -> EOS_HEcom;
}
extern "C" {
    #[doc = " Get a handle to the UI Interface.\n @return EOS_HUI handle\n\n @see eos_ui.h\n @see eos_ui_types.h"]
    pub fn EOS_Platform_GetUIInterface(Handle: EOS_HPlatform) -> EOS_HUI;
}
extern "C" {
    #[doc = " Get a handle to the Friends Interface.\n @return EOS_HFriends handle\n\n @see eos_friends.h\n @see eos_friends_types.h"]
    pub fn EOS_Platform_GetFriendsInterface(Handle: EOS_HPlatform) -> EOS_HFriends;
}
extern "C" {
    #[doc = " Get a handle to the Presence Interface.\n @return EOS_HPresence handle\n\n @see eos_presence.h\n @see eos_presence_types.h"]
    pub fn EOS_Platform_GetPresenceInterface(Handle: EOS_HPlatform) -> EOS_HPresence;
}
extern "C" {
    #[doc = " Get a handle to the Sessions Interface.\n @return EOS_HSessions handle\n\n @see eos_sessions.h\n @see eos_sessions_types.h"]
    pub fn EOS_Platform_GetSessionsInterface(Handle: EOS_HPlatform) -> EOS_HSessions;
}
extern "C" {
    #[doc = " Get a handle to the Lobby Interface.\n @return EOS_HLobby handle\n\n @see eos_lobby.h\n @see eos_lobby_types.h"]
    pub fn EOS_Platform_GetLobbyInterface(Handle: EOS_HPlatform) -> EOS_HLobby;
}
extern "C" {
    #[doc = " Get a handle to the UserInfo Interface.\n @return EOS_HUserInfo handle\n\n @see eos_userinfo.h\n @see eos_userinfo_types.h"]
    pub fn EOS_Platform_GetUserInfoInterface(Handle: EOS_HPlatform) -> EOS_HUserInfo;
}
extern "C" {
    #[doc = " Get a handle to the Peer-to-Peer Networking Interface.\n @return EOS_HP2P handle\n\n @see eos_p2p.h\n @see eos_p2p_types.h"]
    pub fn EOS_Platform_GetP2PInterface(Handle: EOS_HPlatform) -> EOS_HP2P;
}
extern "C" {
    #[doc = " Get a handle to the Real Time Communications Interface (RTC).\n From the RTC interface you can retrieve the handle to the audio interface (RTCAudio), which is a component of RTC.\n @return EOS_HRTC handle\n\n @see EOS_RTC_GetAudioInterface\n @see eos_rtc.h\n @see eos_rtc_types.h"]
    pub fn EOS_Platform_GetRTCInterface(Handle: EOS_HPlatform) -> EOS_HRTC;
}
extern "C" {
    #[doc = " Get a handle to the RTC Admin interface\n @return EOS_HRTCAdmin handle\n\n @see eos_rtc_admin.h\n @see eos_admin_types.h"]
    pub fn EOS_Platform_GetRTCAdminInterface(Handle: EOS_HPlatform) -> EOS_HRTCAdmin;
}
extern "C" {
    #[doc = " Get a handle to the PlayerDataStorage Interface.\n @return EOS_HPlayerDataStorage handle\n\n @see eos_playerdatastorage.h\n @see eos_playerdatastorage_types.h"]
    pub fn EOS_Platform_GetPlayerDataStorageInterface(
        Handle: EOS_HPlatform,
    ) -> EOS_HPlayerDataStorage;
}
extern "C" {
    #[doc = " Get a handle to the TitleStorage Interface.\n @return EOS_HTitleStorage handle\n\n @see eos_titlestorage.h\n @see eos_titlestorage_types.h"]
    pub fn EOS_Platform_GetTitleStorageInterface(Handle: EOS_HPlatform) -> EOS_HTitleStorage;
}
extern "C" {
    #[doc = " Get a handle to the Achievements Interface.\n @return EOS_HAchievements handle\n\n @see eos_achievements.h\n @see eos_achievements_types.h"]
    pub fn EOS_Platform_GetAchievementsInterface(Handle: EOS_HPlatform) -> EOS_HAchievements;
}
extern "C" {
    #[doc = " Get a handle to the Stats Interface.\n @return EOS_HStats handle\n\n @see eos_stats.h\n @see eos_stats_types.h"]
    pub fn EOS_Platform_GetStatsInterface(Handle: EOS_HPlatform) -> EOS_HStats;
}
extern "C" {
    #[doc = " Get a handle to the Leaderboards Interface.\n @return EOS_HLeaderboards handle\n\n @see eos_leaderboards.h\n @see eos_leaderboards_types.h"]
    pub fn EOS_Platform_GetLeaderboardsInterface(Handle: EOS_HPlatform) -> EOS_HLeaderboards;
}
extern "C" {
    #[doc = " Get a handle to the Mods Interface.\n @return EOS_HMods handle\n\n @see eos_mods.h\n @see eos_mods_types.h"]
    pub fn EOS_Platform_GetModsInterface(Handle: EOS_HPlatform) -> EOS_HMods;
}
extern "C" {
    #[doc = " Get a handle to the Anti-Cheat Client Interface.\n @return EOS_HAntiCheatClient handle\n\n @see eos_anticheatclient.h\n @see eos_anticheatclient_types.h"]
    pub fn EOS_Platform_GetAntiCheatClientInterface(Handle: EOS_HPlatform) -> EOS_HAntiCheatClient;
}
extern "C" {
    #[doc = " Get a handle to the Anti-Cheat Server Interface.\n @return EOS_HAntiCheatServer handle\n\n @see eos_anticheatserver.h\n @see eos_anticheatserver_types.h"]
    pub fn EOS_Platform_GetAntiCheatServerInterface(Handle: EOS_HPlatform) -> EOS_HAntiCheatServer;
}
extern "C" {
    #[doc = " Get the active country code that the SDK will send to services which require it.\n This returns the override value otherwise it will use the country code of the given user.\n This is currently used for determining pricing.\n Get a handle to the ProgressionSnapshot Interface.\n @return EOS_HProgressionSnapshot handle\n\n @see eos_progressionsnapshot.h\n @see eos_progressionsnapshot_types.h"]
    pub fn EOS_Platform_GetProgressionSnapshotInterface(
        Handle: EOS_HPlatform,
    ) -> EOS_HProgressionSnapshot;
}
extern "C" {
    #[doc = " Get a handle to the Reports Interface.\n @return EOS_HReports handle\n\n @see eos_reports.h\n @see eos_reports_types.h"]
    pub fn EOS_Platform_GetReportsInterface(Handle: EOS_HPlatform) -> EOS_HReports;
}
extern "C" {
    #[doc = " Get a handle to the Sanctions Interface.\n @return EOS_HSanctions handle\n\n @see eos_sanctions.h\n @see eos_sanctions_types.h"]
    pub fn EOS_Platform_GetSanctionsInterface(Handle: EOS_HPlatform) -> EOS_HSanctions;
}
extern "C" {
    #[doc = " Get a handle to the Kids Web Service Interface.\n @return EOS_HKWS handle\n\n @see eos_kws.h\n @see eos_kws_types.h"]
    pub fn EOS_Platform_GetKWSInterface(Handle: EOS_HPlatform) -> EOS_HKWS;
}
extern "C" {
    #[doc = " Get a handle to the Custom Invites Interface.\n @return EOS_HCustomInvites handle\n\n @see eos_custominvites.h\n @see eos_custominvites_types.h"]
    pub fn EOS_Platform_GetCustomInvitesInterface(Handle: EOS_HPlatform) -> EOS_HCustomInvites;
}
extern "C" {
    #[doc = " Get a handle to the Integrated Platform Interface.\n @return EOS_HIntegratedPlatform handle\n\n @see eos_integratedplatform.h\n @see eos_integratedplatform_types.h"]
    pub fn EOS_Platform_GetIntegratedPlatformInterface(
        Handle: EOS_HPlatform,
    ) -> EOS_HIntegratedPlatform;
}
extern "C" {
    #[doc = " This only will return the value set as the override otherwise EOS_NotFound is returned.\n This is not currently used for anything internally.\n\n @param LocalUserId The account to use for lookup if no override exists.\n @param OutBuffer The buffer into which the character data should be written.  The buffer must be long enough to hold a string of EOS_COUNTRYCODE_MAX_LENGTH.\n @param InOutBufferLength The size of the OutBuffer in characters.\n                          The input buffer should include enough space to be null-terminated.\n                          When the function returns, this parameter will be filled with the length of the string copied into OutBuffer.\n\n @return An EOS_EResult that indicates whether the active country code string was copied into the OutBuffer.\n         EOS_Success if the information is available and passed out in OutBuffer\n         EOS_InvalidParameters if you pass a null pointer for the out parameter\n         EOS_NotFound if there is not an override country code for the user.\n         EOS_LimitExceeded - The OutBuffer is not large enough to receive the country code string. InOutBufferLength contains the required minimum length to perform the operation successfully.\n\n @see eos_ecom.h\n @see EOS_COUNTRYCODE_MAX_LENGTH"]
    pub fn EOS_Platform_GetActiveCountryCode(
        Handle: EOS_HPlatform,
        LocalUserId: EOS_EpicAccountId,
        OutBuffer: *mut ::std::os::raw::c_char,
        InOutBufferLength: *mut i32,
    ) -> EOS_EResult;
}
extern "C" {
    #[doc = " Get the active locale code that the SDK will send to services which require it.\n This returns the override value otherwise it will use the locale code of the given user.\n This is used for localization. This follows ISO 639.\n\n @param LocalUserId The account to use for lookup if no override exists.\n @param OutBuffer The buffer into which the character data should be written.  The buffer must be long enough to hold a string of EOS_LOCALECODE_MAX_LENGTH.\n @param InOutBufferLength The size of the OutBuffer in characters.\n                          The input buffer should include enough space to be null-terminated.\n                          When the function returns, this parameter will be filled with the length of the string copied into OutBuffer.\n\n @return An EOS_EResult that indicates whether the active locale code string was copied into the OutBuffer.\n         EOS_Success if the information is available and passed out in OutBuffer\n         EOS_InvalidParameters if you pass a null pointer for the out parameter\n         EOS_NotFound if there is neither an override nor an available locale code for the user.\n         EOS_LimitExceeded - The OutBuffer is not large enough to receive the locale code string. InOutBufferLength contains the required minimum length to perform the operation successfully.\n\n @see eos_ecom.h\n @see EOS_LOCALECODE_MAX_LENGTH"]
    pub fn EOS_Platform_GetActiveLocaleCode(
        Handle: EOS_HPlatform,
        LocalUserId: EOS_EpicAccountId,
        OutBuffer: *mut ::std::os::raw::c_char,
        InOutBufferLength: *mut i32,
    ) -> EOS_EResult;
}
extern "C" {
    #[doc = " Get the override country code that the SDK will send to services which require it.\n This is not currently used for anything internally.\n\n @param OutBuffer The buffer into which the character data should be written.  The buffer must be long enough to hold a string of EOS_COUNTRYCODE_MAX_LENGTH.\n @param InOutBufferLength The size of the OutBuffer in characters.\n                          The input buffer should include enough space to be null-terminated.\n                          When the function returns, this parameter will be filled with the length of the string copied into OutBuffer.\n\n @return An EOS_EResult that indicates whether the override country code string was copied into the OutBuffer.\n         EOS_Success if the information is available and passed out in OutBuffer\n         EOS_InvalidParameters if you pass a null pointer for the out parameter\n         EOS_LimitExceeded - The OutBuffer is not large enough to receive the country code string. InOutBufferLength contains the required minimum length to perform the operation successfully.\n\n @see eos_ecom.h\n @see EOS_COUNTRYCODE_MAX_LENGTH"]
    pub fn EOS_Platform_GetOverrideCountryCode(
        Handle: EOS_HPlatform,
        OutBuffer: *mut ::std::os::raw::c_char,
        InOutBufferLength: *mut i32,
    ) -> EOS_EResult;
}
extern "C" {
    #[doc = " Get the override locale code that the SDK will send to services which require it.\n This is used for localization. This follows ISO 639.\n\n @param OutBuffer The buffer into which the character data should be written.  The buffer must be long enough to hold a string of EOS_LOCALECODE_MAX_LENGTH.\n @param InOutBufferLength The size of the OutBuffer in characters.\n                          The input buffer should include enough space to be null-terminated.\n                          When the function returns, this parameter will be filled with the length of the string copied into OutBuffer.\n\n @return An EOS_EResult that indicates whether the override locale code string was copied into the OutBuffer.\n         EOS_Success if the information is available and passed out in OutBuffer\n         EOS_InvalidParameters if you pass a null pointer for the out parameter\n         EOS_LimitExceeded - The OutBuffer is not large enough to receive the locale code string. InOutBufferLength contains the required minimum length to perform the operation successfully.\n\n @see eos_ecom.h\n @see EOS_LOCALECODE_MAX_LENGTH"]
    pub fn EOS_Platform_GetOverrideLocaleCode(
        Handle: EOS_HPlatform,
        OutBuffer: *mut ::std::os::raw::c_char,
        InOutBufferLength: *mut i32,
    ) -> EOS_EResult;
}
extern "C" {
    #[doc = " Set the override country code that the SDK will send to services which require it.\n This is not currently used for anything internally.\n\n @return An EOS_EResult that indicates whether the override country code string was saved.\n         EOS_Success if the country code was overridden\n         EOS_InvalidParameters if you pass an invalid country code\n\n @see eos_ecom.h\n @see EOS_COUNTRYCODE_MAX_LENGTH"]
    pub fn EOS_Platform_SetOverrideCountryCode(
        Handle: EOS_HPlatform,
        NewCountryCode: *const ::std::os::raw::c_char,
    ) -> EOS_EResult;
}
extern "C" {
    #[doc = " Set the override locale code that the SDK will send to services which require it.\n This is used for localization. This follows ISO 639.\n\n @return An EOS_EResult that indicates whether the override locale code string was saved.\n         EOS_Success if the locale code was overridden\n         EOS_InvalidParameters if you pass an invalid locale code\n\n @see eos_ecom.h\n @see EOS_LOCALECODE_MAX_LENGTH"]
    pub fn EOS_Platform_SetOverrideLocaleCode(
        Handle: EOS_HPlatform,
        NewLocaleCode: *const ::std::os::raw::c_char,
    ) -> EOS_EResult;
}
extern "C" {
    #[doc = " Checks if the app was launched through the Epic Games Launcher, and relaunches it through the Epic Games Launcher if it wasn't.\n\n NOTE: During the call to EOS_Platform_Create, the command line that was used to launch the app is inspected, and if it is\n recognized as coming from the Epic Games Launcher, an environment variable is set to 1. The name of the environment variable\n is defined by EOS_PLATFORM_CHECKFORLAUNCHERANDRESTART_ENV_VAR.\n\n You can force the EOS_Platform_CheckForLauncherAndRestart API to relaunch the title by\n explicitly unsetting this environment variable before calling EOS_Platform_CheckForLauncherAndRestart.\n\n @return An EOS_EResult is returned to indicate success or an error.\n\n EOS_Success is returned if the app is being restarted. You should quit your process as soon as possible.\n EOS_NoChange is returned if the app was already launched through the Epic Launcher, and no action needs to be taken.\n EOS_UnexpectedError is returned if the LauncherCheck module failed to initialize, or the module tried and failed to restart the app."]
    pub fn EOS_Platform_CheckForLauncherAndRestart(Handle: EOS_HPlatform) -> EOS_EResult;
}
extern "C" {
    #[doc = " Windows only.\n Checks that the application is ready to use desktop crossplay functionality, with the necessary prerequisites having been met.\n\n This function verifies that the application was launched through the Bootstrapper application,\n the redistributable service has been installed and is running in the background,\n and that the overlay has been loaded successfully.\n\n On Windows, the desktop crossplay functionality is required to use Epic accounts login\n with applications that are distributed outside the Epic Games Store.\n\n @param Options input structure that specifies the API version.\n @param OutDesktopCrossplayStatusInfo output structure to receive the desktop crossplay status information.\n\n @return An EOS_EResult is returned to indicate success or an error.\n\t\t   EOS_NotImplemented is returned on non-Windows platforms."]
    pub fn EOS_Platform_GetDesktopCrossplayStatus(
        Handle: EOS_HPlatform,
        Options: *const EOS_Platform_GetDesktopCrossplayStatusOptions,
        OutDesktopCrossplayStatusInfo: *mut EOS_Platform_DesktopCrossplayStatusInfo,
    ) -> EOS_EResult;
}
extern "C" {
    #[doc = " Notify a change in application state.\n\n @note Calling SetApplicationStatus must happen before Tick when foregrounding for the cases where we won't get the background notification.\n\n @param NewStatus The new status for the application.\n\n @return An EOS_EResult that indicates whether we changed the application status successfully.\n         EOS_Success if the application was changed successfully.\n         EOS_InvalidParameters if the value of NewStatus is invalid.\n         EOS_NotImplemented if EOS_AS_BackgroundConstrained or EOS_AS_BackgroundUnconstrained are attempted to be set on platforms that do not have such application states."]
    pub fn EOS_Platform_SetApplicationStatus(
        Handle: EOS_HPlatform,
        NewStatus: EOS_EApplicationStatus,
    ) -> EOS_EResult;
}
extern "C" {
    #[doc = " Retrieves the current application state as told to the SDK by the application.\n\n @return The current application status."]
    pub fn EOS_Platform_GetApplicationStatus(Handle: EOS_HPlatform) -> EOS_EApplicationStatus;
}
extern "C" {
    #[doc = " Notify a change in network state.\n\n @param NewStatus The new network status.\n\n @return An EOS_EResult that indicates whether we changed the network status successfully.\n         EOS_Success if the network was changed successfully.\n         EOS_InvalidParameters if the value of NewStatus is invalid."]
    pub fn EOS_Platform_SetNetworkStatus(
        Handle: EOS_HPlatform,
        NewStatus: EOS_ENetworkStatus,
    ) -> EOS_EResult;
}
extern "C" {
    #[doc = " Retrieves the current network state as told to the SDK by the application.\n\n @return The current network status."]
    pub fn EOS_Platform_GetNetworkStatus(Handle: EOS_HPlatform) -> EOS_ENetworkStatus;
}
